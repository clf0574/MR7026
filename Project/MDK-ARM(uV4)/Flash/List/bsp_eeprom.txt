; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outupt\bsp_eeprom.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\outupt\bsp_eeprom.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\outupt\bsp_eeprom.crf ..\..\User\bsp\src\bsp_eeprom.c]
                          THUMB

                          AREA ||i.CopyDataInFlash||, CODE, READONLY, ALIGN=2

                  CopyDataInFlash PROC
;;;526    //复制
;;;527    unsigned char CopyDataInFlash(uint16_t SSAddres,uint16_t DSAddres,uint16_t n)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;528    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;529    	unsigned char buff[8];  //每次复制的数量由数组决定
;;;530     	unsigned char i=8;
00000a  2708              MOVS     r7,#8
;;;531     	while(n>0)
00000c  e022              B        |L1.84|
                  |L1.14|
;;;532        {
;;;533    		if(n>=8)
00000e  2c08              CMP      r4,#8
000010  db04              BLT      |L1.28|
;;;534          	{
;;;535    			i=8;
000012  2708              MOVS     r7,#8
;;;536           		n-=8;
000014  f1a40008          SUB      r0,r4,#8
000018  b284              UXTH     r4,r0
00001a  e001              B        |L1.32|
                  |L1.28|
;;;537          	}
;;;538        else
;;;539        {
;;;540    		i=n;
00001c  b2e7              UXTB     r7,r4
;;;541           	n=0;
00001e  2400              MOVS     r4,#0
                  |L1.32|
;;;542        }
;;;543    
;;;544        //RW24CXX(buffer,SSAddres,i,Control|0x01);
;;;545    	ReadDataFromFlash(SSAddres,buff,i);
000020  463a              MOV      r2,r7
000022  4669              MOV      r1,sp
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       ReadDataFromFlash
;;;546        //RW24CXX(buffer,DSAddres,i,Control&0xfe);
;;;547    	I2C_WP_SET(0);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       I2C_WP_SET
;;;548    	WriteDataToFlash(DSAddres,buff,i);
000030  463a              MOV      r2,r7
000032  4669              MOV      r1,sp
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       WriteDataToFlash
;;;549    	I2C_WP_SET(1);	
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       I2C_WP_SET
;;;550    
;;;551        if(EEP_flag)
000040  4808              LDR      r0,|L1.100|
000042  7800              LDRB     r0,[r0,#0]  ; EEP_flag
000044  b100              CBZ      r0,|L1.72|
;;;552    	{
;;;553           break;
000046  e007              B        |L1.88|
                  |L1.72|
;;;554    	}
;;;555        SSAddres+=8;
000048  f1060008          ADD      r0,r6,#8
00004c  b286              UXTH     r6,r0
;;;556        DSAddres+=8;
00004e  f1050008          ADD      r0,r5,#8
000052  b285              UXTH     r5,r0
                  |L1.84|
000054  2c00              CMP      r4,#0                 ;531
000056  dcda              BGT      |L1.14|
                  |L1.88|
000058  bf00              NOP                            ;553
;;;557       }
;;;558     return(EEP_flag);
00005a  4802              LDR      r0,|L1.100|
00005c  7800              LDRB     r0,[r0,#0]  ; EEP_flag
;;;559    }
00005e  e8bd81fc          POP      {r2-r8,pc}
;;;560    
                          ENDP

000062  0000              DCW      0x0000
                  |L1.100|
                          DCD      EEP_flag

                          AREA ||i.DeleteDataToFlash||, CODE, READONLY, ALIGN=1

                  DeleteDataToFlash PROC
;;;518    //先删除,再把数据搬过来(用copy)
;;;519    u8 DeleteDataToFlash(uint16_t eep_addr,uint16_t n)//,unsigned char Control)
000000  b570              PUSH     {r4-r6,lr}
;;;520    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;521    	FillDataToFlash(0xff,eep_addr,n);//,Control);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  20ff              MOVS     r0,#0xff
00000c  f7fffffe          BL       FillDataToFlash
;;;522    
;;;523    	return 1;
000010  2001              MOVS     r0,#1
;;;524    }
000012  bd70              POP      {r4-r6,pc}
;;;525    
                          ENDP


                          AREA ||i.EraseAllFlash||, CODE, READONLY, ALIGN=1

                  EraseAllFlash PROC
;;;584    //清除所有FLASH
;;;585    void EraseAllFlash(void)
000000  4770              BX       lr
;;;586    {
;;;587    
;;;588    }
;;;589    
                          ENDP


                          AREA ||i.EraseOneFlash||, CODE, READONLY, ALIGN=1

                  EraseOneFlash PROC
;;;590    //清除单个FLASH扇区，每区设定为4K ,根据具体应用修改
;;;591    void EraseOneFlash(uint8_t i)
000000  b570              PUSH     {r4-r6,lr}
;;;592    {
000002  4604              MOV      r4,r0
;;;593           unsigned int tmp;
;;;594    	   if(i<16)
000004  2c10              CMP      r4,#0x10
000006  da06              BGE      |L4.22|
;;;595    	   {
;;;596    			tmp=1024*4*i;
000008  0325              LSLS     r5,r4,#12
;;;597    			FillDataToFlash(0xff,tmp,1024*4-1);
00000a  b2a9              UXTH     r1,r5
00000c  f64072ff          MOV      r2,#0xfff
000010  20ff              MOVS     r0,#0xff
000012  f7fffffe          BL       FillDataToFlash
                  |L4.22|
;;;598    	   }
;;;599    }
000016  bd70              POP      {r4-r6,pc}
;;;600    
                          ENDP


                          AREA ||i.FillDataToFlash||, CODE, READONLY, ALIGN=2

                  FillDataToFlash PROC
;;;442    //用数据FData填充从eep_addr开始的区域
;;;443    u8 FillDataToFlash(uint8_t FData,uint16_t eep_addr,uint16_t n)//,unsigned char Control)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;444    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;445    	unsigned char j=3;
00000a  f04f0803          MOV      r8,#3
;;;446     	while(1)   //
00000e  e054              B        |L5.186|
                  |L5.16|
;;;447        {
;;;448         I2C_Start();
000010  f7fffffe          BL       I2C_Start
;;;449         I2C_wbyte(Control&0xfe); 				//0xa0写，0xa1读
000014  20a0              MOVS     r0,#0xa0
000016  f7fffffe          BL       I2C_wbyte
;;;450         I2C_RecAck();
00001a  f7fffffe          BL       I2C_RecAck
;;;451         if(EEP_flag)
00001e  4829              LDR      r0,|L5.196|
000020  7800              LDRB     r0,[r0,#0]  ; EEP_flag
000022  b100              CBZ      r0,|L5.38|
;;;452    	 {
;;;453            break;
000024  e04a              B        |L5.188|
                  |L5.38|
;;;454    	 }
;;;455         if(EEPALLBYTE>256)           			//有16位地址吗?
;;;456         {
;;;457    	 	I2C_wbyte(eep_addr/256);  			//16位地址
000026  4626              MOV      r6,r4
000028  17e1              ASRS     r1,r4,#31
00002a  eb046111          ADD      r1,r4,r1,LSR #24
00002e  f3c12007          UBFX     r0,r1,#8,#8
000032  f7fffffe          BL       I2C_wbyte
;;;458            I2C_RecAck();
000036  f7fffffe          BL       I2C_RecAck
;;;459            if(EEP_flag)
00003a  4822              LDR      r0,|L5.196|
00003c  7800              LDRB     r0,[r0,#0]  ; EEP_flag
00003e  b100              CBZ      r0,|L5.66|
;;;460    		{
;;;461               break;
000040  e03c              B        |L5.188|
                  |L5.66|
;;;462    		}
;;;463          }
;;;464    
;;;465         I2C_wbyte(eep_addr);          			//8位地址
000042  b2e0              UXTB     r0,r4
000044  f7fffffe          BL       I2C_wbyte
;;;466         I2C_RecAck();
000048  f7fffffe          BL       I2C_RecAck
;;;467         if(EEP_flag)
00004c  481d              LDR      r0,|L5.196|
00004e  7800              LDRB     r0,[r0,#0]  ; EEP_flag
000050  b100              CBZ      r0,|L5.84|
;;;468    	 {
;;;469            break;
000052  e033              B        |L5.188|
                  |L5.84|
;;;470    	 }
;;;471    
;;;472         while(n>0)
000054  e018              B        |L5.136|
                  |L5.86|
;;;473         {
;;;474    	    
;;;475            I2C_wbyte(FData);
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       I2C_wbyte
;;;476            I2C_RecAck();
00005c  f7fffffe          BL       I2C_RecAck
;;;477    
;;;478    		n--;
000060  1e68              SUBS     r0,r5,#1
000062  b285              UXTH     r5,r0
;;;479    
;;;480            if(EEP_flag)
000064  4817              LDR      r0,|L5.196|
000066  7800              LDRB     r0,[r0,#0]  ; EEP_flag
000068  b100              CBZ      r0,|L5.108|
;;;481    		{
;;;482               break;
00006a  e00f              B        |L5.140|
                  |L5.108|
;;;483    		}
;;;484            eep_addr++;
00006c  1c60              ADDS     r0,r4,#1
00006e  b284              UXTH     r4,r0
;;;485    
;;;486            if((eep_addr%PAGESIZE==0))   //跨页
000070  17e1              ASRS     r1,r4,#31
000072  eb046151          ADD      r1,r4,r1,LSR #25
000076  11c9              ASRS     r1,r1,#7
000078  ebb411c1          SUBS     r1,r4,r1,LSL #7
00007c  d104              BNE      |L5.136|
;;;487            {
;;;488    			I2C_Stop();
00007e  f7fffffe          BL       I2C_Stop
;;;489               	eep_delay10ms();
000082  f7fffffe          BL       eep_delay10ms
;;;490               	break;
000086  e001              B        |L5.140|
                  |L5.136|
000088  2d00              CMP      r5,#0                 ;472
00008a  dce4              BGT      |L5.86|
                  |L5.140|
00008c  bf00              NOP                            ;482
;;;491             }
;;;492          }
;;;493    
;;;494         if(n==0)
00008e  b93d              CBNZ     r5,|L5.160|
;;;495         {
;;;496    	 		I2C_Stop();
000090  f7fffffe          BL       I2C_Stop
;;;497            	eep_delay10ms();
000094  f7fffffe          BL       eep_delay10ms
;;;498            	//break;
;;;499    			return(EEP_flag);
000098  480a              LDR      r0,|L5.196|
00009a  7800              LDRB     r0,[r0,#0]  ; EEP_flag
                  |L5.156|
;;;500         }
;;;501         else if(EEP_flag)
;;;502         {
;;;503    	 		if(j--==0)      //允许重试3次
;;;504               	//break;
;;;505    			return(EEP_flag);
;;;506         }
;;;507        }
;;;508     return(EEP_flag);
;;;509    }
00009c  e8bd81f0          POP      {r4-r8,pc}
                  |L5.160|
0000a0  4808              LDR      r0,|L5.196|
0000a2  7800              LDRB     r0,[r0,#0]            ;501  ; EEP_flag
0000a4  b148              CBZ      r0,|L5.186|
0000a6  ea5f0008          MOVS     r0,r8                 ;503
0000aa  f1a80101          SUB      r1,r8,#1              ;503
0000ae  f00108ff          AND      r8,r1,#0xff           ;503
0000b2  d102              BNE      |L5.186|
0000b4  4803              LDR      r0,|L5.196|
0000b6  7800              LDRB     r0,[r0,#0]            ;505  ; EEP_flag
0000b8  e7f0              B        |L5.156|
                  |L5.186|
0000ba  e7a9              B        |L5.16|
                  |L5.188|
0000bc  bf00              NOP                            ;453
0000be  4801              LDR      r0,|L5.196|
0000c0  7800              LDRB     r0,[r0,#0]            ;508  ; EEP_flag
0000c2  e7eb              B        |L5.156|
;;;510    
                          ENDP

                  |L5.196|
                          DCD      EEP_flag

                          AREA ||i.I2C_NoAck||, CODE, READONLY, ALIGN=2

                  I2C_NoAck PROC
;;;221    }
;;;222    static void I2C_NoAck(void)    //不发送应答信号，用于停止读 
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224        	//SDA=1;
;;;225    	GPIO_SetBits(GPIO_IIC_PORT,SDA);
000002  2180              MOVS     r1,#0x80
000004  4808              LDR      r0,|L6.40|
000006  f7fffffe          BL       GPIO_SetBits
;;;226     	delay_nop();
00000a  f7fffffe          BL       delay_nop
;;;227     	//SCL=1;
;;;228    	GPIO_SetBits(GPIO_IIC_PORT,SCL);
00000e  2140              MOVS     r1,#0x40
000010  4805              LDR      r0,|L6.40|
000012  f7fffffe          BL       GPIO_SetBits
;;;229     	delay_nop();
000016  f7fffffe          BL       delay_nop
;;;230     	//SCL=0;
;;;231    	GPIO_ResetBits(GPIO_IIC_PORT,SCL);
00001a  2140              MOVS     r1,#0x40
00001c  4802              LDR      r0,|L6.40|
00001e  f7fffffe          BL       GPIO_ResetBits
;;;232        	delay_nop();
000022  f7fffffe          BL       delay_nop
;;;233    }    
000026  bd10              POP      {r4,pc}
;;;234    //写一字节到EEPROM
                          ENDP

                  |L6.40|
                          DCD      0x40010c00

                          AREA ||i.I2C_RecAck||, CODE, READONLY, ALIGN=2

                  I2C_RecAck PROC
;;;178    //主机写后，等待从机应答信号
;;;179    static void I2C_RecAck(void)  
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181      //SCL=0;  
;;;182      GPIO_ResetBits(GPIO_IIC_PORT,SCL);    //主机拉低SCL
000002  2140              MOVS     r1,#0x40
000004  4811              LDR      r0,|L7.76|
000006  f7fffffe          BL       GPIO_ResetBits
;;;183      delay_nop();  
00000a  f7fffffe          BL       delay_nop
;;;184    
;;;185      I2C_SDA_IO_SET(1);                    //设数据线为输入
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       I2C_SDA_IO_SET
;;;186      delay_nop();
000014  f7fffffe          BL       delay_nop
;;;187    
;;;188      //SCL=1;
;;;189      delay_nop();                          //等待从机操作，0-成功1-失败
000018  f7fffffe          BL       delay_nop
;;;190      
;;;191      GPIO_SetBits(GPIO_IIC_PORT,SCL);      //拉高SCL，禁止SDA变化
00001c  2140              MOVS     r1,#0x40
00001e  480b              LDR      r0,|L7.76|
000020  f7fffffe          BL       GPIO_SetBits
;;;192      delay_nop(); 
000024  f7fffffe          BL       delay_nop
;;;193    
;;;194      //EEP_flag=SDA;
;;;195      EEP_flag=GPIO_ReadInputDataBit(GPIO_IIC_PORT,SDA);        //读SDA状态，此状态有从机决定
000028  2180              MOVS     r1,#0x80
00002a  4808              LDR      r0,|L7.76|
00002c  f7fffffe          BL       GPIO_ReadInputDataBit
000030  4907              LDR      r1,|L7.80|
000032  7008              STRB     r0,[r1,#0]
;;;196    
;;;197      //SCL=0;
;;;198      GPIO_ResetBits(GPIO_IIC_PORT,SCL);    //拉低SCL，允许主机写入SDA
000034  2140              MOVS     r1,#0x40
000036  4805              LDR      r0,|L7.76|
000038  f7fffffe          BL       GPIO_ResetBits
;;;199      delay_nop();
00003c  f7fffffe          BL       delay_nop
;;;200    
;;;201      //SDAoutput();
;;;202      I2C_SDA_IO_SET(0);       //设数据线为输出
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       I2C_SDA_IO_SET
;;;203      delay_nop();
000046  f7fffffe          BL       delay_nop
;;;204    }
00004a  bd10              POP      {r4,pc}
;;;205    
                          ENDP

                  |L7.76|
                          DCD      0x40010c00
                  |L7.80|
                          DCD      EEP_flag

                          AREA ||i.I2C_SDA_IO_SET||, CODE, READONLY, ALIGN=2

                  I2C_SDA_IO_SET PROC
;;;101    //SDA管脚方向设置
;;;102    void I2C_SDA_IO_SET(unsigned char io_set) //SDA引脚输入输出设置
000000  b538              PUSH     {r3-r5,lr}
;;;103    {
000002  4604              MOV      r4,r0
;;;104      GPIO_InitTypeDef GPIO_InitStructure;
;;;105      if(io_set==0)
000004  b96c              CBNZ     r4,|L8.34|
;;;106      {
;;;107      	GPIO_InitStructure.GPIO_Pin = SDA;          //24C02 SDA 作为输出
000006  2080              MOVS     r0,#0x80
000008  f8ad0000          STRH     r0,[sp,#0]
;;;108      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//GPIO_Mode_Out_OD;
00000c  2010              MOVS     r0,#0x10
00000e  f88d0003          STRB     r0,[sp,#3]
;;;109      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;110      	GPIO_Init(PORT_I2C, &GPIO_InitStructure); 
000018  4669              MOV      r1,sp
00001a  4808              LDR      r0,|L8.60|
00001c  f7fffffe          BL       GPIO_Init
000020  e00b              B        |L8.58|
                  |L8.34|
;;;111      }
;;;112      else if(io_set==1)
000022  2c01              CMP      r4,#1
000024  d109              BNE      |L8.58|
;;;113      {
;;;114      	GPIO_InitStructure.GPIO_Pin = SDA;          //24C02 SDA 作为输入
000026  2080              MOVS     r0,#0x80
000028  f8ad0000          STRH     r0,[sp,#0]
;;;115      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  //上拉输入
00002c  2048              MOVS     r0,#0x48
00002e  f88d0003          STRB     r0,[sp,#3]
;;;116      	GPIO_Init(PORT_I2C, &GPIO_InitStructure); 
000032  4669              MOV      r1,sp
000034  4801              LDR      r0,|L8.60|
000036  f7fffffe          BL       GPIO_Init
                  |L8.58|
;;;117      }
;;;118      else
;;;119      {;}
;;;120    }
00003a  bd38              POP      {r3-r5,pc}
;;;121    //设置是否允许写
                          ENDP

                  |L8.60|
                          DCD      0x40010c00

                          AREA ||i.I2C_SendAck||, CODE, READONLY, ALIGN=2

                  I2C_SendAck PROC
;;;207    //发送应答信号，用于连续读 
;;;208    static void I2C_SendAck(void)  
000000  b510              PUSH     {r4,lr}
;;;209    {
;;;210     	//SDA=0;
;;;211    	GPIO_ResetBits(GPIO_IIC_PORT,SDA);
000002  2180              MOVS     r1,#0x80
000004  4808              LDR      r0,|L9.40|
000006  f7fffffe          BL       GPIO_ResetBits
;;;212     	delay_nop();
00000a  f7fffffe          BL       delay_nop
;;;213    
;;;214     	//SCL=1;
;;;215    	GPIO_SetBits(GPIO_IIC_PORT,SCL);
00000e  2140              MOVS     r1,#0x40
000010  4805              LDR      r0,|L9.40|
000012  f7fffffe          BL       GPIO_SetBits
;;;216     	delay_nop();
000016  f7fffffe          BL       delay_nop
;;;217    
;;;218     	//SCL=0;
;;;219    	GPIO_ResetBits(GPIO_IIC_PORT,SCL);
00001a  2140              MOVS     r1,#0x40
00001c  4802              LDR      r0,|L9.40|
00001e  f7fffffe          BL       GPIO_ResetBits
;;;220     	delay_nop();
000022  f7fffffe          BL       delay_nop
;;;221    }
000026  bd10              POP      {r4,pc}
;;;222    static void I2C_NoAck(void)    //不发送应答信号，用于停止读 
                          ENDP

                  |L9.40|
                          DCD      0x40010c00

                          AREA ||i.I2C_Start||, CODE, READONLY, ALIGN=2

                  I2C_Start PROC
;;;134    //启动
;;;135    static void I2C_Start(void)   //启动总线
000000  b510              PUSH     {r4,lr}
;;;136    { 
;;;137       //clf add 
;;;138       //GPIO_ResetBits(GPIO_IIC_PORT, SCL);
;;;139       //delay_nop();
;;;140    
;;;141       //SDA=1;
;;;142       GPIO_SetBits(GPIO_IIC_PORT,SDA);
000002  2180              MOVS     r1,#0x80
000004  480b              LDR      r0,|L10.52|
000006  f7fffffe          BL       GPIO_SetBits
;;;143       delay_nop();
00000a  f7fffffe          BL       delay_nop
;;;144       //SCL=1;
;;;145       GPIO_SetBits(GPIO_IIC_PORT,SCL);
00000e  2140              MOVS     r1,#0x40
000010  4808              LDR      r0,|L10.52|
000012  f7fffffe          BL       GPIO_SetBits
;;;146       delay_nop();
000016  f7fffffe          BL       delay_nop
;;;147       //SDA=0;
;;;148        GPIO_ResetBits(GPIO_IIC_PORT, SDA);
00001a  2180              MOVS     r1,#0x80
00001c  4805              LDR      r0,|L10.52|
00001e  f7fffffe          BL       GPIO_ResetBits
;;;149       delay_nop();
000022  f7fffffe          BL       delay_nop
;;;150       //SCL=0;
;;;151       GPIO_ResetBits(GPIO_IIC_PORT, SCL);
000026  2140              MOVS     r1,#0x40
000028  4802              LDR      r0,|L10.52|
00002a  f7fffffe          BL       GPIO_ResetBits
;;;152       delay_nop();
00002e  f7fffffe          BL       delay_nop
;;;153    
;;;154    }
000032  bd10              POP      {r4,pc}
;;;155    
                          ENDP

                  |L10.52|
                          DCD      0x40010c00

                          AREA ||i.I2C_Stop||, CODE, READONLY, ALIGN=2

                  I2C_Stop PROC
;;;156    //停止
;;;157    static void I2C_Stop(void)    //停止总线
000000  b510              PUSH     {r4,lr}
;;;158    {  
;;;159       //SCL=0;
;;;160       GPIO_ResetBits(GPIO_IIC_PORT,SCL);
000002  2140              MOVS     r1,#0x40
000004  480b              LDR      r0,|L11.52|
000006  f7fffffe          BL       GPIO_ResetBits
;;;161       delay_nop();
00000a  f7fffffe          BL       delay_nop
;;;162       //SDA=0;
;;;163       GPIO_ResetBits(GPIO_IIC_PORT, SDA);
00000e  2180              MOVS     r1,#0x80
000010  4808              LDR      r0,|L11.52|
000012  f7fffffe          BL       GPIO_ResetBits
;;;164       delay_nop();
000016  f7fffffe          BL       delay_nop
;;;165       //SCL=1;
;;;166       GPIO_SetBits(GPIO_IIC_PORT,SCL);
00001a  2140              MOVS     r1,#0x40
00001c  4805              LDR      r0,|L11.52|
00001e  f7fffffe          BL       GPIO_SetBits
;;;167       delay_nop();
000022  f7fffffe          BL       delay_nop
;;;168       //SDA=1;
;;;169       GPIO_SetBits(GPIO_IIC_PORT,SDA);
000026  2180              MOVS     r1,#0x80
000028  4802              LDR      r0,|L11.52|
00002a  f7fffffe          BL       GPIO_SetBits
;;;170       delay_nop();
00002e  f7fffffe          BL       delay_nop
;;;171    
;;;172       //SCL=0;
;;;173       //GPIO_ResetBits(GPIO_IIC_PORT,SCL);
;;;174       //delay_nop();
;;;175    
;;;176    }
000032  bd10              POP      {r4,pc}
;;;177    
                          ENDP

                  |L11.52|
                          DCD      0x40010c00

                          AREA ||i.I2C_WP_SET||, CODE, READONLY, ALIGN=2

                  I2C_WP_SET PROC
;;;121    //设置是否允许写
;;;122    void I2C_WP_SET(uint8_t io_set) //SDA引脚输入输出设置
000000  b510              PUSH     {r4,lr}
;;;123    {
000002  4604              MOV      r4,r0
;;;124      if(io_set!=0)
000004  b124              CBZ      r4,|L12.16|
;;;125      {
;;;126    		GPIO_SetBits(GPIO_IIC_PORT,WP); 
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L12.28|
00000a  f7fffffe          BL       GPIO_SetBits
00000e  e003              B        |L12.24|
                  |L12.16|
;;;127      }
;;;128      else
;;;129      {
;;;130    		GPIO_ResetBits(GPIO_IIC_PORT,WP); 
000010  2120              MOVS     r1,#0x20
000012  4802              LDR      r0,|L12.28|
000014  f7fffffe          BL       GPIO_ResetBits
                  |L12.24|
;;;131      }
;;;132    }
000018  bd10              POP      {r4,pc}
;;;133    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x40010c00

                          AREA ||i.I2C_rbyte||, CODE, READONLY, ALIGN=2

                  I2C_rbyte PROC
;;;265    //从EEPROM读1字节数据返回
;;;266    static unsigned char I2C_rbyte(void) 
000000  b570              PUSH     {r4-r6,lr}
;;;267    {
;;;268    	unsigned char i=8;
000002  2608              MOVS     r6,#8
;;;269     	unsigned char rbyte=0;
000004  2400              MOVS     r4,#0
;;;270    	unsigned char tmp;
;;;271        
;;;272     	//SDAinput();                  //设数据线为输入
;;;273    	I2C_SDA_IO_SET(1); 
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       I2C_SDA_IO_SET
;;;274    
;;;275     	while(i--)
00000c  e015              B        |L13.58|
                  |L13.14|
;;;276       	{
;;;277    		//SCL=1;
;;;278    		GPIO_SetBits(GPIO_IIC_PORT,SCL);
00000e  2140              MOVS     r1,#0x40
000010  480e              LDR      r0,|L13.76|
000012  f7fffffe          BL       GPIO_SetBits
;;;279        	delay_nop();
000016  f7fffffe          BL       delay_nop
;;;280        	//rbyte=(rbyte<<1)|SDA;
;;;281    		tmp=GPIO_ReadInputDataBit(GPIO_IIC_PORT,SDA);
00001a  2180              MOVS     r1,#0x80
00001c  480b              LDR      r0,|L13.76|
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
000022  4605              MOV      r5,r0
;;;282    		if(tmp!=0)tmp=1;
000024  b105              CBZ      r5,|L13.40|
000026  2501              MOVS     r5,#1
                  |L13.40|
;;;283    		rbyte=(rbyte<<1)|tmp;
000028  ea450044          ORR      r0,r5,r4,LSL #1
00002c  b2c4              UXTB     r4,r0
;;;284    
;;;285        	//SCL=0;
;;;286    		GPIO_ResetBits(GPIO_IIC_PORT,SCL);
00002e  2140              MOVS     r1,#0x40
000030  4806              LDR      r0,|L13.76|
000032  f7fffffe          BL       GPIO_ResetBits
;;;287    
;;;288        	delay_nop();
000036  f7fffffe          BL       delay_nop
                  |L13.58|
00003a  0030              MOVS     r0,r6                 ;275
00003c  f1a60101          SUB      r1,r6,#1              ;275
000040  b2ce              UXTB     r6,r1                 ;275
000042  d1e4              BNE      |L13.14|
;;;289        }
;;;290        //SDAoutput();
;;;291       	I2C_SDA_IO_SET(0); 
000044  f7fffffe          BL       I2C_SDA_IO_SET
;;;292     
;;;293        return(rbyte);
000048  4620              MOV      r0,r4
;;;294    }
00004a  bd70              POP      {r4-r6,pc}
;;;295    
                          ENDP

                  |L13.76|
                          DCD      0x40010c00

                          AREA ||i.I2C_wbyte||, CODE, READONLY, ALIGN=2

                  I2C_wbyte PROC
;;;234    //写一字节到EEPROM
;;;235    static void I2C_wbyte(unsigned char wbyte)      
000000  b570              PUSH     {r4-r6,lr}
;;;236    {
000002  4604              MOV      r4,r0
;;;237    	unsigned char i=8;
000004  2508              MOVS     r5,#8
;;;238     	
;;;239    	delay_nop();
000006  f7fffffe          BL       delay_nop
;;;240    	DISABLE_INT();//CPU_IntDis(); //关中断
00000a  2001              MOVS     r0,#1
00000c  f3808810          MSR      PRIMASK,r0
000010  bf00              NOP      
;;;241     	for(;i>0;i--)
000012  e01b              B        |L14.76|
                  |L14.20|
;;;242      	{
;;;243    		//SCL=0;
;;;244    	    GPIO_ResetBits(GPIO_IIC_PORT,SCL);
000014  2140              MOVS     r1,#0x40
000016  4811              LDR      r0,|L14.92|
000018  f7fffffe          BL       GPIO_ResetBits
;;;245    
;;;246       		if(wbyte&0x80)
00001c  f0140f80          TST      r4,#0x80
000020  d004              BEQ      |L14.44|
;;;247    		{
;;;248    			//SDA=1;
;;;249    			GPIO_SetBits(GPIO_IIC_PORT,SDA);
000022  2180              MOVS     r1,#0x80
000024  480d              LDR      r0,|L14.92|
000026  f7fffffe          BL       GPIO_SetBits
00002a  e003              B        |L14.52|
                  |L14.44|
;;;250    		}
;;;251      		else
;;;252    		{
;;;253    			//SDA=0;
;;;254    			GPIO_ResetBits(GPIO_IIC_PORT,SDA);
00002c  2180              MOVS     r1,#0x80
00002e  480b              LDR      r0,|L14.92|
000030  f7fffffe          BL       GPIO_ResetBits
                  |L14.52|
;;;255    		}   
;;;256       		delay_nop();
000034  f7fffffe          BL       delay_nop
;;;257       		//SCL=1;
;;;258    		GPIO_SetBits(GPIO_IIC_PORT,SCL);
000038  2140              MOVS     r1,#0x40
00003a  4808              LDR      r0,|L14.92|
00003c  f7fffffe          BL       GPIO_SetBits
;;;259       		wbyte<<=1;
000040  0660              LSLS     r0,r4,#25
000042  0e04              LSRS     r4,r0,#24
;;;260       		delay_nop();
000044  f7fffffe          BL       delay_nop
000048  1e68              SUBS     r0,r5,#1              ;241
00004a  b2c5              UXTB     r5,r0                 ;241
                  |L14.76|
00004c  2d00              CMP      r5,#0                 ;241
00004e  dce1              BGT      |L14.20|
;;;261      }
;;;262    	ENABLE_INT();//CPU_IntEn();  //开中断
000050  2000              MOVS     r0,#0
000052  f3808810          MSR      PRIMASK,r0
000056  bf00              NOP      
;;;263    } 
000058  bd70              POP      {r4-r6,pc}
;;;264    
                          ENDP

00005a  0000              DCW      0x0000
                  |L14.92|
                          DCD      0x40010c00

                          AREA ||i.InsertDataToFlash||, CODE, READONLY, ALIGN=1

                  InsertDataToFlash PROC
;;;513    //先把原来的数据搬走(用copy),再插入新数据
;;;514    u8 InsertDataToFlash(uint8_t *p_data,uint16_t eep_addr,uint16_t n)//,unsigned char Control)
000000  4603              MOV      r3,r0
;;;515    {
;;;516      	return 0;
000002  2000              MOVS     r0,#0
;;;517    }
000004  4770              BX       lr
;;;518    //先删除,再把数据搬过来(用copy)
                          ENDP


                          AREA ||i.ReadDataFromFlash||, CODE, READONLY, ALIGN=2

                  ReadDataFromFlash PROC
;;;375    //            unsigned int n,unsigned char Control)
;;;376    u8 ReadDataFromFlash(uint16_t eep_addr,uint8_t* p_data,uint16_t n)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;377    { 
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;378    	//unsigned int j=3;//,i=0;
;;;379    	 
;;;380     	 while(1)   //
00000a  e045              B        |L16.152|
                  |L16.12|
;;;381        {
;;;382         	I2C_Start();
00000c  f7fffffe          BL       I2C_Start
;;;383         	I2C_wbyte(Control&0xfe);
000010  20a0              MOVS     r0,#0xa0
000012  f7fffffe          BL       I2C_wbyte
;;;384         	I2C_RecAck();
000016  f7fffffe          BL       I2C_RecAck
;;;385         	if(EEP_flag)
00001a  4822              LDR      r0,|L16.164|
00001c  7800              LDRB     r0,[r0,#0]  ; EEP_flag
00001e  b100              CBZ      r0,|L16.34|
;;;386    		{
;;;387            	break;
000020  e03b              B        |L16.154|
                  |L16.34|
;;;388    		}
;;;389         	if(EEPALLBYTE>256)           //有16位地址吗?
;;;390           	{
;;;391    			I2C_wbyte(eep_addr/256);  //16位地址
000022  4627              MOV      r7,r4
000024  17e1              ASRS     r1,r4,#31
000026  eb046111          ADD      r1,r4,r1,LSR #24
00002a  f3c12007          UBFX     r0,r1,#8,#8
00002e  f7fffffe          BL       I2C_wbyte
;;;392            	I2C_RecAck();
000032  f7fffffe          BL       I2C_RecAck
;;;393            	if(EEP_flag)
000036  481b              LDR      r0,|L16.164|
000038  7800              LDRB     r0,[r0,#0]  ; EEP_flag
00003a  b100              CBZ      r0,|L16.62|
;;;394    			{
;;;395               		break;
00003c  e02d              B        |L16.154|
                  |L16.62|
;;;396    			}
;;;397            }
;;;398    
;;;399         	I2C_wbyte(eep_addr);          //8位地址
00003e  b2e0              UXTB     r0,r4
000040  f7fffffe          BL       I2C_wbyte
;;;400         	I2C_RecAck();
000044  f7fffffe          BL       I2C_RecAck
;;;401         	if(EEP_flag)
000048  4816              LDR      r0,|L16.164|
00004a  7800              LDRB     r0,[r0,#0]  ; EEP_flag
00004c  b100              CBZ      r0,|L16.80|
;;;402    		{
;;;403            	break;
00004e  e024              B        |L16.154|
                  |L16.80|
;;;404    		}
;;;405    
;;;406           //读-----------
;;;407    	    I2C_Start();
000050  f7fffffe          BL       I2C_Start
;;;408            I2C_wbyte(Control|0X01);	 //0XA1读，0xa0写
000054  20a1              MOVS     r0,#0xa1
000056  f7fffffe          BL       I2C_wbyte
;;;409    
;;;410            I2C_RecAck();
00005a  f7fffffe          BL       I2C_RecAck
;;;411            if(EEP_flag)
00005e  4811              LDR      r0,|L16.164|
000060  7800              LDRB     r0,[r0,#0]  ; EEP_flag
000062  b100              CBZ      r0,|L16.102|
;;;412    		{
;;;413               break;
000064  e019              B        |L16.154|
                  |L16.102|
;;;414    		}
;;;415            while(n>0)
000066  e00f              B        |L16.136|
                  |L16.104|
;;;416            {
;;;417    			*p_data++=I2C_rbyte();
000068  f7fffffe          BL       I2C_rbyte
00006c  f8060b01          STRB     r0,[r6],#1
;;;418    			n--;
000070  1e68              SUBS     r0,r5,#1
000072  b285              UXTH     r5,r0
;;;419               	if(n>0)
000074  2d00              CMP      r5,#0
000076  dd02              BLE      |L16.126|
;;;420    			{
;;;421                  I2C_SendAck();
000078  f7fffffe          BL       I2C_SendAck
00007c  e004              B        |L16.136|
                  |L16.126|
;;;422    			}
;;;423               	else
;;;424                {
;;;425    				I2C_NoAck();
00007e  f7fffffe          BL       I2C_NoAck
;;;426                  	I2C_Stop();
000082  f7fffffe          BL       I2C_Stop
;;;427                     break;
000086  e001              B        |L16.140|
                  |L16.136|
000088  2d00              CMP      r5,#0                 ;415
00008a  dced              BGT      |L16.104|
                  |L16.140|
00008c  bf00              NOP      
;;;428                }
;;;429              }
;;;430    
;;;431    		//==========================================
;;;432    		if(n==0)
00008e  b91d              CBNZ     r5,|L16.152|
;;;433            {
;;;434               	//break;
;;;435    			 return(EEP_flag);
000090  4804              LDR      r0,|L16.164|
000092  7800              LDRB     r0,[r0,#0]  ; EEP_flag
                  |L16.148|
;;;436            }
;;;437           }
;;;438     return(EEP_flag);
;;;439    }
000094  e8bd81f0          POP      {r4-r8,pc}
                  |L16.152|
000098  e7b8              B        |L16.12|
                  |L16.154|
00009a  bf00              NOP                            ;387
00009c  4801              LDR      r0,|L16.164|
00009e  7800              LDRB     r0,[r0,#0]            ;438  ; EEP_flag
0000a0  e7f8              B        |L16.148|
;;;440    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L16.164|
                          DCD      EEP_flag

                          AREA ||i.TestWRFlash||, CODE, READONLY, ALIGN=2

                  TestWRFlash PROC
;;;565    //测试程序
;;;566    void TestWRFlash(void)
000000  b510              PUSH     {r4,lr}
;;;567    {  
;;;568    	 static u8 buf[150],buf1[150];
;;;569    
;;;570    	 u8 i;//,j;
;;;571    
;;;572    	 for(i=0;i<150;i++)
000002  2400              MOVS     r4,#0
000004  e007              B        |L17.22|
                  |L17.6|
;;;573    	 {
;;;574    	 	buf[i]=0xcf;
000006  20cf              MOVS     r0,#0xcf
000008  490c              LDR      r1,|L17.60|
00000a  5508              STRB     r0,[r1,r4]
;;;575    		buf1[i]=0x35;
00000c  2035              MOVS     r0,#0x35
00000e  490c              LDR      r1,|L17.64|
000010  5508              STRB     r0,[r1,r4]
000012  1c60              ADDS     r0,r4,#1              ;572
000014  b2c4              UXTB     r4,r0                 ;572
                  |L17.22|
000016  2c96              CMP      r4,#0x96              ;572
000018  dbf5              BLT      |L17.6|
;;;576    	 }
;;;577    
;;;578    	 I2C_WP_SET(0);
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       I2C_WP_SET
;;;579    	 WriteDataToFlash(0x80,buf,150);
000020  2296              MOVS     r2,#0x96
000022  4906              LDR      r1,|L17.60|
000024  2080              MOVS     r0,#0x80
000026  f7fffffe          BL       WriteDataToFlash
;;;580       I2C_WP_SET(1);
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       I2C_WP_SET
;;;581    	 ReadDataFromFlash(0x80,buf1,150);
000030  2296              MOVS     r2,#0x96
000032  4903              LDR      r1,|L17.64|
000034  2080              MOVS     r0,#0x80
000036  f7fffffe          BL       ReadDataFromFlash
;;;582    
;;;583    } 
00003a  bd10              POP      {r4,pc}
;;;584    //清除所有FLASH
                          ENDP

                  |L17.60|
                          DCD      buf
                  |L17.64|
                          DCD      buf1

                          AREA ||i.WriteDataToFlash||, CODE, READONLY, ALIGN=2

                  WriteDataToFlash PROC
;;;302    //读多字节
;;;303    u8 WriteDataToFlash(uint16_t eep_addr,uint8_t* p_data,uint16_t n)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;304    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;305    	 unsigned int j=3;//,i=0,;
00000a  f04f0803          MOV      r8,#3
;;;306      
;;;307      	while(1)   
00000e  e053              B        |L18.184|
                  |L18.16|
;;;308        {
;;;309         	I2C_Start();
000010  f7fffffe          BL       I2C_Start
;;;310         	I2C_wbyte(Control&0xfe);
000014  20a0              MOVS     r0,#0xa0
000016  f7fffffe          BL       I2C_wbyte
;;;311         	I2C_RecAck();
00001a  f7fffffe          BL       I2C_RecAck
;;;312         	if(EEP_flag)
00001e  4829              LDR      r0,|L18.196|
000020  7800              LDRB     r0,[r0,#0]  ; EEP_flag
000022  b100              CBZ      r0,|L18.38|
;;;313    		{
;;;314            	break;
000024  e049              B        |L18.186|
                  |L18.38|
;;;315    		}
;;;316    
;;;317         	if(EEPALLBYTE>256)          		 	//有16位地址吗?
;;;318            {
;;;319    			I2C_wbyte(eep_addr/256);  			//16位地址
000026  4627              MOV      r7,r4
000028  17e1              ASRS     r1,r4,#31
00002a  eb046111          ADD      r1,r4,r1,LSR #24
00002e  f3c12007          UBFX     r0,r1,#8,#8
000032  f7fffffe          BL       I2C_wbyte
;;;320            	I2C_RecAck();
000036  f7fffffe          BL       I2C_RecAck
;;;321            	if(EEP_flag)
00003a  4822              LDR      r0,|L18.196|
00003c  7800              LDRB     r0,[r0,#0]  ; EEP_flag
00003e  b100              CBZ      r0,|L18.66|
;;;322    			{
;;;323               		break;
000040  e03b              B        |L18.186|
                  |L18.66|
;;;324    			}
;;;325            }
;;;326    
;;;327         	I2C_wbyte(eep_addr);          			//8位地址
000042  b2e0              UXTB     r0,r4
000044  f7fffffe          BL       I2C_wbyte
;;;328         	I2C_RecAck();
000048  f7fffffe          BL       I2C_RecAck
;;;329         	if(EEP_flag)
00004c  481d              LDR      r0,|L18.196|
00004e  7800              LDRB     r0,[r0,#0]  ; EEP_flag
000050  b100              CBZ      r0,|L18.84|
;;;330    		{
;;;331            	break;
000052  e032              B        |L18.186|
                  |L18.84|
;;;332    		}
;;;333    
;;;334    		while(n>0)
000054  e019              B        |L18.138|
                  |L18.86|
;;;335            {
;;;336               	I2C_wbyte(*p_data);
000056  7830              LDRB     r0,[r6,#0]
000058  f7fffffe          BL       I2C_wbyte
;;;337               	I2C_RecAck();
00005c  f7fffffe          BL       I2C_RecAck
;;;338    			n--;
000060  1e68              SUBS     r0,r5,#1
000062  b285              UXTH     r5,r0
;;;339               	if(EEP_flag)
000064  4817              LDR      r0,|L18.196|
000066  7800              LDRB     r0,[r0,#0]  ; EEP_flag
000068  b100              CBZ      r0,|L18.108|
;;;340    			{
;;;341                  break;
00006a  e010              B        |L18.142|
                  |L18.108|
;;;342    			}
;;;343               	p_data++;
00006c  1c76              ADDS     r6,r6,#1
;;;344               	eep_addr++;
00006e  1c60              ADDS     r0,r4,#1
000070  b284              UXTH     r4,r0
;;;345               	if((eep_addr%PAGESIZE==0))   //跨页
000072  17e1              ASRS     r1,r4,#31
000074  eb046151          ADD      r1,r4,r1,LSR #25
000078  11c9              ASRS     r1,r1,#7
00007a  ebb411c1          SUBS     r1,r4,r1,LSL #7
00007e  d104              BNE      |L18.138|
;;;346                {
;;;347    				I2C_Stop();
000080  f7fffffe          BL       I2C_Stop
;;;348                  	eep_delay10ms();
000084  f7fffffe          BL       eep_delay10ms
;;;349                  	break;
000088  e001              B        |L18.142|
                  |L18.138|
00008a  2d00              CMP      r5,#0                 ;334
00008c  dce3              BGT      |L18.86|
                  |L18.142|
00008e  bf00              NOP                            ;341
;;;350                }
;;;351             }
;;;352    
;;;353            if(n==0)
000090  b93d              CBNZ     r5,|L18.162|
;;;354            {
;;;355    			I2C_Stop();
000092  f7fffffe          BL       I2C_Stop
;;;356               	eep_delay10ms();
000096  f7fffffe          BL       eep_delay10ms
;;;357               	//break;
;;;358    			return(EEP_flag);
00009a  480a              LDR      r0,|L18.196|
00009c  7800              LDRB     r0,[r0,#0]  ; EEP_flag
                  |L18.158|
;;;359            }
;;;360            else if(EEP_flag)
;;;361            {
;;;362    			if(j--==0)      //允许重试3次
;;;363    			{
;;;364                 	//break;
;;;365    				return(EEP_flag);
;;;366    			}
;;;367            }
;;;368        }
;;;369     return(EEP_flag);
;;;370    
;;;371    }
00009e  e8bd81f0          POP      {r4-r8,pc}
                  |L18.162|
0000a2  4808              LDR      r0,|L18.196|
0000a4  7800              LDRB     r0,[r0,#0]            ;360  ; EEP_flag
0000a6  b138              CBZ      r0,|L18.184|
0000a8  ea5f0008          MOVS     r0,r8                 ;362
0000ac  f1a80801          SUB      r8,r8,#1              ;362
0000b0  d102              BNE      |L18.184|
0000b2  4804              LDR      r0,|L18.196|
0000b4  7800              LDRB     r0,[r0,#0]            ;365  ; EEP_flag
0000b6  e7f2              B        |L18.158|
                  |L18.184|
0000b8  e7aa              B        |L18.16|
                  |L18.186|
0000ba  bf00              NOP                            ;314
0000bc  4801              LDR      r0,|L18.196|
0000be  7800              LDRB     r0,[r0,#0]            ;369  ; EEP_flag
0000c0  e7ed              B        |L18.158|
;;;372    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L18.196|
                          DCD      EEP_flag

                          AREA ||i.bsp_EepromInit||, CODE, READONLY, ALIGN=2

                  bsp_EepromInit PROC
;;;47     //IO口配置
;;;48     void bsp_EepromInit(void)
000000  b508              PUSH     {r3,lr}
;;;49     {  
;;;50       GPIO_InitTypeDef GPIO_InitStructure;
;;;51     
;;;52     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;53       
;;;54       GPIO_InitStructure.GPIO_Pin = SCL;          			//24C02 SCL
00000a  2040              MOVS     r0,#0x40
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;55       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//GPIO_Mode_Out_OD;
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;56       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;57       GPIO_Init(PORT_I2C, &GPIO_InitStructure); 
00001c  4669              MOV      r1,sp
00001e  4815              LDR      r0,|L19.116|
000020  f7fffffe          BL       GPIO_Init
;;;58     
;;;59       GPIO_InitStructure.GPIO_Pin = SDA;          			//24C02 SDA 作为输出
000024  2080              MOVS     r0,#0x80
000026  f8ad0000          STRH     r0,[sp,#0]
;;;60       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//GPIO_Mode_Out_OD;
00002a  2010              MOVS     r0,#0x10
00002c  f88d0003          STRB     r0,[sp,#3]
;;;61       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000030  2003              MOVS     r0,#3
000032  f88d0002          STRB     r0,[sp,#2]
;;;62       GPIO_Init(PORT_I2C, &GPIO_InitStructure); 
000036  4669              MOV      r1,sp
000038  480e              LDR      r0,|L19.116|
00003a  f7fffffe          BL       GPIO_Init
;;;63     	
;;;64     
;;;65     	GPIO_InitStructure.GPIO_Pin = WP;          			//24C02 SDA 作为输出
00003e  2020              MOVS     r0,#0x20
000040  f8ad0000          STRH     r0,[sp,#0]
;;;66       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//GPIO_Mode_Out_OD;
000044  2010              MOVS     r0,#0x10
000046  f88d0003          STRB     r0,[sp,#3]
;;;67       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00004a  2003              MOVS     r0,#3
00004c  f88d0002          STRB     r0,[sp,#2]
;;;68       GPIO_Init(PORT_I2C, &GPIO_InitStructure); 
000050  4669              MOV      r1,sp
000052  4808              LDR      r0,|L19.116|
000054  f7fffffe          BL       GPIO_Init
;;;69     	
;;;70     #ifndef HT8201
;;;71     	//使能特殊功能和禁止JTAG脚
;;;72     	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); 	
;;;73     	DBGMCU->CR = DBGMCU->CR & ~((uint32_t)1<<5);							//关闭TRACESWO信号跟踪
000058  4807              LDR      r0,|L19.120|
00005a  6840              LDR      r0,[r0,#4]
00005c  f0200020          BIC      r0,r0,#0x20
000060  4905              LDR      r1,|L19.120|
000062  6048              STR      r0,[r1,#4]
;;;74     	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);   //禁止JTAG脚
000064  2101              MOVS     r1,#1
000066  4805              LDR      r0,|L19.124|
000068  f7fffffe          BL       GPIO_PinRemapConfig
;;;75     #endif
;;;76     	
;;;77     	I2C_WP_SET(1);
00006c  2001              MOVS     r0,#1
00006e  f7fffffe          BL       I2C_WP_SET
;;;78     
;;;79     }
000072  bd08              POP      {r3,pc}
;;;80     
                          ENDP

                  |L19.116|
                          DCD      0x40010c00
                  |L19.120|
                          DCD      0xe0042000
                  |L19.124|
                          DCD      0x00300200

                          AREA ||i.delay_nop||, CODE, READONLY, ALIGN=1

                  delay_nop PROC
;;;81     //为了兼容大多数24CXX，至少延时2uS 与晶振有关,定义成静态函数
;;;82     static void delay_nop(void)     
000000  200a              MOVS     r0,#0xa
;;;83     { 
;;;84        uint8_t i=10; //i=10延时1.5us//这里可以优化速度 ，经测试最低到5还能写入
;;;85        while(i--); 
000002  bf00              NOP      
                  |L20.4|
000004  0001              MOVS     r1,r0
000006  f1a00201          SUB      r2,r0,#1
00000a  b2d0              UXTB     r0,r2
00000c  d1fa              BNE      |L20.4|
;;;86     }
00000e  4770              BX       lr
;;;87     
                          ENDP


                          AREA ||i.eep_delay10ms||, CODE, READONLY, ALIGN=1

                  eep_delay10ms PROC
;;;88     //延时10mS 与晶振有关,定义成静态函数
;;;89     static void eep_delay10ms(void)   
000000  f44f707a          MOV      r0,#0x3e8
;;;90     { 
;;;91     	unsigned int t1,t2;
;;;92     	t1=1000;
;;;93     	while(t1--)
000004  e005              B        |L21.18|
                  |L21.6|
;;;94     	{
;;;95     		t2=100;
000006  2164              MOVS     r1,#0x64
;;;96     		while(t2--);
000008  bf00              NOP      
                  |L21.10|
00000a  000a              MOVS     r2,r1
00000c  f1a10101          SUB      r1,r1,#1
000010  d1fb              BNE      |L21.10|
                  |L21.18|
000012  0002              MOVS     r2,r0                 ;93
000014  f1a00001          SUB      r0,r0,#1              ;93
000018  d1f5              BNE      |L21.6|
;;;97     	}
;;;98      	//OSDelayxmS(5);
;;;99     }
00001a  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  buf
                          %        150
                  buf1
                          %        150

                          AREA ||.data||, DATA, ALIGN=0

                  EEP_flag
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_eeprom.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_eeprom_c_12f848a7____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_eeprom_c_12f848a7____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_eeprom_c_12f848a7____REVSH|
#line 128
|__asm___12_bsp_eeprom_c_12f848a7____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
