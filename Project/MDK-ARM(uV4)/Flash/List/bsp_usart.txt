; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outupt\bsp_usart.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\outupt\bsp_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\outupt\bsp_usart.crf ..\..\User\bsp\src\bsp_usart.c]
                          THUMB

                          AREA ||i.Bsp_Get_UsartData||, CODE, READONLY, ALIGN=2

                  Bsp_Get_UsartData PROC
;;;233    //============================================================================================
;;;234    void Bsp_Get_UsartData(uint8_t *p,uint8_t *pt)
000000  b510              PUSH     {r4,lr}
;;;235    {
000002  4602              MOV      r2,r0
;;;236            uint8_t i;
;;;237    		for(i=0;i<Rx.cnt;i++)
000004  2000              MOVS     r0,#0
000006  e008              B        |L1.26|
                  |L1.8|
;;;238    		{
;;;239    			  *p++=Rx.buf[i];
000008  4b0b              LDR      r3,|L1.56|
00000a  5c1b              LDRB     r3,[r3,r0]
00000c  f8023b01          STRB     r3,[r2],#1
;;;240    			   Rx.buf[i]=0;
000010  2400              MOVS     r4,#0
000012  4b09              LDR      r3,|L1.56|
000014  541c              STRB     r4,[r3,r0]
000016  1c43              ADDS     r3,r0,#1              ;237
000018  b2d8              UXTB     r0,r3                 ;237
                  |L1.26|
00001a  4b07              LDR      r3,|L1.56|
00001c  1e5b              SUBS     r3,r3,#1              ;237
00001e  781b              LDRB     r3,[r3,#0]            ;237  ; Rx
000020  4283              CMP      r3,r0                 ;237
000022  dcf1              BGT      |L1.8|
;;;241    		}
;;;242    		*pt=Rx.cnt;
000024  4b04              LDR      r3,|L1.56|
000026  1e5b              SUBS     r3,r3,#1
000028  781b              LDRB     r3,[r3,#0]  ; Rx
00002a  700b              STRB     r3,[r1,#0]
;;;243    		 Rx.cnt=0;
00002c  2300              MOVS     r3,#0
00002e  4c02              LDR      r4,|L1.56|
000030  1e64              SUBS     r4,r4,#1
000032  7023              STRB     r3,[r4,#0]
;;;244    }
000034  bd10              POP      {r4,pc}
;;;245    
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      ||Rx||+0x1

                          AREA ||i.RS485_Send||, CODE, READONLY, ALIGN=2

                  RS485_Send PROC
;;;147    */
;;;148    void RS485_Send(uint8_t *buff,uint8_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;150    	uint8_t i;
;;;151    	uint16_t dly;
;;;152    
;;;153    
;;;154    	RS485_TX_EN();
000008  2104              MOVS     r1,#4
00000a  4814              LDR      r0,|L2.92|
00000c  f7fffffe          BL       GPIO_SetBits
;;;155    	dly=200;
000010  27c8              MOVS     r7,#0xc8
;;;156    	while(dly--);
000012  bf00              NOP      
                  |L2.20|
000014  0038              MOVS     r0,r7
000016  f1a70101          SUB      r1,r7,#1
00001a  b28f              UXTH     r7,r1
00001c  d1fa              BNE      |L2.20|
;;;157    
;;;158    	//Delayx10us(1);
;;;159    	//USART_ClearFlag(USART2,USART_FLAG_TC);
;;;160    	//临界区============    禁止调度
;;;161    	//CPU_CRITICAL_ENTER();
;;;162    	for(i=0;i<len;i++)
00001e  2400              MOVS     r4,#0
000020  e00c              B        |L2.60|
                  |L2.34|
;;;163    	{	
;;;164    		//while (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET);	
;;;165    		USART_SendData(USART3, (uint8_t)buff[i]); 				//发送一个字符函数
000022  5d29              LDRB     r1,[r5,r4]
000024  480e              LDR      r0,|L2.96|
000026  f7fffffe          BL       USART_SendData
;;;166    		while (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET);				
00002a  bf00              NOP      
                  |L2.44|
00002c  2140              MOVS     r1,#0x40
00002e  480c              LDR      r0,|L2.96|
000030  f7fffffe          BL       USART_GetFlagStatus
000034  2800              CMP      r0,#0
000036  d0f9              BEQ      |L2.44|
000038  1c60              ADDS     r0,r4,#1              ;162
00003a  b2c4              UXTB     r4,r0                 ;162
                  |L2.60|
00003c  42b4              CMP      r4,r6                 ;162
00003e  dbf0              BLT      |L2.34|
;;;167    	}
;;;168    	//CPU_CRITICAL_EXIT();
;;;169    	//===================    打开调度
;;;170    	//Delayx10us(1);
;;;171    	//Delay2us();
;;;172    	dly=300;
000040  f44f7796          MOV      r7,#0x12c
;;;173    	while(dly--);
000044  bf00              NOP      
                  |L2.70|
000046  0038              MOVS     r0,r7
000048  f1a70101          SUB      r1,r7,#1
00004c  b28f              UXTH     r7,r1
00004e  d1fa              BNE      |L2.70|
;;;174     	RS485_RX_EN();	
000050  2104              MOVS     r1,#4
000052  4802              LDR      r0,|L2.92|
000054  f7fffffe          BL       GPIO_ResetBits
;;;175    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;176    /*
                          ENDP

                  |L2.92|
                          DCD      0x40010c00
                  |L2.96|
                          DCD      0x40004800

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;183    */
;;;184    void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186      //接收中断
;;;187    
;;;188      uint8_t tmp;
;;;189      tmp=tmp;
000002  bf00              NOP      
;;;190    	
;;;191    	//====================================================================================================
;;;192    	//有操作系统，需进入临界状态处理
;;;193    		
;;;194      if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  480f              LDR      r0,|L3.72|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1c8              CBZ      r0,|L3.68|
;;;195      {
;;;196        	if(Rx.cnt<RX_MAX)
000010  480e              LDR      r0,|L3.76|
000012  7800              LDRB     r0,[r0,#0]  ; Rx
000014  28c8              CMP      r0,#0xc8
000016  da0d              BGE      |L3.52|
;;;197            {
;;;198             	   Rx.buf[Rx.cnt]=USART_ReceiveData(USART3);
000018  480b              LDR      r0,|L3.72|
00001a  f7fffffe          BL       USART_ReceiveData
00001e  b2c1              UXTB     r1,r0
000020  480a              LDR      r0,|L3.76|
000022  7802              LDRB     r2,[r0,#0]  ; Rx
000024  1c40              ADDS     r0,r0,#1
000026  5481              STRB     r1,[r0,r2]
;;;199                Rx.cnt++;
000028  1e40              SUBS     r0,r0,#1
00002a  7800              LDRB     r0,[r0,#0]  ; Rx
00002c  1c40              ADDS     r0,r0,#1
00002e  4907              LDR      r1,|L3.76|
000030  7008              STRB     r0,[r1,#0]
000032  e003              B        |L3.60|
                  |L3.52|
;;;200            }
;;;201            else
;;;202            {
;;;203              	tmp=USART_ReceiveData(USART3);
000034  4804              LDR      r0,|L3.72|
000036  f7fffffe          BL       USART_ReceiveData
00003a  b2c4              UXTB     r4,r0
                  |L3.60|
;;;204            }
;;;205            
;;;206            Bus.interval=0;
00003c  2000              MOVS     r0,#0
00003e  4904              LDR      r1,|L3.80|
000040  70c8              STRB     r0,[r1,#3]
;;;207    				Bus.time=0;
000042  7088              STRB     r0,[r1,#2]
                  |L3.68|
;;;208      }
;;;209    	//退出临界状态处理
;;;210    	//=====================================================================================================
;;;211    	
;;;212    }
000044  bd10              POP      {r4,pc}
;;;213    
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      0x40004800
                  |L3.76|
                          DCD      ||Rx||
                  |L3.80|
                          DCD      Bus

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=2

                  bsp_InitUart PROC
;;;37     */
;;;38     void bsp_InitUart(uint8_t rate)
000000  b510              PUSH     {r4,lr}
;;;39     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;40     	GPIO_InitTypeDef GPIO_InitStructure;
;;;41     	USART_InitTypeDef USART_InitStructure;
;;;42     	
;;;43     	//中断
;;;44     	NVIC_InitTypeDef NVIC_InitStructure;
;;;45     	
;;;46     
;;;47     	/* 第1步：打开GPIO和USART部件的时钟 */
;;;48       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
000006  2101              MOVS     r1,#1
000008  2009              MOVS     r0,#9
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;49     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0488              LSLS     r0,r1,#18
000012  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;50     
;;;51     	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;52     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 ;
000016  f44f6080          MOV      r0,#0x400
00001a  f8ad0014          STRH     r0,[sp,#0x14]
;;;53     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2018              MOVS     r0,#0x18
000020  f88d0017          STRB     r0,[sp,#0x17]
;;;54     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
000026  f88d0016          STRB     r0,[sp,#0x16]
;;;55     	GPIO_Init(GPIOB, &GPIO_InitStructure);
00002a  a905              ADD      r1,sp,#0x14
00002c  482a              LDR      r0,|L4.216|
00002e  f7fffffe          BL       GPIO_Init
;;;56     	
;;;57     
;;;58     	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;59     		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;60     		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;61     	*/
;;;62     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000032  f44f6000          MOV      r0,#0x800
000036  f8ad0014          STRH     r0,[sp,#0x14]
;;;63     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  2004              MOVS     r0,#4
00003c  f88d0017          STRB     r0,[sp,#0x17]
;;;64     	GPIO_Init(GPIOB, &GPIO_InitStructure);
000040  a905              ADD      r1,sp,#0x14
000042  4825              LDR      r0,|L4.216|
000044  f7fffffe          BL       GPIO_Init
;;;65     	
;;;66     	/*  第3步已经做了，因此这步可以不做
;;;67     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;68     	*/
;;;69     	GPIO_Init(GPIOB, &GPIO_InitStructure);
000048  a905              ADD      r1,sp,#0x14
00004a  4823              LDR      r0,|L4.216|
00004c  f7fffffe          BL       GPIO_Init
;;;70     
;;;71     	//======================================================================
;;;72     	//485控制脚
;;;73     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000050  2004              MOVS     r0,#4
000052  f8ad0014          STRH     r0,[sp,#0x14]
;;;74     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000056  2010              MOVS     r0,#0x10
000058  f88d0017          STRB     r0,[sp,#0x17]
;;;75     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00005c  2003              MOVS     r0,#3
00005e  f88d0016          STRB     r0,[sp,#0x16]
;;;76     	GPIO_Init(GPIOB, &GPIO_InitStructure);
000062  a905              ADD      r1,sp,#0x14
000064  481c              LDR      r0,|L4.216|
000066  f7fffffe          BL       GPIO_Init
;;;77     	//==========================================================================
;;;78     
;;;79     	/* 第4步：配置USART参数
;;;80     	    - 波特率   = 115200 baud
;;;81     	    - 数据长度 = 8 Bits
;;;82     	    - 1个停止位
;;;83     	    - 无校验
;;;84     	    - 禁止硬件流控(即禁止RTS和CTS)
;;;85     	    - 使能接收和发送
;;;86     	*/
;;;87     	USART_InitStructure.USART_BaudRate = 19200;
00006a  f44f4096          MOV      r0,#0x4b00
00006e  9001              STR      r0,[sp,#4]
;;;88     
;;;89     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000070  2000              MOVS     r0,#0
000072  f8ad0008          STRH     r0,[sp,#8]
;;;90     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000076  f8ad000a          STRH     r0,[sp,#0xa]
;;;91     	USART_InitStructure.USART_Parity = USART_Parity_No;
00007a  f8ad000c          STRH     r0,[sp,#0xc]
;;;92     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00007e  f8ad0010          STRH     r0,[sp,#0x10]
;;;93     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000082  200c              MOVS     r0,#0xc
000084  f8ad000e          STRH     r0,[sp,#0xe]
;;;94     	USART_Init(USART3, &USART_InitStructure);
000088  a901              ADD      r1,sp,#4
00008a  4814              LDR      r0,|L4.220|
00008c  f7fffffe          BL       USART_Init
;;;95     
;;;96     	/* 第5步：使能 USART， 配置完毕 */
;;;97     	USART_Cmd(USART3, ENABLE);
000090  2101              MOVS     r1,#1
000092  4812              LDR      r0,|L4.220|
000094  f7fffffe          BL       USART_Cmd
;;;98     
;;;99     	/* 
;;;100    		CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;101    		如下语句解决第1个字节无法正确发送出去的问题：
;;;102    	 	清发送完成标志，Transmission Complete flag 
;;;103    	*/
;;;104    	USART_ClearFlag(USART3, USART_FLAG_TC); 
000098  2140              MOVS     r1,#0x40
00009a  4810              LDR      r0,|L4.220|
00009c  f7fffffe          BL       USART_ClearFlag
;;;105    	
;;;106    
;;;107    	/*************************************************************************************************/
;;;108    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);  /* 使能接收中断 */
0000a0  2201              MOVS     r2,#1
0000a2  f2405125          MOV      r1,#0x525
0000a6  480d              LDR      r0,|L4.220|
0000a8  f7fffffe          BL       USART_ITConfig
;;;109    	
;;;110    	USART_Cmd(USART3, ENABLE);		                   /* 使能串口 */
0000ac  2101              MOVS     r1,#1
0000ae  480b              LDR      r0,|L4.220|
0000b0  f7fffffe          BL       USART_Cmd
;;;111    	
;;;112    	USART_ClearFlag(USART3, USART_FLAG_TC);        /* 清发送完成标志，Transmission Complete flag */
0000b4  2140              MOVS     r1,#0x40
0000b6  4809              LDR      r0,|L4.220|
0000b8  f7fffffe          BL       USART_ClearFlag
;;;113    	
;;;114    	//=================================================================================================
;;;115    	//中断配置
;;;116    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
0000bc  2027              MOVS     r0,#0x27
0000be  f88d0000          STRB     r0,[sp,#0]
;;;117    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
0000c2  2000              MOVS     r0,#0
0000c4  f88d0002          STRB     r0,[sp,#2]
;;;118    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000c8  2001              MOVS     r0,#1
0000ca  f88d0003          STRB     r0,[sp,#3]
;;;119    	NVIC_Init(&NVIC_InitStructure);
0000ce  4668              MOV      r0,sp
0000d0  f7fffffe          BL       NVIC_Init
;;;120    	//=====================================================================================================
;;;121    	
;;;122    	//=================================================================================================
;;;123    // 	//以下用于杜亚IT系统，总线竞争
;;;124    // 	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;		     //外部中断2
;;;125    // 	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	   //抢占优先级 0
;;;126    // 	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			     //子优先级0  
;;;127    // 	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				       //使能
;;;128    // 	NVIC_Init(&NVIC_InitStructure);
;;;129    	
;;;130    // 	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource11); //外部中断配置AFIO--ETXI2
;;;131    // 	
;;;132    // 	EXTI_InitStructure.EXTI_Line = EXTI_Line11;					         //PA11 作为键盘的行线。检测状态
;;;133    // 	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;			     //中断模式
;;;134    // 	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;		   //下降沿触发
;;;135    // 	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
;;;136    // 	EXTI_Init(&EXTI_InitStructure);
;;;137    	//==================================================================================================
;;;138        
;;;139    }
0000d4  b006              ADD      sp,sp,#0x18
0000d6  bd10              POP      {r4,pc}
;;;140    /*
                          ENDP

                  |L4.216|
                          DCD      0x40010c00
                  |L4.220|
                          DCD      0x40004800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ||Rx||
                          %        201

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_usart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_bsp_usart_c_b28b0d00____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_usart_c_b28b0d00____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_bsp_usart_c_b28b0d00____REVSH|
#line 128
|__asm___11_bsp_usart_c_b28b0d00____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
