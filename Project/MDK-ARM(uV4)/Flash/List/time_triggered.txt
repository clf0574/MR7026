; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outupt\time_triggered.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\outupt\time_triggered.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\outupt\time_triggered.crf ..\..\User\Time_Triggered.c]
                          THUMB

                          AREA ||i.hSCH_Add_Task||, CODE, READONLY, ALIGN=2

                  hSCH_Add_Task PROC
;;;93     */
;;;94     tByte hSCH_Add_Task(void (*pFuntion)(void),
000000  b570              PUSH     {r4-r6,lr}
;;;95     							tWord DELAY,
;;;96     							tWord PERIOD,
;;;97     							tByte Co_op)	  /*任务合作式和抢占式的区分*/
;;;98     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;99     	tByte index = 0; /*首先在队列中找到一个空隙，（如果有的话）*/
000006  2100              MOVS     r1,#0
;;;100    	
;;;101    	while((hSCH_task_G[index].pTask != 0) && (index <hSCH_MAX_TASKS))
000008  e001              B        |L1.14|
                  |L1.10|
;;;102    	{
;;;103    		index ++;		
00000a  1c48              ADDS     r0,r1,#1
00000c  b2c1              UXTB     r1,r0
                  |L1.14|
00000e  4812              LDR      r0,|L1.88|
000010  eb001001          ADD      r0,r0,r1,LSL #4       ;101
000014  6800              LDR      r0,[r0,#0]            ;101
000016  b108              CBZ      r0,|L1.28|
000018  2904              CMP      r1,#4                 ;101
00001a  dbf6              BLT      |L1.10|
                  |L1.28|
;;;104    	}
;;;105    	if(index == hSCH_MAX_TASKS)/*超过最大的任务数目 则返错误信息*/
00001c  2904              CMP      r1,#4
00001e  d104              BNE      |L1.42|
;;;106    	{
;;;107    		Error_code_G = ERROR_SCH_TOO_MANY_TASKS;/*设置全局错误变量*/
000020  2003              MOVS     r0,#3
000022  4e0e              LDR      r6,|L1.92|
000024  7030              STRB     r0,[r6,#0]
;;;108    		return hSCH_MAX_TASKS;	
000026  2004              MOVS     r0,#4
                  |L1.40|
;;;109    	}
;;;110    	
;;;111    	hSCH_task_G[index].pTask = pFuntion;	/*运行到这里说明申请的任务块成功*/
;;;112    	hSCH_task_G[index].Delay = DELAY;
;;;113    	hSCH_task_G[index].Period = PERIOD;
;;;114    	hSCH_task_G[index].RunMe = 0;
;;;115    	hSCH_task_G[index].Co_op = Co_op;
;;;116    	
;;;117    	return index;					   /*返回任务的位置，以便于以后删除*/
;;;118    }
000028  bd70              POP      {r4-r6,pc}
                  |L1.42|
00002a  480b              LDR      r0,|L1.88|
00002c  eb001001          ADD      r0,r0,r1,LSL #4       ;111
000030  6004              STR      r4,[r0,#0]            ;111
000032  4809              LDR      r0,|L1.88|
000034  eb001001          ADD      r0,r0,r1,LSL #4       ;112
000038  6045              STR      r5,[r0,#4]            ;112
00003a  4807              LDR      r0,|L1.88|
00003c  eb001001          ADD      r0,r0,r1,LSL #4       ;113
000040  6082              STR      r2,[r0,#8]            ;113
000042  2000              MOVS     r0,#0                 ;114
000044  4e04              LDR      r6,|L1.88|
000046  eb061601          ADD      r6,r6,r1,LSL #4       ;114
00004a  7330              STRB     r0,[r6,#0xc]          ;114
00004c  4802              LDR      r0,|L1.88|
00004e  eb001001          ADD      r0,r0,r1,LSL #4       ;115
000052  7343              STRB     r3,[r0,#0xd]          ;115
000054  4608              MOV      r0,r1                 ;117
000056  e7e7              B        |L1.40|
;;;119    /*
                          ENDP

                  |L1.88|
                          DCD      hSCH_task_G
                  |L1.92|
                          DCD      Error_code_G

                          AREA ||i.hSCH_Dispatch_Tasks||, CODE, READONLY, ALIGN=2

                  hSCH_Dispatch_Tasks PROC
;;;155    */
;;;156    void hSCH_Dispatch_Tasks(void)
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158    	tByte index;
;;;159    	/*运行下一个任务，如果下一个任务准备就绪的话*/
;;;160    	for(index = 0; index < hSCH_MAX_TASKS; index++)
000002  2400              MOVS     r4,#0
000004  e022              B        |L2.76|
                  |L2.6|
;;;161    	{
;;;162    		if((hSCH_task_G[index].RunMe >0) && (hSCH_task_G[index].Co_op))	/*只调度合作式任务*/
000006  4814              LDR      r0,|L2.88|
000008  eb001004          ADD      r0,r0,r4,LSL #4
00000c  7b00              LDRB     r0,[r0,#0xc]
00000e  2800              CMP      r0,#0
000010  dd1a              BLE      |L2.72|
000012  4811              LDR      r0,|L2.88|
000014  eb001004          ADD      r0,r0,r4,LSL #4
000018  7b40              LDRB     r0,[r0,#0xd]
00001a  b1a8              CBZ      r0,|L2.72|
;;;163    		{
;;;164    			(*hSCH_task_G[index].pTask)();     /*执行任务 */
00001c  490e              LDR      r1,|L2.88|
00001e  eb011104          ADD      r1,r1,r4,LSL #4
000022  6808              LDR      r0,[r1,#0]
000024  4780              BLX      r0
;;;165    			hSCH_task_G[index].RunMe -= 1;	   /*执行任务完成后，将RunMe减一 */
000026  480c              LDR      r0,|L2.88|
000028  eb001004          ADD      r0,r0,r4,LSL #4
00002c  7b00              LDRB     r0,[r0,#0xc]
00002e  1e40              SUBS     r0,r0,#1
000030  4909              LDR      r1,|L2.88|
000032  eb011104          ADD      r1,r1,r4,LSL #4
000036  7308              STRB     r0,[r1,#0xc]
;;;166    			if(hSCH_task_G[index].Period == 0) /*如果是单次任务的话，则将任务删除 */
000038  4807              LDR      r0,|L2.88|
00003a  eb001004          ADD      r0,r0,r4,LSL #4
00003e  6880              LDR      r0,[r0,#8]
000040  b910              CBNZ     r0,|L2.72|
;;;167    			{
;;;168    				hSCH_Task_Delete(index);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       hSCH_Task_Delete
                  |L2.72|
000048  1c60              ADDS     r0,r4,#1              ;160
00004a  b2c4              UXTB     r4,r0                 ;160
                  |L2.76|
00004c  2c04              CMP      r4,#4                 ;160
00004e  dbda              BLT      |L2.6|
;;;169    			}
;;;170    		}
;;;171    	}
;;;172      //=======================================================================================================	
;;;173      //此任务要求不停运行，并且间隔时间短
;;;174      AppTask_RivalrySend();								 //竞争发送		
000050  f7fffffe          BL       AppTask_RivalrySend
;;;175    }
000054  bd10              POP      {r4,pc}
;;;176    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      hSCH_task_G

                          AREA ||i.hSCH_Task_Delete||, CODE, READONLY, ALIGN=2

                  hSCH_Task_Delete PROC
;;;126    */
;;;127    tByte hSCH_Task_Delete(tByte index)
000000  4601              MOV      r1,r0
;;;128    {
;;;129    	tByte Return_code;
;;;130    	
;;;131    	if(hSCH_task_G[index].pTask == 0)				   /*这里没有任务*/
000002  4a0e              LDR      r2,|L3.60|
000004  eb021201          ADD      r2,r2,r1,LSL #4
000008  6812              LDR      r2,[r2,#0]
00000a  b922              CBNZ     r2,|L3.22|
;;;132    	{
;;;133    		Error_code_G = ERROR_SCH_CANOT_DELETE_TASK;/*设置全局错误变量*/
00000c  2202              MOVS     r2,#2
00000e  4b0c              LDR      r3,|L3.64|
000010  701a              STRB     r2,[r3,#0]
;;;134    		Return_code  = RETURN_ERROR;
000012  2000              MOVS     r0,#0
000014  e000              B        |L3.24|
                  |L3.22|
;;;135    	}
;;;136    	else
;;;137    	{
;;;138    		Return_code  = RETURN_NORMOL;		
000016  2001              MOVS     r0,#1
                  |L3.24|
;;;139    	}
;;;140    	
;;;141    	hSCH_task_G[index].pTask = 0x0000;
000018  2200              MOVS     r2,#0
00001a  4b08              LDR      r3,|L3.60|
00001c  eb031301          ADD      r3,r3,r1,LSL #4
000020  601a              STR      r2,[r3,#0]
;;;142    	hSCH_task_G[index].Delay = 0;
000022  4b06              LDR      r3,|L3.60|
000024  eb031301          ADD      r3,r3,r1,LSL #4
000028  605a              STR      r2,[r3,#4]
;;;143    	hSCH_task_G[index].Period = 0;
00002a  4b04              LDR      r3,|L3.60|
00002c  eb031301          ADD      r3,r3,r1,LSL #4
000030  609a              STR      r2,[r3,#8]
;;;144    	hSCH_task_G[index].RunMe =0;
000032  4b02              LDR      r3,|L3.60|
000034  eb031301          ADD      r3,r3,r1,LSL #4
000038  731a              STRB     r2,[r3,#0xc]
;;;145    	
;;;146    	return Return_code;						/*返回状态*/
;;;147    }
00003a  4770              BX       lr
;;;148    /*
                          ENDP

                  |L3.60|
                          DCD      hSCH_task_G
                  |L3.64|
                          DCD      Error_code_G

                          AREA ||i.hSCH_Update||, CODE, READONLY, ALIGN=2

                  hSCH_Update PROC
;;;43     */
;;;44     void hSCH_Update(void)
000000  b510              PUSH     {r4,lr}
;;;45     {
;;;46     	tByte index;
;;;47     	/*注意计数单位是时标，不是毫秒*/
;;;48     	for(index = 0; index < hSCH_MAX_TASKS; index++)
000002  2400              MOVS     r4,#0
000004  e047              B        |L4.150|
                  |L4.6|
;;;49     	{
;;;50     		if(hSCH_task_G[index].pTask)				   /*检测这里是否有任务*/
000006  4825              LDR      r0,|L4.156|
000008  eb001004          ADD      r0,r0,r4,LSL #4
00000c  6800              LDR      r0,[r0,#0]
00000e  b3a8              CBZ      r0,|L4.124|
;;;51     		{
;;;52     			if(hSCH_task_G[index].Delay == 0)
000010  4822              LDR      r0,|L4.156|
000012  eb001004          ADD      r0,r0,r4,LSL #4
000016  6840              LDR      r0,[r0,#4]
000018  bb88              CBNZ     r0,|L4.126|
;;;53     			{
;;;54     				if(hSCH_task_G[index].Co_op)
00001a  4820              LDR      r0,|L4.156|
00001c  eb001004          ADD      r0,r0,r4,LSL #4
000020  7b40              LDRB     r0,[r0,#0xd]
000022  b178              CBZ      r0,|L4.68|
;;;55     				{
;;;56     					//hSCH_task_G[index].RunMe += 1;  /*合作式任务需要运行 将RunMe置1*/	
;;;57     					if(hSCH_task_G[index].RunMe<200)hSCH_task_G[index].RunMe += 1;
000024  481d              LDR      r0,|L4.156|
000026  eb001004          ADD      r0,r0,r4,LSL #4
00002a  7b00              LDRB     r0,[r0,#0xc]
00002c  28c8              CMP      r0,#0xc8
00002e  da18              BGE      |L4.98|
000030  481a              LDR      r0,|L4.156|
000032  eb001004          ADD      r0,r0,r4,LSL #4
000036  7b00              LDRB     r0,[r0,#0xc]
000038  1c40              ADDS     r0,r0,#1
00003a  4918              LDR      r1,|L4.156|
00003c  eb011104          ADD      r1,r1,r4,LSL #4
000040  7308              STRB     r0,[r1,#0xc]
000042  e00e              B        |L4.98|
                  |L4.68|
;;;58     				}	
;;;59     				else
;;;60     				{
;;;61     					(*hSCH_task_G[index].pTask)();   /*抢占式任务需要立即运行 将RunMe减1*/	
000044  4915              LDR      r1,|L4.156|
000046  eb011104          ADD      r1,r1,r4,LSL #4
00004a  6808              LDR      r0,[r1,#0]
00004c  4780              BLX      r0
;;;62     										
;;;63     					//hSCH_task_G[index].RunMe -= 1;
;;;64     					if(hSCH_task_G[index].Period == 0)
00004e  4813              LDR      r0,|L4.156|
000050  eb001004          ADD      r0,r0,r4,LSL #4
000054  6880              LDR      r0,[r0,#8]
000056  b920              CBNZ     r0,|L4.98|
;;;65     					{						       /*单次执行的任务 则将其清除*/
;;;66     						hSCH_task_G[index].pTask = 0;									
000058  2000              MOVS     r0,#0
00005a  4910              LDR      r1,|L4.156|
00005c  eb011104          ADD      r1,r1,r4,LSL #4
000060  6008              STR      r0,[r1,#0]
                  |L4.98|
;;;67     					}
;;;68     				}
;;;69     				if(hSCH_task_G[index].Period)
000062  480e              LDR      r0,|L4.156|
000064  eb001004          ADD      r0,r0,r4,LSL #4
000068  6880              LDR      r0,[r0,#8]
00006a  b138              CBZ      r0,|L4.124|
;;;70     				{						           /*调度周期性的任务再次执行*/
;;;71     					hSCH_task_G[index].Delay = hSCH_task_G[index].Period;									
00006c  480b              LDR      r0,|L4.156|
00006e  eb001004          ADD      r0,r0,r4,LSL #4
000072  6880              LDR      r0,[r0,#8]
000074  4909              LDR      r1,|L4.156|
000076  eb011104          ADD      r1,r1,r4,LSL #4
00007a  6048              STR      r0,[r1,#4]
                  |L4.124|
00007c  e009              B        |L4.146|
                  |L4.126|
00007e  e7ff              B        |L4.128|
                  |L4.128|
;;;72     				}
;;;73     			}
;;;74     			else
;;;75     			{							              /*还有准备好运行*/
;;;76     				hSCH_task_G[index].Delay -= 1;															
000080  4806              LDR      r0,|L4.156|
000082  eb001004          ADD      r0,r0,r4,LSL #4
000086  6840              LDR      r0,[r0,#4]
000088  1e40              SUBS     r0,r0,#1
00008a  4904              LDR      r1,|L4.156|
00008c  eb011104          ADD      r1,r1,r4,LSL #4
000090  6048              STR      r0,[r1,#4]
                  |L4.146|
000092  1c60              ADDS     r0,r4,#1              ;48
000094  b2c4              UXTB     r4,r0                 ;48
                  |L4.150|
000096  2c04              CMP      r4,#4                 ;48
000098  dbb5              BLT      |L4.6|
;;;77     			}
;;;78     		}		
;;;79     	}
;;;80     }
00009a  bd10              POP      {r4,pc}
;;;81     
                          ENDP

                  |L4.156|
                          DCD      hSCH_task_G

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  hSCH_task_G
                          %        64

                          AREA ||.data||, DATA, ALIGN=0

                  Error_code_G
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\Time_Triggered.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_Time_Triggered_c_350215f3____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_Time_Triggered_c_350215f3____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_Time_Triggered_c_350215f3____REVSH|
#line 128
|__asm___16_Time_Triggered_c_350215f3____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
