; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outupt\bsp_a7139.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\outupt\bsp_a7139.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\outupt\bsp_a7139.crf ..\..\User\bsp\src\bsp_A7139.C]
                          THUMB

                          AREA ||i.A7129_Cal||, CODE, READONLY, ALIGN=2

                  A7129_Cal PROC
;;;821    // A7129_Cal
;;;822    void A7129_Cal(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;823    {
;;;824    	uint8_t fb,fcd, fbcf;							//IF Filter
;;;825    	uint8_t vb,vbcf;									//VCO Current
;;;826    	uint8_t vcb, vccf;								//VCO Band
;;;827    	uint16_t tmp;
;;;828    	uint16_t dly=0;
000004  2500              MOVS     r5,#0
;;;829    	
;;;830    	//===============================================================================================
;;;831    	//防止编译警告
;;;832    	fb=fb;
000006  bf00              NOP      
;;;833    	fcd=fcd;
000008  bf00              NOP      
;;;834    	vcb=vcb;
00000a  9800              LDR      r0,[sp,#0]
00000c  9000              STR      r0,[sp,#0]
;;;835    	vb=vb;
00000e  bf00              NOP      
;;;836    	//===============================================================================================
;;;837    	A7129_WriteReg(MODE_REG, A7129Config[MODE_REG] | 0x0802);			//IF Filter & VCO Current Calibration
000010  4846              LDR      r0,|L1.300|
000012  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config
000014  f6400202          MOV      r2,#0x802
000018  ea400102          ORR      r1,r0,r2
00001c  200f              MOVS     r0,#0xf
00001e  f7fffffe          BL       A7129_WriteReg
;;;838    	A7139_Delay10us(1);			//clf test
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       A7139_Delay10us
;;;839    	dly=5000;
000028  f2413588          MOV      r5,#0x1388
;;;840        	do{
00002c  bf00              NOP      
                  |L1.46|
;;;841            	tmp = A7129_ReadReg(MODE_REG);
00002e  200f              MOVS     r0,#0xf
000030  f7fffffe          BL       A7129_ReadReg
000034  4604              MOV      r4,r0
;;;842    		A7139_Delay10us(1);dly--;if(dly==0)break;			//clf add 2016.1.13
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       A7139_Delay10us
00003c  1e68              SUBS     r0,r5,#1
00003e  b285              UXTH     r5,r0
000040  b905              CBNZ     r5,|L1.68|
000042  e003              B        |L1.76|
                  |L1.68|
;;;843        	}while(tmp & 0x0802);
000044  f6400002          MOV      r0,#0x802
000048  4204              TST      r4,r0
00004a  d1f0              BNE      |L1.46|
                  |L1.76|
00004c  bf00              NOP                            ;842
;;;844    
;;;845        	//for check(IF Filter)
;;;846        	tmp = A7129_ReadReg(CALIBRATION_REG);
00004e  200e              MOVS     r0,#0xe
000050  f7fffffe          BL       A7129_ReadReg
000054  4604              MOV      r4,r0
;;;847        	fb = tmp & 0x0F;
000056  f004090f          AND      r9,r4,#0xf
;;;848    	fcd = (tmp>>11) & 0x1F;
00005a  ea4f2ad4          LSR      r10,r4,#11
;;;849        	fbcf = (tmp>>4) & 0x01;
00005e  f3c41600          UBFX     r6,r4,#4,#1
;;;850        	if(fbcf)
000062  b10e              CBZ      r6,|L1.104|
;;;851        	{
;;;852            	Err_State();
000064  f7fffffe          BL       Err_State
                  |L1.104|
;;;853        	}
;;;854    
;;;855    	//for check(VCO Current)
;;;856        	tmp = A7129_ReadPageA(VCB_PAGEA);
000068  200a              MOVS     r0,#0xa
00006a  f7fffffe          BL       A7129_ReadPageA
00006e  4604              MOV      r4,r0
;;;857    	vcb = tmp & 0x0F;
000070  f004000f          AND      r0,r4,#0xf
000074  9000              STR      r0,[sp,#0]
;;;858    	vccf = (tmp>>4) & 0x01;
000076  f3c41800          UBFX     r8,r4,#4,#1
;;;859    	if(vccf)
00007a  f1b80f00          CMP      r8,#0
00007e  d001              BEQ      |L1.132|
;;;860    	{
;;;861            	Err_State();
000080  f7fffffe          BL       Err_State
                  |L1.132|
;;;862        	}
;;;863        
;;;864        
;;;865        	//RSSI Calibration procedure @STB state
;;;866    	A7129_WriteReg(ADC_REG, 0x4C00);									//set ADC average=64
000084  f44f4198          MOV      r1,#0x4c00
000088  200c              MOVS     r0,#0xc
00008a  f7fffffe          BL       A7129_WriteReg
;;;867        	A7129_WriteReg(MODE_REG, A7129Config[MODE_REG] | 0x1000);			//RSSI Calibration
00008e  4827              LDR      r0,|L1.300|
000090  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config
000092  f4405180          ORR      r1,r0,#0x1000
000096  200f              MOVS     r0,#0xf
000098  f7fffffe          BL       A7129_WriteReg
;;;868    	dly=5000;
00009c  f2413588          MOV      r5,#0x1388
;;;869        	do{
0000a0  bf00              NOP      
                  |L1.162|
;;;870            	tmp = A7129_ReadReg(MODE_REG);
0000a2  200f              MOVS     r0,#0xf
0000a4  f7fffffe          BL       A7129_ReadReg
0000a8  4604              MOV      r4,r0
;;;871    		A7139_Delay10us(1);dly--;if(dly==0)break;	         //clf add 2016.1.13
0000aa  2001              MOVS     r0,#1
0000ac  f7fffffe          BL       A7139_Delay10us
0000b0  1e68              SUBS     r0,r5,#1
0000b2  b285              UXTH     r5,r0
0000b4  b905              CBNZ     r5,|L1.184|
0000b6  e002              B        |L1.190|
                  |L1.184|
;;;872        	}while(tmp & 0x1000);
0000b8  f4145f80          TST      r4,#0x1000
0000bc  d1f1              BNE      |L1.162|
                  |L1.190|
0000be  bf00              NOP                            ;871
;;;873    	A7129_WriteReg(ADC_REG, A7129Config[ADC_REG]);
0000c0  481a              LDR      r0,|L1.300|
0000c2  8b01              LDRH     r1,[r0,#0x18]  ; A7129Config
0000c4  200c              MOVS     r0,#0xc
0000c6  f7fffffe          BL       A7129_WriteReg
;;;874    
;;;875    
;;;876        	//VCO calibration procedure @STB state
;;;877    	A7129_WriteReg(PLL1_REG, A7129Config[PLL1_REG]);
0000ca  4818              LDR      r0,|L1.300|
0000cc  8841              LDRH     r1,[r0,#2]  ; A7129Config
0000ce  2001              MOVS     r0,#1
0000d0  f7fffffe          BL       A7129_WriteReg
;;;878    	A7129_WriteReg(PLL2_REG, A7129Config[PLL2_REG]);
0000d4  4815              LDR      r0,|L1.300|
0000d6  8881              LDRH     r1,[r0,#4]  ; A7129Config
0000d8  2002              MOVS     r0,#2
0000da  f7fffffe          BL       A7129_WriteReg
;;;879    	A7129_WriteReg(MODE_REG, A7129Config[MODE_REG] | 0x0004);		//VCO Band Calibration
0000de  4813              LDR      r0,|L1.300|
0000e0  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config
0000e2  f0400104          ORR      r1,r0,#4
0000e6  200f              MOVS     r0,#0xf
0000e8  f7fffffe          BL       A7129_WriteReg
;;;880    	dly=5000;
0000ec  f2413588          MOV      r5,#0x1388
;;;881    	do{
0000f0  bf00              NOP      
                  |L1.242|
;;;882    		tmp = A7129_ReadReg(MODE_REG);
0000f2  200f              MOVS     r0,#0xf
0000f4  f7fffffe          BL       A7129_ReadReg
0000f8  4604              MOV      r4,r0
;;;883    		A7139_Delay10us(1);dly--;if(dly==0)break;	
0000fa  2001              MOVS     r0,#1
0000fc  f7fffffe          BL       A7139_Delay10us
000100  1e68              SUBS     r0,r5,#1
000102  b285              UXTH     r5,r0
000104  b905              CBNZ     r5,|L1.264|
000106  e002              B        |L1.270|
                  |L1.264|
;;;884    	}while(tmp & 0x0004);
000108  f0140f04          TST      r4,#4
00010c  d1f1              BNE      |L1.242|
                  |L1.270|
00010e  bf00              NOP                            ;883
;;;885    
;;;886    	//for check(VCO Band)
;;;887    	tmp = A7129_ReadReg(CALIBRATION_REG);
000110  200e              MOVS     r0,#0xe
000112  f7fffffe          BL       A7129_ReadReg
000116  4604              MOV      r4,r0
;;;888    	vb = (tmp >>5) & 0x07;
000118  f3c41b42          UBFX     r11,r4,#5,#3
;;;889    	vbcf = (tmp >>8) & 0x01;
00011c  f3c42700          UBFX     r7,r4,#8,#1
;;;890    	if(vbcf)
000120  b10f              CBZ      r7,|L1.294|
;;;891    	{
;;;892    		Err_State();
000122  f7fffffe          BL       Err_State
                  |L1.294|
;;;893    	}
;;;894    }
000126  e8bd8ff8          POP      {r3-r11,pc}
;;;895    
                          ENDP

00012a  0000              DCW      0x0000
                  |L1.300|
                          DCD      A7129Config

                          AREA ||i.A7129_Config||, CODE, READONLY, ALIGN=2

                  A7129_Config PROC
;;;751    //A7129_Config
;;;752    void A7129_Config(void)
000000  b570              PUSH     {r4-r6,lr}
;;;753    {
;;;754    	uint8_t i;
;;;755    	uint16_t tmp;
;;;756    
;;;757        	for(i=0; i<8; i++)
000002  2400              MOVS     r4,#0
000004  e007              B        |L2.22|
                  |L2.6|
;;;758        	{
;;;759            	A7129_WriteReg(i, A7129Config[i]);
000006  481c              LDR      r0,|L2.120|
000008  f8301014          LDRH     r1,[r0,r4,LSL #1]
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       A7129_WriteReg
000012  1c60              ADDS     r0,r4,#1              ;757
000014  b2c4              UXTB     r4,r0                 ;757
                  |L2.22|
000016  2c08              CMP      r4,#8                 ;757
000018  dbf5              BLT      |L2.6|
;;;760            }
;;;761    
;;;762    	for(i=10; i<16; i++)
00001a  240a              MOVS     r4,#0xa
00001c  e007              B        |L2.46|
                  |L2.30|
;;;763    	{
;;;764            	A7129_WriteReg(i, A7129Config[i]);
00001e  4816              LDR      r0,|L2.120|
000020  f8301014          LDRH     r1,[r0,r4,LSL #1]
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       A7129_WriteReg
00002a  1c60              ADDS     r0,r4,#1              ;762
00002c  b2c4              UXTB     r4,r0                 ;762
                  |L2.46|
00002e  2c10              CMP      r4,#0x10              ;762
000030  dbf5              BLT      |L2.30|
;;;765            }
;;;766    
;;;767        	for(i=0; i<16; i++)
000032  2400              MOVS     r4,#0
000034  e007              B        |L2.70|
                  |L2.54|
;;;768        	{
;;;769            	A7129_WritePageA(i, A7129Config_PageA[i]);
000036  4811              LDR      r0,|L2.124|
000038  f8301014          LDRH     r1,[r0,r4,LSL #1]
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       A7129_WritePageA
000042  1c60              ADDS     r0,r4,#1              ;767
000044  b2c4              UXTB     r4,r0                 ;767
                  |L2.70|
000046  2c10              CMP      r4,#0x10              ;767
000048  dbf5              BLT      |L2.54|
;;;770            }
;;;771    
;;;772    	for(i=0; i<5; i++)
00004a  2400              MOVS     r4,#0
00004c  e007              B        |L2.94|
                  |L2.78|
;;;773    	{
;;;774            	A7129_WritePageB(i, A7129Config_PageB[i]);
00004e  480c              LDR      r0,|L2.128|
000050  f8301014          LDRH     r1,[r0,r4,LSL #1]
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       A7129_WritePageB
00005a  1c60              ADDS     r0,r4,#1              ;772
00005c  b2c4              UXTB     r4,r0                 ;772
                  |L2.94|
00005e  2c05              CMP      r4,#5                 ;772
000060  dbf5              BLT      |L2.78|
;;;775      }
;;;776    
;;;777    	//for check        
;;;778    	tmp = A7129_ReadReg(SYSTEMCLOCK_REG);
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       A7129_ReadReg
000068  4605              MOV      r5,r0
;;;779    	if(tmp != A7129Config[SYSTEMCLOCK_REG])
00006a  4803              LDR      r0,|L2.120|
00006c  8800              LDRH     r0,[r0,#0]  ; A7129Config
00006e  42a8              CMP      r0,r5
000070  d001              BEQ      |L2.118|
;;;780    	{
;;;781    		Err_State();	
000072  f7fffffe          BL       Err_State
                  |L2.118|
;;;782    	}
;;;783    
;;;784    }
000076  bd70              POP      {r4-r6,pc}
;;;785    
                          ENDP

                  |L2.120|
                          DCD      A7129Config
                  |L2.124|
                          DCD      A7129Config_PageA
                  |L2.128|
                          DCD      A7129Config_PageB

                          AREA ||i.A7129_ReadPageA||, CODE, READONLY, ALIGN=2

                  A7129_ReadPageA PROC
;;;714    //A7129_ReadPageA
;;;715    uint16_t A7129_ReadPageA(uint8_t address)
000000  b570              PUSH     {r4-r6,lr}
;;;716    {
000002  4604              MOV      r4,r0
;;;717    	    uint16_t tmp;
;;;718    	
;;;719    	    tmp = address;
000004  4625              MOV      r5,r4
;;;720    	    tmp = ((tmp << 12) | A7129Config[CRYSTAL_REG]);
000006  4807              LDR      r0,|L3.36|
000008  89c0              LDRH     r0,[r0,#0xe]  ; A7129Config
00000a  ea403005          ORR      r0,r0,r5,LSL #12
00000e  b285              UXTH     r5,r0
;;;721    	    A7129_WriteReg(CRYSTAL_REG, tmp);
000010  4629              MOV      r1,r5
000012  2007              MOVS     r0,#7
000014  f7fffffe          BL       A7129_WriteReg
;;;722    	    tmp = A7129_ReadReg(PAGEA_REG);
000018  2008              MOVS     r0,#8
00001a  f7fffffe          BL       A7129_ReadReg
00001e  4605              MOV      r5,r0
;;;723    	    return tmp;
000020  4628              MOV      r0,r5
;;;724    }
000022  bd70              POP      {r4-r6,pc}
;;;725    
                          ENDP

                  |L3.36|
                          DCD      A7129Config

                          AREA ||i.A7129_ReadPageB||, CODE, READONLY, ALIGN=2

                  A7129_ReadPageB PROC
;;;739    //A7129_ReadPageB
;;;740    uint16_t A7129_ReadPageB(uint8_t address)
000000  b570              PUSH     {r4-r6,lr}
;;;741    {
000002  4604              MOV      r4,r0
;;;742    	    uint16_t tmp;
;;;743    	
;;;744    	    tmp = address;
000004  4625              MOV      r5,r4
;;;745    	    tmp = ((tmp << 7) | A7129Config[CRYSTAL_REG]);
000006  4807              LDR      r0,|L4.36|
000008  89c0              LDRH     r0,[r0,#0xe]  ; A7129Config
00000a  ea4010c5          ORR      r0,r0,r5,LSL #7
00000e  b285              UXTH     r5,r0
;;;746    	    A7129_WriteReg(CRYSTAL_REG, tmp);
000010  4629              MOV      r1,r5
000012  2007              MOVS     r0,#7
000014  f7fffffe          BL       A7129_WriteReg
;;;747    	    tmp = A7129_ReadReg(PAGEB_REG);
000018  2009              MOVS     r0,#9
00001a  f7fffffe          BL       A7129_ReadReg
00001e  4605              MOV      r5,r0
;;;748    	    return tmp;
000020  4628              MOV      r0,r5
;;;749    }
000022  bd70              POP      {r4-r6,pc}
;;;750    //===========================================================================================
                          ENDP

                  |L4.36|
                          DCD      A7129Config

                          AREA ||i.A7129_ReadReg||, CODE, READONLY, ALIGN=2

                  A7129_ReadReg PROC
;;;637    //A7129_ReadReg
;;;638    uint16_t A7129_ReadReg(uint8_t address)
000000  b570              PUSH     {r4-r6,lr}
;;;639    {
000002  4604              MOV      r4,r0
;;;640        uint8_t i;
;;;641        uint16_t tmp=0;
000004  2600              MOVS     r6,#0
;;;642    
;;;643        //SCS=0;
;;;644        Write_SCS_LO(); 
000006  2110              MOVS     r1,#0x10
000008  4828              LDR      r0,|L5.172|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;645        
;;;646        address |= CMD_Reg_R;
00000e  f0440480          ORR      r4,r4,#0x80
;;;647        for(i=0; i<8; i++)
000012  2500              MOVS     r5,#0
000014  e01b              B        |L5.78|
                  |L5.22|
;;;648        {
;;;649            if(address & 0x80)
000016  f0140f80          TST      r4,#0x80
00001a  d004              BEQ      |L5.38|
;;;650            {
;;;651                //SDIO = 1;
;;;652                Write_SDIO_HI(); 
00001c  2180              MOVS     r1,#0x80
00001e  4823              LDR      r0,|L5.172|
000020  f7fffffe          BL       GPIO_SetBits
000024  e003              B        |L5.46|
                  |L5.38|
;;;653            }
;;;654            else
;;;655            {
;;;656                //SDIO = 0;
;;;657                Write_SDIO_LO(); 
000026  2180              MOVS     r1,#0x80
000028  4820              LDR      r0,|L5.172|
00002a  f7fffffe          BL       GPIO_ResetBits
                  |L5.46|
;;;658            }
;;;659    
;;;660    	My_NOP(); 
00002e  f7fffffe          BL       My_NOP
;;;661            //SCK=1;
;;;662            Write_SCK_HI(); 
000032  2120              MOVS     r1,#0x20
000034  481d              LDR      r0,|L5.172|
000036  f7fffffe          BL       GPIO_SetBits
;;;663            My_NOP();
00003a  f7fffffe          BL       My_NOP
;;;664            //SCK=0;
;;;665            Write_SCK_LO(); 
00003e  2120              MOVS     r1,#0x20
000040  481a              LDR      r0,|L5.172|
000042  f7fffffe          BL       GPIO_ResetBits
;;;666            address<<=1;
000046  0660              LSLS     r0,r4,#25
000048  0e04              LSRS     r4,r0,#24
00004a  1c68              ADDS     r0,r5,#1              ;647
00004c  b2c5              UXTB     r5,r0                 ;647
                  |L5.78|
00004e  2d08              CMP      r5,#8                 ;647
000050  dbe1              BLT      |L5.22|
;;;667        }
;;;668        My_NOP();
000052  f7fffffe          BL       My_NOP
;;;669        
;;;670        //read data code
;;;671        //TRIS_SDIO = 1;		//SDIO pull high
;;;672        Set_SDIO_Direction(1);
000056  2001              MOVS     r0,#1
000058  f7fffffe          BL       Set_SDIO_Direction
;;;673        
;;;674        for(i=0; i<16; i++)
00005c  2500              MOVS     r5,#0
00005e  e019              B        |L5.148|
                  |L5.96|
;;;675        {
;;;676            //if(SDIO)
;;;677            if(0!=Read_SDIO())
000060  2180              MOVS     r1,#0x80
000062  4812              LDR      r0,|L5.172|
000064  f7fffffe          BL       GPIO_ReadInputDataBit
000068  b120              CBZ      r0,|L5.116|
;;;678            {
;;;679                tmp = (tmp << 1) | 0x01;
00006a  2001              MOVS     r0,#1
00006c  eb000046          ADD      r0,r0,r6,LSL #1
000070  b286              UXTH     r6,r0
000072  e003              B        |L5.124|
                  |L5.116|
;;;680            }
;;;681            else
;;;682            {
;;;683                tmp = tmp << 1;
000074  f64f70ff          MOV      r0,#0xffff
000078  ea000646          AND      r6,r0,r6,LSL #1
                  |L5.124|
;;;684            }
;;;685    
;;;686            //SCK=1;
;;;687            Write_SCK_HI(); 
00007c  2120              MOVS     r1,#0x20
00007e  480b              LDR      r0,|L5.172|
000080  f7fffffe          BL       GPIO_SetBits
;;;688            My_NOP();
000084  f7fffffe          BL       My_NOP
;;;689            //SCK=0;
;;;690            Write_SCK_LO(); 
000088  2120              MOVS     r1,#0x20
00008a  4808              LDR      r0,|L5.172|
00008c  f7fffffe          BL       GPIO_ResetBits
000090  1c68              ADDS     r0,r5,#1              ;674
000092  b2c5              UXTB     r5,r0                 ;674
                  |L5.148|
000094  2d10              CMP      r5,#0x10              ;674
000096  dbe3              BLT      |L5.96|
;;;691             
;;;692        }
;;;693        //SCS=1;
;;;694        Write_SCS_HI(); 
000098  2110              MOVS     r1,#0x10
00009a  4804              LDR      r0,|L5.172|
00009c  f7fffffe          BL       GPIO_SetBits
;;;695         
;;;696        //TRIS_SDIO = 0;
;;;697        Set_SDIO_Direction(0); 
0000a0  2000              MOVS     r0,#0
0000a2  f7fffffe          BL       Set_SDIO_Direction
;;;698        return tmp;
0000a6  4630              MOV      r0,r6
;;;699    }
0000a8  bd70              POP      {r4-r6,pc}
;;;700    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L5.172|
                          DCD      0x40010800

                          AREA ||i.A7129_WriteFIFO||, CODE, READONLY, ALIGN=2

                  A7129_WriteFIFO PROC
;;;898    //void A7129_WriteFIFO(void)
;;;899    void A7129_WriteFIFO(uint8_t *buf,uint8_t length)
000000  b570              PUSH     {r4-r6,lr}
;;;900    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;901    	uint8_t i;
;;;902    
;;;903    	
;;;904    	StrobeCMD(CMD_TFR);			//TX FIFO address pointer reset
000006  2060              MOVS     r0,#0x60
000008  f7fffffe          BL       StrobeCMD
;;;905    
;;;906            //SCS=0;
;;;907      	Write_SCS_LO(); 
00000c  2110              MOVS     r1,#0x10
00000e  480b              LDR      r0,|L6.60|
000010  f7fffffe          BL       GPIO_ResetBits
;;;908    	ByteSend(CMD_FIFO_W);			//TX FIFO write command
000014  2040              MOVS     r0,#0x40
000016  f7fffffe          BL       ByteSend
;;;909    	
;;;910    	//__set_PRIMASK(1);			//关中断
;;;911    	
;;;912           ByteSend(length);   			//clf   add
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       ByteSend
;;;913    	for(i=0;i<length;i++)
000020  2500              MOVS     r5,#0
000022  e004              B        |L6.46|
                  |L6.36|
;;;914    	{		
;;;915    		ByteSend(buf[i]);
000024  5d70              LDRB     r0,[r6,r5]
000026  f7fffffe          BL       ByteSend
00002a  1c68              ADDS     r0,r5,#1              ;913
00002c  b2c5              UXTB     r5,r0                 ;913
                  |L6.46|
00002e  42a5              CMP      r5,r4                 ;913
000030  dbf8              BLT      |L6.36|
;;;916    	}
;;;917    	
;;;918    	//__set_PRIMASK(0);	//开中断
;;;919    	
;;;920    	//SCS=1;
;;;921    	Write_SCS_HI(); 
000032  2110              MOVS     r1,#0x10
000034  4801              LDR      r0,|L6.60|
000036  f7fffffe          BL       GPIO_SetBits
;;;922    }
00003a  bd70              POP      {r4-r6,pc}
;;;923    
                          ENDP

                  |L6.60|
                          DCD      0x40010800

                          AREA ||i.A7129_WriteID||, CODE, READONLY, ALIGN=2

                  A7129_WriteID PROC
;;;787    //WriteID
;;;788    void A7129_WriteID(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;789    {
;;;790    	uint8_t i;
;;;791    	uint8_t d1, d2, d3, d4;
;;;792    
;;;793    	//SCS=0;
;;;794    	Write_SCS_LO(); 
000004  2110              MOVS     r1,#0x10
000006  481f              LDR      r0,|L7.132|
000008  f7fffffe          BL       GPIO_ResetBits
;;;795    	ByteSend(CMD_ID_W);
00000c  2020              MOVS     r0,#0x20
00000e  f7fffffe          BL       ByteSend
;;;796    	for(i=0; i<4; i++)
000012  2400              MOVS     r4,#0
000014  e005              B        |L7.34|
                  |L7.22|
;;;797    	{
;;;798    		ByteSend(ID_Tab[i]);
000016  491c              LDR      r1,|L7.136|
000018  5d08              LDRB     r0,[r1,r4]
00001a  f7fffffe          BL       ByteSend
00001e  1c60              ADDS     r0,r4,#1              ;796
000020  b2c4              UXTB     r4,r0                 ;796
                  |L7.34|
000022  2c04              CMP      r4,#4                 ;796
000024  dbf7              BLT      |L7.22|
;;;799    	}
;;;800    	
;;;801    	//SCS=1;
;;;802      	Write_SCS_HI(); 
000026  2110              MOVS     r1,#0x10
000028  4816              LDR      r0,|L7.132|
00002a  f7fffffe          BL       GPIO_SetBits
;;;803    	//SCS=0;
;;;804    	Write_SCS_LO(); 
00002e  2110              MOVS     r1,#0x10
000030  4814              LDR      r0,|L7.132|
000032  f7fffffe          BL       GPIO_ResetBits
;;;805    	ByteSend(CMD_ID_R);
000036  20a0              MOVS     r0,#0xa0
000038  f7fffffe          BL       ByteSend
;;;806    	d1=ByteRead();
00003c  f7fffffe          BL       ByteRead
000040  4605              MOV      r5,r0
;;;807    	d2=ByteRead();
000042  f7fffffe          BL       ByteRead
000046  4606              MOV      r6,r0
;;;808    	d3=ByteRead();
000048  f7fffffe          BL       ByteRead
00004c  4607              MOV      r7,r0
;;;809    	d4=ByteRead();
00004e  f7fffffe          BL       ByteRead
000052  4680              MOV      r8,r0
;;;810    	
;;;811    	//SCS=1;
;;;812    	Write_SCS_HI(); 
000054  2110              MOVS     r1,#0x10
000056  480b              LDR      r0,|L7.132|
000058  f7fffffe          BL       GPIO_SetBits
;;;813    	
;;;814    	if((d1!=ID_Tab[0]) || (d2!=ID_Tab[1]) || (d3!=ID_Tab[2]) || (d4!=ID_Tab[3]))
00005c  480a              LDR      r0,|L7.136|
00005e  7800              LDRB     r0,[r0,#0]  ; ID_Tab
000060  42a8              CMP      r0,r5
000062  d10b              BNE      |L7.124|
000064  4808              LDR      r0,|L7.136|
000066  7840              LDRB     r0,[r0,#1]  ; ID_Tab
000068  42b0              CMP      r0,r6
00006a  d107              BNE      |L7.124|
00006c  4806              LDR      r0,|L7.136|
00006e  7880              LDRB     r0,[r0,#2]  ; ID_Tab
000070  42b8              CMP      r0,r7
000072  d103              BNE      |L7.124|
000074  4804              LDR      r0,|L7.136|
000076  78c0              LDRB     r0,[r0,#3]  ; ID_Tab
000078  4540              CMP      r0,r8
00007a  d001              BEQ      |L7.128|
                  |L7.124|
;;;815    	{
;;;816    	       Err_State();
00007c  f7fffffe          BL       Err_State
                  |L7.128|
;;;817    	 }
;;;818    }
000080  e8bd81f0          POP      {r4-r8,pc}
;;;819    
                          ENDP

                  |L7.132|
                          DCD      0x40010800
                  |L7.136|
                          DCD      ID_Tab

                          AREA ||i.A7129_WritePageA||, CODE, READONLY, ALIGN=2

                  A7129_WritePageA PROC
;;;702    //A7129_WritePageA
;;;703    void A7129_WritePageA(uint8_t address, uint16_t dataWord)
000000  b570              PUSH     {r4-r6,lr}
;;;704    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;705    	    uint16_t tmp;
;;;706    	
;;;707    	    tmp = address;
000006  4625              MOV      r5,r4
;;;708    	    tmp = ((tmp << 12) | A7129Config[CRYSTAL_REG]);
000008  4806              LDR      r0,|L8.36|
00000a  89c0              LDRH     r0,[r0,#0xe]  ; A7129Config
00000c  ea403005          ORR      r0,r0,r5,LSL #12
000010  b285              UXTH     r5,r0
;;;709    	    A7129_WriteReg(CRYSTAL_REG, tmp);
000012  4629              MOV      r1,r5
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       A7129_WriteReg
;;;710    	    A7129_WriteReg(PAGEA_REG, dataWord);
00001a  4631              MOV      r1,r6
00001c  2008              MOVS     r0,#8
00001e  f7fffffe          BL       A7129_WriteReg
;;;711    }
000022  bd70              POP      {r4-r6,pc}
;;;712    
                          ENDP

                  |L8.36|
                          DCD      A7129Config

                          AREA ||i.A7129_WritePageB||, CODE, READONLY, ALIGN=2

                  A7129_WritePageB PROC
;;;727    //A7129_WritePageB
;;;728    void A7129_WritePageB(uint8_t address, uint16_t dataWord)
000000  b570              PUSH     {r4-r6,lr}
;;;729    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;730    	    uint16_t tmp;
;;;731    	
;;;732    	    tmp = address;
000006  4625              MOV      r5,r4
;;;733    	    tmp = ((tmp << 7) | A7129Config[CRYSTAL_REG]);
000008  4806              LDR      r0,|L9.36|
00000a  89c0              LDRH     r0,[r0,#0xe]  ; A7129Config
00000c  ea4010c5          ORR      r0,r0,r5,LSL #7
000010  b285              UXTH     r5,r0
;;;734    	    A7129_WriteReg(CRYSTAL_REG, tmp);
000012  4629              MOV      r1,r5
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       A7129_WriteReg
;;;735    	    A7129_WriteReg(PAGEB_REG, dataWord);
00001a  4631              MOV      r1,r6
00001c  2009              MOVS     r0,#9
00001e  f7fffffe          BL       A7129_WriteReg
;;;736    }
000022  bd70              POP      {r4-r6,pc}
;;;737    
                          ENDP

                  |L9.36|
                          DCD      A7129Config

                          AREA ||i.A7129_WriteReg||, CODE, READONLY, ALIGN=2

                  A7129_WriteReg PROC
;;;580    //A7129_WriteReg
;;;581    void A7129_WriteReg(uint8_t address, uint16_t dataWord)
000000  b570              PUSH     {r4-r6,lr}
;;;582    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;583        uint8_t i;
;;;584    
;;;585        //SCS=0;
;;;586        Write_SCS_LO(); 
000006  2110              MOVS     r1,#0x10
000008  4824              LDR      r0,|L10.156|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;587        address |= CMD_Reg_W;
00000e  bf00              NOP      
;;;588        for(i=0; i<8; i++)
000010  2500              MOVS     r5,#0
000012  e019              B        |L10.72|
                  |L10.20|
;;;589        {
;;;590            if(address & 0x80)
000014  f0140f80          TST      r4,#0x80
000018  d004              BEQ      |L10.36|
;;;591            {
;;;592                //SDIO = 1;
;;;593                 Write_SDIO_HI(); 
00001a  2180              MOVS     r1,#0x80
00001c  481f              LDR      r0,|L10.156|
00001e  f7fffffe          BL       GPIO_SetBits
000022  e003              B        |L10.44|
                  |L10.36|
;;;594            }
;;;595            else
;;;596            {
;;;597                //SDIO = 0;
;;;598                 Write_SDIO_LO(); 
000024  2180              MOVS     r1,#0x80
000026  481d              LDR      r0,|L10.156|
000028  f7fffffe          BL       GPIO_ResetBits
                  |L10.44|
;;;599            }
;;;600    
;;;601            //SCK=1;
;;;602            Write_SCK_HI(); 
00002c  2120              MOVS     r1,#0x20
00002e  481b              LDR      r0,|L10.156|
000030  f7fffffe          BL       GPIO_SetBits
;;;603            My_NOP(); 
000034  f7fffffe          BL       My_NOP
;;;604            //SCK=0;
;;;605            Write_SCK_LO(); 
000038  2120              MOVS     r1,#0x20
00003a  4818              LDR      r0,|L10.156|
00003c  f7fffffe          BL       GPIO_ResetBits
;;;606            address<<=1;
000040  0660              LSLS     r0,r4,#25
000042  0e04              LSRS     r4,r0,#24
000044  1c68              ADDS     r0,r5,#1              ;588
000046  b2c5              UXTB     r5,r0                 ;588
                  |L10.72|
000048  2d08              CMP      r5,#8                 ;588
00004a  dbe3              BLT      |L10.20|
;;;607        }
;;;608        My_NOP();
00004c  f7fffffe          BL       My_NOP
;;;609    
;;;610        //send data word
;;;611        for(i=0; i<16; i++)
000050  2500              MOVS     r5,#0
000052  e01b              B        |L10.140|
                  |L10.84|
;;;612        {
;;;613            if(dataWord & 0x8000)
000054  f4164f00          TST      r6,#0x8000
000058  d004              BEQ      |L10.100|
;;;614            {
;;;615                //SDIO = 1;
;;;616                Write_SDIO_HI(); 
00005a  2180              MOVS     r1,#0x80
00005c  480f              LDR      r0,|L10.156|
00005e  f7fffffe          BL       GPIO_SetBits
000062  e003              B        |L10.108|
                  |L10.100|
;;;617            }
;;;618            else
;;;619            {
;;;620                //SDIO = 0;
;;;621                Write_SDIO_LO(); 
000064  2180              MOVS     r1,#0x80
000066  480d              LDR      r0,|L10.156|
000068  f7fffffe          BL       GPIO_ResetBits
                  |L10.108|
;;;622            }
;;;623    
;;;624            //SCK=1;
;;;625            Write_SCK_HI(); 
00006c  2120              MOVS     r1,#0x20
00006e  480b              LDR      r0,|L10.156|
000070  f7fffffe          BL       GPIO_SetBits
;;;626             
;;;627            My_NOP();
000074  f7fffffe          BL       My_NOP
;;;628            //SCK=0;
;;;629            Write_SCK_LO(); 
000078  2120              MOVS     r1,#0x20
00007a  4808              LDR      r0,|L10.156|
00007c  f7fffffe          BL       GPIO_ResetBits
;;;630            dataWord<<=1;
000080  f64f70ff          MOV      r0,#0xffff
000084  ea000646          AND      r6,r0,r6,LSL #1
000088  1c68              ADDS     r0,r5,#1              ;611
00008a  b2c5              UXTB     r5,r0                 ;611
                  |L10.140|
00008c  2d10              CMP      r5,#0x10              ;611
00008e  dbe1              BLT      |L10.84|
;;;631        }
;;;632        //SCS=1;
;;;633        Write_SCS_HI(); 
000090  2110              MOVS     r1,#0x10
000092  4802              LDR      r0,|L10.156|
000094  f7fffffe          BL       GPIO_SetBits
;;;634    }
000098  bd70              POP      {r4-r6,pc}
;;;635    
                          ENDP

00009a  0000              DCW      0x0000
                  |L10.156|
                          DCD      0x40010800

                          AREA ||i.A7139_Delay10us||, CODE, READONLY, ALIGN=1

                  A7139_Delay10us PROC
;;;970    //========================================================================================
;;;971    void A7139_Delay10us(uint16_t dly)
000000  b500              PUSH     {lr}
;;;972    {
000002  4602              MOV      r2,r0
;;;973    	uint16_t td;
;;;974    	
;;;975    	td=dly;
000004  4613              MOV      r3,r2
;;;976    	while(td>0)
000006  e003              B        |L11.16|
                  |L11.8|
;;;977    	{
;;;978    	    td--;
000008  1e58              SUBS     r0,r3,#1
00000a  b283              UXTH     r3,r0
;;;979    	    My_NOP();
00000c  f7fffffe          BL       My_NOP
                  |L11.16|
000010  2b00              CMP      r3,#0                 ;976
000012  dcf9              BGT      |L11.8|
;;;980    	}
;;;981    }
000014  bd00              POP      {pc}
;;;982    
                          ENDP


                          AREA ||i.ByteRead||, CODE, READONLY, ALIGN=2

                  ByteRead PROC
;;;548    //读字节
;;;549    uint8_t ByteRead(void)
000000  b570              PUSH     {r4-r6,lr}
;;;550    {
;;;551    	uint8_t i,tmp=0;
000002  2400              MOVS     r4,#0
;;;552    
;;;553        	//TRIS_SDIO = 1;
;;;554        	Set_SDIO_Direction(1);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       Set_SDIO_Direction
;;;555        	
;;;556        	for(i=0; i<8; i++)
00000a  2500              MOVS     r5,#0
00000c  e017              B        |L12.62|
                  |L12.14|
;;;557        	{
;;;558    	        //if(SDIO)
;;;559    	        if(0!=Read_SDIO())
00000e  2180              MOVS     r1,#0x80
000010  480e              LDR      r0,|L12.76|
000012  f7fffffe          BL       GPIO_ReadInputDataBit
000016  b120              CBZ      r0,|L12.34|
;;;560    	       {
;;;561    	            tmp = (tmp << 1) | 0x01;
000018  2001              MOVS     r0,#1
00001a  eb000044          ADD      r0,r0,r4,LSL #1
00001e  b2c4              UXTB     r4,r0
000020  e001              B        |L12.38|
                  |L12.34|
;;;562    	        }
;;;563    	        else
;;;564    	        {
;;;565    	            tmp = tmp << 1;
000022  0660              LSLS     r0,r4,#25
000024  0e04              LSRS     r4,r0,#24
                  |L12.38|
;;;566    	        }
;;;567    
;;;568    	        //SCK=1;
;;;569    	        Write_SCK_HI();  
000026  2120              MOVS     r1,#0x20
000028  4808              LDR      r0,|L12.76|
00002a  f7fffffe          BL       GPIO_SetBits
;;;570    	        My_NOP();
00002e  f7fffffe          BL       My_NOP
;;;571    	        //SCK=0;
;;;572    	        Write_SCK_LO(); 
000032  2120              MOVS     r1,#0x20
000034  4805              LDR      r0,|L12.76|
000036  f7fffffe          BL       GPIO_ResetBits
00003a  1c68              ADDS     r0,r5,#1              ;556
00003c  b2c5              UXTB     r5,r0                 ;556
                  |L12.62|
00003e  2d08              CMP      r5,#8                 ;556
000040  dbe5              BLT      |L12.14|
;;;573        	}
;;;574    	//TRIS_SDIO = 0;
;;;575    	Set_SDIO_Direction(0);
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       Set_SDIO_Direction
;;;576        	return tmp;
000048  4620              MOV      r0,r4
;;;577    }
00004a  bd70              POP      {r4-r6,pc}
;;;578    
                          ENDP

                  |L12.76|
                          DCD      0x40010800

                          AREA ||i.ByteSend||, CODE, READONLY, ALIGN=2

                  ByteSend PROC
;;;519    //发送一个字节
;;;520    void ByteSend(uint8_t src)
000000  b570              PUSH     {r4-r6,lr}
;;;521    {
000002  4604              MOV      r4,r0
;;;522        uint8_t i;
;;;523    
;;;524        for(i=0; i<8; i++)
000004  2500              MOVS     r5,#0
000006  e01b              B        |L13.64|
                  |L13.8|
;;;525        {
;;;526            if(src & 0x80)
000008  f0140f80          TST      r4,#0x80
00000c  d004              BEQ      |L13.24|
;;;527            {
;;;528                //SDIO = 1;
;;;529                 Write_SDIO_HI(); 
00000e  2180              MOVS     r1,#0x80
000010  480d              LDR      r0,|L13.72|
000012  f7fffffe          BL       GPIO_SetBits
000016  e003              B        |L13.32|
                  |L13.24|
;;;530            }
;;;531            else
;;;532            {
;;;533                //SDIO = 0;
;;;534                Write_SDIO_LO(); 
000018  2180              MOVS     r1,#0x80
00001a  480b              LDR      r0,|L13.72|
00001c  f7fffffe          BL       GPIO_ResetBits
                  |L13.32|
;;;535            }
;;;536    
;;;537    	My_NOP();
000020  f7fffffe          BL       My_NOP
;;;538            //SCK=1;
;;;539            Write_SCK_HI(); 
000024  2120              MOVS     r1,#0x20
000026  4808              LDR      r0,|L13.72|
000028  f7fffffe          BL       GPIO_SetBits
;;;540            My_NOP();
00002c  f7fffffe          BL       My_NOP
;;;541            //SCK=0;
;;;542            Write_SCK_LO(); 
000030  2120              MOVS     r1,#0x20
000032  4805              LDR      r0,|L13.72|
000034  f7fffffe          BL       GPIO_ResetBits
;;;543            src<<=1;
000038  0660              LSLS     r0,r4,#25
00003a  0e04              LSRS     r4,r0,#24
00003c  1c68              ADDS     r0,r5,#1              ;524
00003e  b2c5              UXTB     r5,r0                 ;524
                  |L13.64|
000040  2d08              CMP      r5,#8                 ;524
000042  dbe1              BLT      |L13.8|
;;;544        }
;;;545    }
000044  bd70              POP      {r4-r6,pc}
;;;546    
                          ENDP

000046  0000              DCW      0x0000
                  |L13.72|
                          DCD      0x40010800

                          AREA ||i.DSSS_MODE||, CODE, READONLY, ALIGN=2

                  DSSS_MODE PROC
;;;1189   *********************************************************************/
;;;1190   void DSSS_MODE(void)
000000  b510              PUSH     {r4,lr}
;;;1191   {
;;;1192   	A7129_WritePageA(CODE_PAGEA, 0x5502);	//PML=3bytes, IDL=1bytes
000002  f2455102          MOV      r1,#0x5502
000006  200e              MOVS     r0,#0xe
000008  f7fffffe          BL       A7129_WritePageA
;;;1193   	//DSSS mode : Preamble Length=3bytes
;;;1194   	//IDL[1:0]=[x0], x=don't care, ID Length=1byte
;;;1195   	//IDL[1:0]=[x1], x=don't care, ID Length=2bytes
;;;1196   	
;;;1197   	A7129_WritePageB(DC_SHIFT_PAGEB, A7129Config_PageB[DC_SHIFT_PAGEB] | 0x0400);	//DSSS mode : Preamble detect=2bytes
00000c  480f              LDR      r0,|L14.76|
00000e  8cc0              LDRH     r0,[r0,#0x26]  ; A7129Config_PageB
000010  f4406180          ORR      r1,r0,#0x400
000014  2013              MOVS     r0,#0x13
000016  f7fffffe          BL       A7129_WritePageB
;;;1198   	A7129_WritePageB(DSSS_PAGEB, A7129Config_PageB[DSSS_PAGEB] | 0xC4FF);	//DSSS setting : ETHM=3, DSSS_SEL=1, FSYNC_D=255
00001a  480c              LDR      r0,|L14.76|
00001c  89c0              LDRH     r0,[r0,#0xe]  ; A7129Config_PageB
00001e  f24c42ff          MOV      r2,#0xc4ff
000022  ea400102          ORR      r1,r0,r2
000026  2007              MOVS     r0,#7
000028  f7fffffe          BL       A7129_WritePageB
;;;1199   	A7129_WritePageB(DSSS2_PAGEB, A7129Config_PageB[DSSS2_PAGEB] | 0x6200);	//TCNT_SEL=1, TCNT=34
00002c  4807              LDR      r0,|L14.76|
00002e  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config_PageB
000030  f44041c4          ORR      r1,r0,#0x6200
000034  200f              MOVS     r0,#0xf
000036  f7fffffe          BL       A7129_WritePageB
;;;1200   	A7129_WritePageB(SYN_PAGEB, A7129Config_PageB[SYN_PAGEB] | 0x0400);		//enable DSSS=1
00003a  4804              LDR      r0,|L14.76|
00003c  8940              LDRH     r0,[r0,#0xa]  ; A7129Config_PageB
00003e  f4406180          ORR      r1,r0,#0x400
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       A7129_WritePageB
;;;1201   }
000048  bd10              POP      {r4,pc}
;;;1202   #endif
                          ENDP

00004a  0000              DCW      0x0000
                  |L14.76|
                          DCD      A7129Config_PageB

                          AREA ||i.Err_State||, CODE, READONLY, ALIGN=2

                  Err_State PROC
;;;475    //错误状态
;;;476    void Err_State(void)
000000  2055              MOVS     r0,#0x55
;;;477    {
;;;478        //ERR display
;;;479        //Error Proc...
;;;480        //...
;;;481        //while(1);							//clf add 
;;;482        init_err=0x55;
000002  4901              LDR      r1,|L15.8|
000004  7008              STRB     r0,[r1,#0]
;;;483    		  
;;;484    }
000006  4770              BX       lr
;;;485    //==============================================================================================
                          ENDP

                  |L15.8|
                          DCD      init_err

                          AREA ||i.My_NOP||, CODE, READONLY, ALIGN=1

                  My_NOP PROC
;;;989    //========================================================================================
;;;990    void My_NOP(void)
000000  2000              MOVS     r0,#0
;;;991    {
;;;992    	uint8_t dly;
;;;993    	for(dly=0;dly<10;dly++);	
000002  e001              B        |L16.8|
                  |L16.4|
000004  1c41              ADDS     r1,r0,#1
000006  b2c8              UXTB     r0,r1
                  |L16.8|
000008  280a              CMP      r0,#0xa
00000a  dbfb              BLT      |L16.4|
;;;994    }
00000c  4770              BX       lr
;;;995    
                          ENDP


                          AREA ||i.RCOSC_Cal||, CODE, READONLY, ALIGN=2

                  RCOSC_Cal PROC
;;;1002   *********************************************************************/
;;;1003   void RCOSC_Cal(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1004   {
;;;1005           Uint16 tmp;
;;;1006   	Uint16 TGNUM;  
;;;1007   	
;;;1008   	StrobeCMD(CMD_STBY);
000002  2014              MOVS     r0,#0x14
000004  f7fffffe          BL       StrobeCMD
;;;1009   	
;;;1010   	TGNUM = RCOSC_TGNUM;
000008  f240158b          MOV      r5,#0x18b
;;;1011   	A7129_WritePageB(CCM1_PAGEB, (TGNUM<<4));
00000c  f64f70ff          MOV      r0,#0xffff
000010  ea001105          AND      r1,r0,r5,LSL #4
000014  2008              MOVS     r0,#8
000016  f7fffffe          BL       A7129_WritePageB
;;;1012   
;;;1013   	A7129_WritePageA(WOR2_PAGEA, A7129Config_PageA[WOR2_PAGEA] | 0x0011);		//enable RC OSC and RCOT=1
00001a  4814              LDR      r0,|L17.108|
00001c  8880              LDRH     r0,[r0,#4]  ; A7129Config_PageA
00001e  f0400111          ORR      r1,r0,#0x11
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       A7129_WritePageA
;;;1014   
;;;1015   	while(1)
000028  e01c              B        |L17.100|
                  |L17.42|
;;;1016   	{
;;;1017   		A7129_WritePageA(WCAL_PAGEA, A7129Config_PageA[WCAL_PAGEA] | 0x0001);	//set ENCAL=1 to start RC OSC CAL
00002a  4810              LDR      r0,|L17.108|
00002c  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config_PageA
00002e  f0400101          ORR      r1,r0,#1
000032  200f              MOVS     r0,#0xf
000034  f7fffffe          BL       A7129_WritePageA
;;;1018   		do{
000038  bf00              NOP      
                  |L17.58|
;;;1019   			tmp = A7129_ReadPageA(WCAL_PAGEA);
00003a  200f              MOVS     r0,#0xf
00003c  f7fffffe          BL       A7129_ReadPageA
000040  4604              MOV      r4,r0
;;;1020   		}while(tmp & 0x0001);
000042  f0140f01          TST      r4,#1
000046  d1f8              BNE      |L17.58|
;;;1021   			
;;;1022   		tmp = (A7129_ReadPageA(WCAL_PAGEA) & 0x1FFF);		//read NUMLH[11:0]
000048  200f              MOVS     r0,#0xf
00004a  f7fffffe          BL       A7129_ReadPageA
00004e  f3c0040c          UBFX     r4,r0,#0,#13
;;;1023   		tmp >>= 1;	
000052  1064              ASRS     r4,r4,#1
;;;1024   		
;;;1025   		if((tmp > (TGNUM-10)) && (tmp < (TGNUM+10)))		//NUMLH[11:0]=TGNUM+-10
000054  f1a5000a          SUB      r0,r5,#0xa
000058  42a0              CMP      r0,r4
00005a  da03              BGE      |L17.100|
00005c  3014              ADDS     r0,r0,#0x14
00005e  4284              CMP      r4,r0
000060  da00              BGE      |L17.100|
;;;1026   		{
;;;1027   			break;
000062  e000              B        |L17.102|
                  |L17.100|
000064  e7e1              B        |L17.42|
                  |L17.102|
000066  bf00              NOP      
;;;1028   		}
;;;1029   	}
;;;1030   }
000068  bd70              POP      {r4-r6,pc}
;;;1031   
                          ENDP

00006a  0000              DCW      0x0000
                  |L17.108|
                          DCD      A7129Config_PageA

                          AREA ||i.RF_RX||, CODE, READONLY, ALIGN=2

                  RF_RX PROC
;;;460    //无线模块 接收
;;;461    uint8_t RF_RX(uint8_t *buf,uint8_t *plen)
000000  b570              PUSH     {r4-r6,lr}
;;;462    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;463      uint8_t cnt;
;;;464    	if(0==Read_GIO2()) 
000006  2140              MOVS     r1,#0x40
000008  4807              LDR      r0,|L18.40|
00000a  f7fffffe          BL       GPIO_ReadInputDataBit
00000e  b940              CBNZ     r0,|L18.34|
;;;465    	{
;;;466    		 cnt=RxPacket(buf);
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       RxPacket
000016  4605              MOV      r5,r0
;;;467    		 My_NOP();
000018  f7fffffe          BL       My_NOP
;;;468    		 *plen=cnt;		 
00001c  7025              STRB     r5,[r4,#0]
;;;469         return 1;
00001e  2001              MOVS     r0,#1
                  |L18.32|
;;;470    	}	 
;;;471    	return 0;
;;;472    }
000020  bd70              POP      {r4-r6,pc}
                  |L18.34|
000022  2000              MOVS     r0,#0                 ;471
000024  e7fc              B        |L18.32|
;;;473    
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
                          DCD      0x40010800

                          AREA ||i.RF_TX||, CODE, READONLY, ALIGN=2

                  RF_TX PROC
;;;411    //无线模块 发送
;;;412    void RF_TX(uint8_t *buf,uint8_t length)
000000  b570              PUSH     {r4-r6,lr}
;;;413    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;414    	uint16_t yy;
;;;415    	
;;;416    	StrobeCMD(CMD_STBY);		
000006  2014              MOVS     r0,#0x14
000008  f7fffffe          BL       StrobeCMD
;;;417    	A7129_WritePageA(FIFO_PAGEA,length);//clf ?20171129
00000c  4631              MOV      r1,r6
00000e  200d              MOVS     r0,#0xd
000010  f7fffffe          BL       A7129_WritePageA
;;;418    	StrobeCMD(CMD_TFR);
000014  2060              MOVS     r0,#0x60
000016  f7fffffe          BL       StrobeCMD
;;;419    	A7129_WriteFIFO(buf,length); 	//write data to TX FIFO
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       A7129_WriteFIFO
;;;420      StrobeCMD(CMD_TX);
000022  201a              MOVS     r0,#0x1a
000024  f7fffffe          BL       StrobeCMD
;;;421    	A7139_Delay10us(10);
000028  200a              MOVS     r0,#0xa
00002a  f7fffffe          BL       A7139_Delay10us
;;;422    	
;;;423    	
;;;424    	//========================================================================
;;;425    	#if 0
;;;426    	WaitForTime=50;
;;;427    	WaitFlag=0x5a;
;;;428    	#else
;;;429    	while(1==Read_GIO2()) 
00002e  e009              B        |L19.68|
                  |L19.48|
;;;430    	{
;;;431    		 yy++;
000030  1c60              ADDS     r0,r4,#1
000032  b284              UXTH     r4,r0
;;;432    		 A7139_Delay10us(10);
000034  200a              MOVS     r0,#0xa
000036  f7fffffe          BL       A7139_Delay10us
;;;433    		 if(yy>50000)break;	//测试用，暂时屏蔽
00003a  f24c3050          MOV      r0,#0xc350
00003e  4284              CMP      r4,r0
000040  dd00              BLE      |L19.68|
000042  e005              B        |L19.80|
                  |L19.68|
000044  2140              MOVS     r1,#0x40              ;429
000046  4808              LDR      r0,|L19.104|
000048  f7fffffe          BL       GPIO_ReadInputDataBit
00004c  2801              CMP      r0,#1                 ;429
00004e  d0ef              BEQ      |L19.48|
                  |L19.80|
000050  bf00              NOP      
;;;434    	}
;;;435    	StrobeCMD(CMD_STBY);
000052  2014              MOVS     r0,#0x14
000054  f7fffffe          BL       StrobeCMD
;;;436    	StrobeCMD(CMD_RX);
000058  2018              MOVS     r0,#0x18
00005a  f7fffffe          BL       StrobeCMD
;;;437    	A7139_Delay10us(1);
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       A7139_Delay10us
;;;438      #endif
;;;439    	//=========================================================================	
;;;440    }
000064  bd70              POP      {r4-r6,pc}
;;;441    
                          ENDP

000066  0000              DCW      0x0000
                  |L19.104|
                          DCD      0x40010800

                          AREA ||i.RF_TX1||, CODE, READONLY, ALIGN=2

                  RF_TX1 PROC
;;;384    //无线唤醒
;;;385    void RF_TX1(uint8_t *buf,uint8_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;386    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;387    				unsigned int yy=0;	
000008  2400              MOVS     r4,#0
;;;388    				unsigned int i;
;;;389    
;;;390    				StrobeCMD(CMD_STBY);								
00000a  2014              MOVS     r0,#0x14
00000c  f7fffffe          BL       StrobeCMD
;;;391    				A7129_WritePageA(FIFO_PAGEA,1);			
000010  2101              MOVS     r1,#1
000012  200d              MOVS     r0,#0xd
000014  f7fffffe          BL       A7129_WritePageA
;;;392    				StrobeCMD(CMD_TFR);
000018  2060              MOVS     r0,#0x60
00001a  f7fffffe          BL       StrobeCMD
;;;393    				for(i=0;i<550;i++)			//150MS
00001e  2500              MOVS     r5,#0
000020  e01a              B        |L20.88|
                  |L20.34|
;;;394    				//for(i=0;i<1815;i++)			//500MS
;;;395    				{
;;;396    					IWDG_Feed();
000022  f7fffffe          BL       IWDG_Feed
;;;397    	        A7129_WriteFIFO(buf,1);
000026  2101              MOVS     r1,#1
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       A7129_WriteFIFO
;;;398    					StrobeCMD(CMD_TX);
00002e  201a              MOVS     r0,#0x1a
000030  f7fffffe          BL       StrobeCMD
;;;399    					A7139_Delay10us(1);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       A7139_Delay10us
;;;400    					yy=0;
00003a  2400              MOVS     r4,#0
;;;401    					while(1==GPIO_ReadInputDataBit(GPIO_PORT_GIO2,GPIO_PIN_GIO2))
00003c  e004              B        |L20.72|
                  |L20.62|
;;;402    					{
;;;403    						 yy++;
00003e  1c64              ADDS     r4,r4,#1
;;;404    						 if(yy>0x65500)break;
000040  480b              LDR      r0,|L20.112|
000042  4284              CMP      r4,r0
000044  d900              BLS      |L20.72|
000046  e005              B        |L20.84|
                  |L20.72|
000048  2140              MOVS     r1,#0x40              ;401
00004a  480a              LDR      r0,|L20.116|
00004c  f7fffffe          BL       GPIO_ReadInputDataBit
000050  2801              CMP      r0,#1                 ;401
000052  d0f4              BEQ      |L20.62|
                  |L20.84|
000054  bf00              NOP      
000056  1c6d              ADDS     r5,r5,#1              ;393
                  |L20.88|
000058  f2402026          MOV      r0,#0x226             ;393
00005c  4285              CMP      r5,r0                 ;393
00005e  d3e0              BCC      |L20.34|
;;;405    					}
;;;406    				}
;;;407    				StrobeCMD(CMD_STBY);
000060  2014              MOVS     r0,#0x14
000062  f7fffffe          BL       StrobeCMD
;;;408    				A7139_Delay10us(10);
000066  200a              MOVS     r0,#0xa
000068  f7fffffe          BL       A7139_Delay10us
;;;409    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;410    //===============================================================================================
                          ENDP

                  |L20.112|
                          DCD      0x00065500
                  |L20.116|
                          DCD      0x40010800

                          AREA ||i.RF_WaitForSend||, CODE, READONLY, ALIGN=2

                  RF_WaitForSend PROC
;;;443    //每10mS进来检测一次
;;;444    uint8_t RF_WaitForSend(void)
000000  b510              PUSH     {r4,lr}
;;;445    {
;;;446     	
;;;447    	if(WaitFlag==0)return 0;
000002  480e              LDR      r0,|L21.60|
000004  7800              LDRB     r0,[r0,#0]  ; WaitFlag
000006  b908              CBNZ     r0,|L21.12|
000008  2000              MOVS     r0,#0
                  |L21.10|
;;;448    	
;;;449    	if(WaitForTime>0)WaitForTime--;
;;;450    	if((WaitForTime==0)||(0==Read_GIO2()))
;;;451    	{
;;;452    		WaitFlag=0;
;;;453    		Rf_Power_En(0);
;;;454    	}
;;;455    	
;;;456    	return 1;
;;;457    	
;;;458    }
00000a  bd10              POP      {r4,pc}
                  |L21.12|
00000c  480c              LDR      r0,|L21.64|
00000e  7800              LDRB     r0,[r0,#0]            ;449  ; WaitForTime
000010  2800              CMP      r0,#0                 ;449
000012  dd04              BLE      |L21.30|
000014  480a              LDR      r0,|L21.64|
000016  7800              LDRB     r0,[r0,#0]            ;449  ; WaitForTime
000018  1e40              SUBS     r0,r0,#1              ;449
00001a  4909              LDR      r1,|L21.64|
00001c  7008              STRB     r0,[r1,#0]            ;449
                  |L21.30|
00001e  4808              LDR      r0,|L21.64|
000020  7800              LDRB     r0,[r0,#0]            ;450  ; WaitForTime
000022  b120              CBZ      r0,|L21.46|
000024  2140              MOVS     r1,#0x40              ;450
000026  4807              LDR      r0,|L21.68|
000028  f7fffffe          BL       GPIO_ReadInputDataBit
00002c  b920              CBNZ     r0,|L21.56|
                  |L21.46|
00002e  2000              MOVS     r0,#0                 ;452
000030  4902              LDR      r1,|L21.60|
000032  7008              STRB     r0,[r1,#0]            ;452
000034  f7fffffe          BL       Rf_Power_En
                  |L21.56|
000038  2001              MOVS     r0,#1                 ;456
00003a  e7e6              B        |L21.10|
;;;459    //==============================================================================================
                          ENDP

                  |L21.60|
                          DCD      WaitFlag
                  |L21.64|
                          DCD      WaitForTime
                  |L21.68|
                          DCD      0x40010800

                          AREA ||i.RSSI_measurement||, CODE, READONLY, ALIGN=2

                  RSSI_measurement PROC
;;;1163   //================================================================================
;;;1164   void RSSI_measurement(void)
000000  b510              PUSH     {r4,lr}
;;;1165   {
;;;1166   	Uint16 tmp;
;;;1167   
;;;1168   	StrobeCMD(CMD_STBY);
000002  2014              MOVS     r0,#0x14
000004  f7fffffe          BL       StrobeCMD
;;;1169   	
;;;1170   	A7129_WritePageA(GIO_PAGEA, (A7129Config_PageA[GIO_PAGEA] & 0xF000) | 0x0045);	//GIO1=FSYNC, GIO2=WTR
000008  4816              LDR      r0,|L22.100|
00000a  8a00              LDRH     r0,[r0,#0x10]  ; A7129Config_PageA
00000c  f4004070          AND      r0,r0,#0xf000
000010  f0400145          ORR      r1,r0,#0x45
000014  2008              MOVS     r0,#8
000016  f7fffffe          BL       A7129_WritePageA
;;;1171   	
;;;1172   	A7129_WriteReg(ADC_REG, A7129Config[ADC_REG] | 0x8000);		//ARSSI=1
00001a  4813              LDR      r0,|L22.104|
00001c  8b00              LDRH     r0,[r0,#0x18]  ; A7129Config
00001e  f4404100          ORR      r1,r0,#0x8000
000022  200c              MOVS     r0,#0xc
000024  f7fffffe          BL       A7129_WriteReg
;;;1173   	
;;;1174   	StrobeCMD(CMD_RX);	//entry RX mode
000028  2018              MOVS     r0,#0x18
00002a  f7fffffe          BL       StrobeCMD
;;;1175   	A7139_Delay10us(1);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       A7139_Delay10us
;;;1176   	
;;;1177   	while(Read_GIO2()==0)		//Stay in WOR mode until receiving ID code(sync ok)
000034  e003              B        |L22.62|
                  |L22.54|
;;;1178   	{
;;;1179   		tmp = (A7129_ReadReg(ADC_REG) & 0x00FF);	//read RSSI value(environment RSSI)
000036  200c              MOVS     r0,#0xc
000038  f7fffffe          BL       A7129_ReadReg
00003c  b2c4              UXTB     r4,r0
                  |L22.62|
00003e  2140              MOVS     r1,#0x40              ;1177
000040  480a              LDR      r0,|L22.108|
000042  f7fffffe          BL       GPIO_ReadInputDataBit
000046  2800              CMP      r0,#0                 ;1177
000048  d0f5              BEQ      |L22.54|
;;;1180   	}
;;;1181   	tmp = (A7129_ReadReg(ADC_REG) & 0x00FF);		//read RSSI value(wanted signal RSSI)
00004a  200c              MOVS     r0,#0xc
00004c  f7fffffe          BL       A7129_ReadReg
000050  b2c4              UXTB     r4,r0
;;;1182   	RSSI=tmp;
000052  4807              LDR      r0,|L22.112|
000054  6004              STR      r4,[r0,#0]  ; RSSI
;;;1183   	My_NOP();
000056  f7fffffe          BL       My_NOP
;;;1184   	My_NOP();
00005a  f7fffffe          BL       My_NOP
;;;1185   	My_NOP();
00005e  f7fffffe          BL       My_NOP
;;;1186   }
000062  bd10              POP      {r4,pc}
;;;1187   /*********************************************************************
                          ENDP

                  |L22.100|
                          DCD      A7129Config_PageA
                  |L22.104|
                          DCD      A7129Config
                  |L22.108|
                          DCD      0x40010800
                  |L22.112|
                          DCD      RSSI

                          AREA ||i.Rf_Power_En||, CODE, READONLY, ALIGN=1

                  Rf_Power_En PROC
;;;983    //==========================================================================================
;;;984    void Rf_Power_En(uint8_t stu)
000000  4770              BX       lr
;;;985    {
;;;986    
;;;987    }
;;;988    
                          ENDP


                          AREA ||i.RxPacket||, CODE, READONLY, ALIGN=2

                  RxPacket PROC
;;;925    //RxPacket
;;;926    uint8_t RxPacket(uint8_t *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;927    {
000002  4606              MOV      r6,r0
;;;928    	    uint8_t i;
;;;929    	    uint8_t tmp;
;;;930    	
;;;931    	    StrobeCMD(CMD_RFR);		//RX FIFO address pointer reset
000004  20e0              MOVS     r0,#0xe0
000006  f7fffffe          BL       StrobeCMD
;;;932        	//SCS=0;
;;;933        	Write_SCS_LO(); 
00000a  2110              MOVS     r1,#0x10
00000c  4816              LDR      r0,|L24.104|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;934        	   
;;;935    			//StrobeCMD(CMD_RFR);		//RX FIFO address pointer reset  //clf mod 20171201
;;;936    	    ByteSend(CMD_FIFO_R);		//RX FIFO read command
000012  20c0              MOVS     r0,#0xc0
000014  f7fffffe          BL       ByteSend
;;;937    	    tmp =ByteRead();
000018  f7fffffe          BL       ByteRead
00001c  4605              MOV      r5,r0
;;;938    	
;;;939    	    //数据过长
;;;940    	    if(tmp>=(RF_DATA_BUF_MAX_LEN-1))
00001e  2d3f              CMP      r5,#0x3f
000020  db07              BLT      |L24.50|
;;;941    	    {
;;;942    					StrobeCMD(CMD_STBY);
000022  2014              MOVS     r0,#0x14
000024  f7fffffe          BL       StrobeCMD
;;;943    					StrobeCMD(CMD_RX);
000028  2018              MOVS     r0,#0x18
00002a  f7fffffe          BL       StrobeCMD
;;;944    					//Set_GPIO_SCS();
;;;945    					//Write_SCS_HI(); 
;;;946    					return 0;
00002e  2000              MOVS     r0,#0
                  |L24.48|
;;;947          }
;;;948    			
;;;949    			
;;;950    			if(tmp==0)return 0;
;;;951    				
;;;952    	    for(i=0; i<tmp; i++)																		//此处要当心，缓冲区要开的大点
;;;953    	    {
;;;954    					buf[i] = ByteRead();
;;;955    	    }
;;;956    			
;;;957    	    //bsp_InitRF(1);
;;;958    			
;;;959    			StrobeCMD(CMD_RF_RST);
;;;960    			A7139_Delay10us(80);	
;;;961    			//StrobeCMD(CMD_STBY);
;;;962    			StrobeCMD(CMD_RX);
;;;963    			
;;;964    	    //SCS=1;
;;;965    	    Write_SCS_HI(); 
;;;966    	    
;;;967    	    return tmp;			//返回长度 
;;;968    }
000030  bd70              POP      {r4-r6,pc}
                  |L24.50|
000032  b90d              CBNZ     r5,|L24.56|
000034  2000              MOVS     r0,#0                 ;950
000036  e7fb              B        |L24.48|
                  |L24.56|
000038  2400              MOVS     r4,#0                 ;952
00003a  e004              B        |L24.70|
                  |L24.60|
00003c  f7fffffe          BL       ByteRead
000040  5530              STRB     r0,[r6,r4]            ;954
000042  1c60              ADDS     r0,r4,#1              ;952
000044  b2c4              UXTB     r4,r0                 ;952
                  |L24.70|
000046  42ac              CMP      r4,r5                 ;952
000048  dbf8              BLT      |L24.60|
00004a  20ff              MOVS     r0,#0xff              ;959
00004c  f7fffffe          BL       StrobeCMD
000050  2050              MOVS     r0,#0x50              ;960
000052  f7fffffe          BL       A7139_Delay10us
000056  2018              MOVS     r0,#0x18              ;962
000058  f7fffffe          BL       StrobeCMD
00005c  2110              MOVS     r1,#0x10              ;965
00005e  4802              LDR      r0,|L24.104|
000060  f7fffffe          BL       GPIO_SetBits
000064  4628              MOV      r0,r5                 ;967
000066  e7e3              B        |L24.48|
;;;969    
                          ENDP

                  |L24.104|
                          DCD      0x40010800

                          AREA ||i.Set_SDIO_Direction||, CODE, READONLY, ALIGN=2

                  Set_SDIO_Direction PROC
;;;364    //参数：0-输出，1-输入
;;;365    void Set_SDIO_Direction(uint8_t val)
000000  b538              PUSH     {r3-r5,lr}
;;;366    {
000002  4604              MOV      r4,r0
;;;367    	
;;;368    	GPIO_InitTypeDef GPIO_InitStructure;
;;;369    	if(val==0)
000004  b91c              CBNZ     r4,|L25.14|
;;;370    	{
;;;371    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;		/* ????? */
000006  2010              MOVS     r0,#0x10
000008  f88d0003          STRB     r0,[sp,#3]
00000c  e002              B        |L25.20|
                  |L25.14|
;;;372    	}
;;;373    	else
;;;374    	{
;;;375    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;		//??????,????
00000e  2048              MOVS     r0,#0x48
000010  f88d0003          STRB     r0,[sp,#3]
                  |L25.20|
;;;376    	}
;;;377    
;;;378    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO????? */	
000014  2003              MOVS     r0,#3
000016  f88d0002          STRB     r0,[sp,#2]
;;;379    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_SDIO;
00001a  2080              MOVS     r0,#0x80
00001c  f8ad0000          STRH     r0,[sp,#0]
;;;380    	GPIO_Init(GPIO_PORT_SDIO, &GPIO_InitStructure);
000020  4669              MOV      r1,sp
000022  4802              LDR      r0,|L25.44|
000024  f7fffffe          BL       GPIO_Init
;;;381    }
000028  bd38              POP      {r3-r5,pc}
;;;382    
                          ENDP

00002a  0000              DCW      0x0000
                  |L25.44|
                          DCD      0x40010800

                          AREA ||i.StrobeCMD||, CODE, READONLY, ALIGN=2

                  StrobeCMD PROC
;;;486    // Strobe Command
;;;487    void StrobeCMD(uint8_t cmd)
000000  b570              PUSH     {r4-r6,lr}
;;;488    {
000002  4604              MOV      r4,r0
;;;489        uint8_t i;
;;;490    
;;;491        //SCS=0;
;;;492        Write_SCS_LO(); 
000004  2110              MOVS     r1,#0x10
000006  4814              LDR      r0,|L26.88|
000008  f7fffffe          BL       GPIO_ResetBits
;;;493        
;;;494        for(i=0;i<8; i++)
00000c  2500              MOVS     r5,#0
00000e  e01b              B        |L26.72|
                  |L26.16|
;;;495        {
;;;496            if(cmd & 0x80)
000010  f0140f80          TST      r4,#0x80
000014  d004              BEQ      |L26.32|
;;;497            {
;;;498                //SDIO = 1;
;;;499                Write_SDIO_HI(); 
000016  2180              MOVS     r1,#0x80
000018  480f              LDR      r0,|L26.88|
00001a  f7fffffe          BL       GPIO_SetBits
00001e  e003              B        |L26.40|
                  |L26.32|
;;;500            }
;;;501            else
;;;502            {
;;;503                //SDIO = 0;
;;;504                Write_SDIO_LO(); 
000020  2180              MOVS     r1,#0x80
000022  480d              LDR      r0,|L26.88|
000024  f7fffffe          BL       GPIO_ResetBits
                  |L26.40|
;;;505            }
;;;506            My_NOP();
000028  f7fffffe          BL       My_NOP
;;;507            //SCK=1;
;;;508            Write_SCK_HI();      
00002c  2120              MOVS     r1,#0x20
00002e  480a              LDR      r0,|L26.88|
000030  f7fffffe          BL       GPIO_SetBits
;;;509            My_NOP();
000034  f7fffffe          BL       My_NOP
;;;510            //SCK=0;
;;;511            Write_SCK_LO();        
000038  2120              MOVS     r1,#0x20
00003a  4807              LDR      r0,|L26.88|
00003c  f7fffffe          BL       GPIO_ResetBits
;;;512            cmd<<=1;
000040  0660              LSLS     r0,r4,#25
000042  0e04              LSRS     r4,r0,#24
000044  1c68              ADDS     r0,r5,#1              ;494
000046  b2c5              UXTB     r5,r0                 ;494
                  |L26.72|
000048  2d08              CMP      r5,#8                 ;494
00004a  dbe1              BLT      |L26.16|
;;;513        }
;;;514        //SCS=1;
;;;515        Write_SCS_HI(); 
00004c  2110              MOVS     r1,#0x10
00004e  4802              LDR      r0,|L26.88|
000050  f7fffffe          BL       GPIO_SetBits
;;;516    }
000054  bd70              POP      {r4-r6,pc}
;;;517    
                          ENDP

000056  0000              DCW      0x0000
                  |L26.88|
                          DCD      0x40010800

                          AREA ||i.WOR_enable_by_RSSI_carrier||, CODE, READONLY, ALIGN=2

                  WOR_enable_by_RSSI_carrier PROC
;;;1108   *********************************************************************/
;;;1109   void WOR_enable_by_RSSI_carrier(void)
000000  b510              PUSH     {r4,lr}
;;;1110   {
;;;1111   	RCOSC_Cal();     	//RC Oscillator Calibration
000002  f7fffffe          BL       RCOSC_Cal
;;;1112   	
;;;1113   	A7129_WritePageA(GIO_PAGEA, (A7129Config_PageA[GIO_PAGEA] & 0xF000) | 0x0049);	//GIO1=CD, GIO2=WTR
000006  4824              LDR      r0,|L27.152|
000008  8a00              LDRH     r0,[r0,#0x10]  ; A7129Config_PageA
00000a  f4004070          AND      r0,r0,#0xf000
00000e  f0400149          ORR      r1,r0,#0x49
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       A7129_WritePageA
;;;1114   	//A7159_WritePageA(GIO_PAGEA, (A7159Config_PageA[GIO_PAGEA] & 0xF000) | 0x0051);	//GIO1=TWWS, GIO2=WTR
;;;1115   
;;;1116   	//setup WOR Sleep time and Rx time
;;;1117   	//WOR Active Period = (WOR_AC[8:0]+1) x (1/32768), (30.5us ~ 15.6ms).
;;;1118   	//WOR Sleep  Period = (WOR_SL[9:0]+1) x (32/4096), (7.8ms ~ 7.99s).
;;;1119   	A7129_WritePageA(WOR1_PAGEA, 0x0005);		//WOR_SL[9:0]=5   : WOR Sleep  Period ~ 46.875ms 
000018  2105              MOVS     r1,#5
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       A7129_WritePageA
;;;1120   	A7129_WritePageB(ACKFIFO_PAGEB, 0x8000);	//WOR_AC[8:0]=256 : WOR Active Period ~ 7.84ms
000020  f44f4100          MOV      r1,#0x8000
000024  2006              MOVS     r0,#6
000026  f7fffffe          BL       A7129_WritePageB
;;;1121   	
;;;1122   	//WOR_HOLD : WOR hold RX setting when preamble/sync/carrier detected ok.
;;;1123   	//			[0]: No hold. [1]: Hold RX.
;;;1124   	//WOR_SEL: TWWS=1 setting. 
;;;1125   	//			[0]:RX valid packet.  [1]: preamble/sync/carrier  detected ok.
;;;1126   	//WOR_RST: TWWS=1 width setting. 
;;;1127   	//			[0]: pulse, reset by EOP. [1]: hold high, reset by strobe command.
;;;1128   	A7129_WritePageB(DSSS_PAGEB, A7129Config_PageB[DSSS_PAGEB] & ~0x0800);	//WOR_SEL=0
00002a  481c              LDR      r0,|L27.156|
00002c  89c0              LDRH     r0,[r0,#0xe]  ; A7129Config_PageB
00002e  f4206100          BIC      r1,r0,#0x800
000032  2007              MOVS     r0,#7
000034  f7fffffe          BL       A7129_WritePageB
;;;1129   	A7129_WritePageB(DSSS2_PAGEB, A7129Config_PageB[DSSS2_PAGEB] | 0x0003);	//WOR_HOLD=1, WOR_RST=1
000038  4818              LDR      r0,|L27.156|
00003a  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config_PageB
00003c  f0400103          ORR      r1,r0,#3
000040  200f              MOVS     r0,#0xf
000042  f7fffffe          BL       A7129_WritePageB
;;;1130   	
;;;1131   	A7129_WritePageA(WOR2_PAGEA, A7129Config_PageA[WOR2_PAGEA] | 0x0411);	//enable RC OSC & WOR by carrier
000046  4814              LDR      r0,|L27.152|
000048  8880              LDRH     r0,[r0,#4]  ; A7129Config_PageA
00004a  f2404211          MOV      r2,#0x411
00004e  ea400102          ORR      r1,r0,r2
000052  2002              MOVS     r0,#2
000054  f7fffffe          BL       A7129_WritePageA
;;;1132   	A7129_WritePageA(RFI_PAGEA, A7129Config_PageA[RFI_PAGEA] & ~0x6000);	//select CDSEL=[0x] : RSSI Carrier Detect
000058  480f              LDR      r0,|L27.152|
00005a  88c0              LDRH     r0,[r0,#6]  ; A7129Config_PageA
00005c  f42041c0          BIC      r1,r0,#0x6000
000060  2003              MOVS     r0,#3
000062  f7fffffe          BL       A7129_WritePageA
;;;1133   	A7129_WriteReg(ADC_REG, A7129Config[ADC_REG] | 0x8064);					//ARSSI=1, RTH=100
000066  480e              LDR      r0,|L27.160|
000068  8b00              LDRH     r0,[r0,#0x18]  ; A7129Config
00006a  f2480264          MOV      r2,#0x8064
00006e  ea400102          ORR      r1,r0,r2
000072  200c              MOVS     r0,#0xc
000074  f7fffffe          BL       A7129_WriteReg
;;;1134   
;;;1135   	A7129_WriteReg(MODE_REG, A7129Config[MODE_REG] | 0x0200);				//WORE=1 to enable WOR function
000078  4809              LDR      r0,|L27.160|
00007a  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config
00007c  f4407100          ORR      r1,r0,#0x200
000080  200f              MOVS     r0,#0xf
000082  f7fffffe          BL       A7129_WriteReg
;;;1136   	
;;;1137   	//CLF MOD 20161027 
;;;1138   	while(Read_GIO2()==0);		//GIO1=CD	: Stay in WOR mode until carrier signal strength is greater than the value set by RTH[7:0](carrier ok)
000086  bf00              NOP      
                  |L27.136|
000088  2140              MOVS     r1,#0x40
00008a  4806              LDR      r0,|L27.164|
00008c  f7fffffe          BL       GPIO_ReadInputDataBit
000090  2800              CMP      r0,#0
000092  d0f9              BEQ      |L27.136|
;;;1139   	//while(GIO1==0);		//GIO1=TWWS	: Stay in WOR mode until receiving valid packet. (WOR_SEL=0)	
;;;1140   }
000094  bd10              POP      {r4,pc}
;;;1141   
                          ENDP

000096  0000              DCW      0x0000
                  |L27.152|
                          DCD      A7129Config_PageA
                  |L27.156|
                          DCD      A7129Config_PageB
                  |L27.160|
                          DCD      A7129Config
                  |L27.164|
                          DCD      0x40010800

                          AREA ||i.WOR_enable_by_preamble||, CODE, READONLY, ALIGN=2

                  WOR_enable_by_preamble PROC
;;;1034   *********************************************************************/
;;;1035   void WOR_enable_by_preamble(void)
000000  b510              PUSH     {r4,lr}
;;;1036   {
;;;1037   	RCOSC_Cal();     	//RC Oscillator Calibration
000002  f7fffffe          BL       RCOSC_Cal
;;;1038   	
;;;1039   	A7129_WritePageA(GIO_PAGEA, (A7129Config_PageA[GIO_PAGEA] & 0xF000) | 0x004D);	//GIO1=PMDO, GIO2=WTR
000006  481b              LDR      r0,|L28.116|
000008  8a00              LDRH     r0,[r0,#0x10]  ; A7129Config_PageA
00000a  f4004070          AND      r0,r0,#0xf000
00000e  f040014d          ORR      r1,r0,#0x4d
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       A7129_WritePageA
;;;1040   	//A7159_WritePageA(GIO_PAGEA, (A7159Config_PageA[GIO_PAGEA] & 0xF000) | 0x0051);	//GIO1=TWWS, GIO2=WTR
;;;1041   
;;;1042   	//setup WOR Sleep time and Rx time
;;;1043   	//WOR Active Period = (WOR_AC[8:0]+1) x (1/32768), (30.5us ~ 15.6ms).
;;;1044   	//WOR Sleep  Period = (WOR_SL[9:0]+1) x (32/4096), (7.8ms ~ 7.99s).
;;;1045   	A7129_WritePageA(WOR1_PAGEA, 0x0005);		//WOR_SL[9:0]=5   : WOR Sleep  Period ~ 46.875ms 
000018  2105              MOVS     r1,#5
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       A7129_WritePageA
;;;1046   	A7129_WritePageB(ACKFIFO_PAGEB, 0x8000);	//WOR_AC[8:0]=256 : WOR Active Period ~ 7.84ms
000020  f44f4100          MOV      r1,#0x8000
000024  2006              MOVS     r0,#6
000026  f7fffffe          BL       A7129_WritePageB
;;;1047   	
;;;1048   	//WOR_HOLD : WOR hold RX setting when preamble/sync/carrier detected ok.
;;;1049   	//			[0]: No hold. [1]: Hold RX.
;;;1050   	//WOR_SEL: TWWS=1 setting. 
;;;1051   	//			[0]:RX valid packet.  [1]: preamble/sync/carrier  detected ok.
;;;1052   	//WOR_RST: TWWS=1 width setting. 
;;;1053   	//			[0]: pulse, reset by EOP. [1]: hold high, reset by strobe command.
;;;1054   	A7129_WritePageB(DSSS_PAGEB, A7129Config_PageB[DSSS_PAGEB] & ~0x0800);	//WOR_SEL=0
00002a  4813              LDR      r0,|L28.120|
00002c  89c0              LDRH     r0,[r0,#0xe]  ; A7129Config_PageB
00002e  f4206100          BIC      r1,r0,#0x800
000032  2007              MOVS     r0,#7
000034  f7fffffe          BL       A7129_WritePageB
;;;1055   	A7129_WritePageB(DSSS2_PAGEB, A7129Config_PageB[DSSS2_PAGEB] | 0x0003);	//WOR_HOLD=1, WOR_RST=1
000038  480f              LDR      r0,|L28.120|
00003a  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config_PageB
00003c  f0400103          ORR      r1,r0,#3
000040  200f              MOVS     r0,#0xf
000042  f7fffffe          BL       A7129_WritePageB
;;;1056   	
;;;1057   	A7129_WritePageA(WOR2_PAGEA, A7129Config_PageA[WOR2_PAGEA] | 0x0031);	//enable RC OSC & WOR by preamble
000046  480b              LDR      r0,|L28.116|
000048  8880              LDRH     r0,[r0,#4]  ; A7129Config_PageA
00004a  f0400131          ORR      r1,r0,#0x31
00004e  2002              MOVS     r0,#2
000050  f7fffffe          BL       A7129_WritePageA
;;;1058   	
;;;1059   	A7129_WriteReg(MODE_REG, A7129Config[MODE_REG] | 0x0200);				//WORE=1 to enable WOR function
000054  4809              LDR      r0,|L28.124|
000056  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config
000058  f4407100          ORR      r1,r0,#0x200
00005c  200f              MOVS     r0,#0xf
00005e  f7fffffe          BL       A7129_WriteReg
;;;1060   	
;;;1061   	//CLF MOD 20161027
;;;1062   	while(Read_GIO2()==0);		//GIO1=PMDO : Stay in WOR mode until receiving preamble(preamble ok)
000062  bf00              NOP      
                  |L28.100|
000064  2140              MOVS     r1,#0x40
000066  4806              LDR      r0,|L28.128|
000068  f7fffffe          BL       GPIO_ReadInputDataBit
00006c  2800              CMP      r0,#0
00006e  d0f9              BEQ      |L28.100|
;;;1063   	//while(GIO1==0);		//GIO1=TWWS	: Stay in WOR mode until receiving valid packet. (WOR_SEL=0)
;;;1064   }
000070  bd10              POP      {r4,pc}
;;;1065   
                          ENDP

000072  0000              DCW      0x0000
                  |L28.116|
                          DCD      A7129Config_PageA
                  |L28.120|
                          DCD      A7129Config_PageB
                  |L28.124|
                          DCD      A7129Config
                  |L28.128|
                          DCD      0x40010800

                          AREA ||i.WOR_enable_by_sync||, CODE, READONLY, ALIGN=2

                  WOR_enable_by_sync PROC
;;;1069   *********************************************************************/
;;;1070   void WOR_enable_by_sync(void)
000000  b510              PUSH     {r4,lr}
;;;1071   {
;;;1072   	RCOSC_Cal();     	//RC Oscillator Calibration
000002  f7fffffe          BL       RCOSC_Cal
;;;1073   	
;;;1074   	A7129_WritePageA(GIO_PAGEA, (A7129Config_PageA[GIO_PAGEA] & 0xF000) | 0x0045);	//GIO1=FSYNC, GIO2=WTR
000006  481b              LDR      r0,|L29.116|
000008  8a00              LDRH     r0,[r0,#0x10]  ; A7129Config_PageA
00000a  f4004070          AND      r0,r0,#0xf000
00000e  f0400145          ORR      r1,r0,#0x45
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       A7129_WritePageA
;;;1075   	//A7159_WritePageA(GIO_PAGEA, (A7159Config_PageA[GIO_PAGEA] & 0xF000) | 0x0051);	//GIO1=TWWS, GIO2=WTR
;;;1076   
;;;1077   	//setup WOR Sleep time and Rx time
;;;1078   	//WOR Active Period = (WOR_AC[8:0]+1) x (1/32768), (30.5us ~ 15.6ms).
;;;1079   	//WOR Sleep  Period = (WOR_SL[9:0]+1) x (32/4096), (7.8ms ~ 7.99s).
;;;1080   	A7129_WritePageA(WOR1_PAGEA, 0xFC05);		//WOR_SL[9:0]=5   : WOR Sleep  Period ~ 46.875ms 
000018  f64f4105          MOV      r1,#0xfc05
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       A7129_WritePageA
;;;1081   	A7129_WritePageB(ACKFIFO_PAGEB, 0xE000);	//WOR_AC[8:0]=256 : WOR Active Period ~ 7.84ms
000022  f44f4160          MOV      r1,#0xe000
000026  2006              MOVS     r0,#6
000028  f7fffffe          BL       A7129_WritePageB
;;;1082   	
;;;1083   	//WOR_HOLD : WOR hold RX setting when preamble/sync/carrier detected ok.
;;;1084   	//			[0]: No hold. [1]: Hold RX.
;;;1085   	//WOR_SEL: TWWS=1 setting. 
;;;1086   	//			[0]:RX valid packet.  [1]: preamble/sync/carrier  detected ok.
;;;1087   	//WOR_RST: TWWS=1 width setting. 
;;;1088   	//			[0]: pulse, reset by EOP. [1]: hold high, reset by strobe command.
;;;1089   	A7129_WritePageB(DSSS_PAGEB, A7129Config_PageB[DSSS_PAGEB] & ~0x0800);	//WOR_SEL=0
00002c  4812              LDR      r0,|L29.120|
00002e  89c0              LDRH     r0,[r0,#0xe]  ; A7129Config_PageB
000030  f4206100          BIC      r1,r0,#0x800
000034  2007              MOVS     r0,#7
000036  f7fffffe          BL       A7129_WritePageB
;;;1090   	A7129_WritePageB(DSSS2_PAGEB, A7129Config_PageB[DSSS2_PAGEB] | 0x0003);	//WOR_HOLD=1, WOR_RST=1
00003a  480f              LDR      r0,|L29.120|
00003c  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config_PageB
00003e  f0400103          ORR      r1,r0,#3
000042  200f              MOVS     r0,#0xf
000044  f7fffffe          BL       A7129_WritePageB
;;;1091   	
;;;1092   	A7129_WritePageA(WOR2_PAGEA, A7129Config_PageA[WOR2_PAGEA] | 0x0011);	//enable RC OSC & WOR by sync
000048  480a              LDR      r0,|L29.116|
00004a  8880              LDRH     r0,[r0,#4]  ; A7129Config_PageA
00004c  f0400111          ORR      r1,r0,#0x11
000050  2002              MOVS     r0,#2
000052  f7fffffe          BL       A7129_WritePageA
;;;1093   	
;;;1094   	A7129_WriteReg(MODE_REG, A7129Config[MODE_REG] | 0x0200);				//WORE=1 to enable WOR function
000056  4809              LDR      r0,|L29.124|
000058  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config
00005a  f4407100          ORR      r1,r0,#0x200
00005e  200f              MOVS     r0,#0xf
000060  f7fffffe          BL       A7129_WriteReg
;;;1095   	
;;;1096   //	while(GIO1==0);		//GIO1=FSYNC: Stay in WOR mode until receiving ID code(sync ok)
;;;1097   	My_NOP();
000064  f7fffffe          BL       My_NOP
;;;1098   	//while(GIO1==1);
;;;1099   //	RSSI_measurement();
;;;1100   	//RxPacket(xxyy);
;;;1101   	My_NOP();
000068  f7fffffe          BL       My_NOP
;;;1102   	My_NOP();
00006c  f7fffffe          BL       My_NOP
;;;1103   	//while(GIO1==0);		//GIO1=TWWS	: Stay in WOR mode until receiving valid packet. (WOR_SEL=0)
;;;1104   }
000070  bd10              POP      {r4,pc}
;;;1105   
                          ENDP

000072  0000              DCW      0x0000
                  |L29.116|
                          DCD      A7129Config_PageA
                  |L29.120|
                          DCD      A7129Config_PageB
                  |L29.124|
                          DCD      A7129Config

                          AREA ||i.WOT_enable||, CODE, READONLY, ALIGN=2

                  WOT_enable PROC
;;;1144   *********************************************************************/
;;;1145   void WOT_enable(void)
000000  f7fffffe          BL       RCOSC_Cal
;;;1146   {
;;;1147   	RCOSC_Cal();     		//RC Oscillator Calibration
;;;1148   	
;;;1149   	A7129_WritePageA(GIO_PAGEA, (A7129Config_PageA[GIO_PAGEA] & 0xF000) | 0x0045);	//GIO1=FSYNC, GIO2=WTR
000004  480e              LDR      r0,|L30.64|
000006  8a00              LDRH     r0,[r0,#0x10]  ; A7129Config_PageA
000008  f4004070          AND      r0,r0,#0xf000
00000c  f0400145          ORR      r1,r0,#0x45
000010  2008              MOVS     r0,#8
000012  f7fffffe          BL       A7129_WritePageA
;;;1150   
;;;1151   	//setup WOR Sleep time.
;;;1152   	//WOR Sleep  Period = (WOR_SL[9:0]+1) x (32/4096), (7.8ms ~ 7.99s).
;;;1153   	A7129_WritePageA(WOR1_PAGEA, 0x0005);		//WOR_SL[9:0]=5   : WOR Sleep  Period ~ 46.875ms 
000016  2105              MOVS     r1,#5
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       A7129_WritePageA
;;;1154   	
;;;1155   //	A7129_WriteFIFO();		//write data to TX FIFO
;;;1156   
;;;1157   	A7129_WriteReg(PIN_REG, A7129Config[PIN_REG] | 0x0400);		//WMODE=1 select WOT function
00001e  4809              LDR      r0,|L30.68|
000020  8b40              LDRH     r0,[r0,#0x1a]  ; A7129Config
000022  f4406180          ORR      r1,r0,#0x400
000026  200d              MOVS     r0,#0xd
000028  f7fffffe          BL       A7129_WriteReg
;;;1158   	
;;;1159   	A7129_WriteReg(MODE_REG, A7129Config[MODE_REG] | 0x0200);	//WORE=1 to enable WOT function
00002c  4805              LDR      r0,|L30.68|
00002e  8bc0              LDRH     r0,[r0,#0x1e]  ; A7129Config
000030  f4407100          ORR      r1,r0,#0x200
000034  200f              MOVS     r0,#0xf
000036  f7fffffe          BL       A7129_WriteReg
;;;1160   	
;;;1161   	while(1);
00003a  bf00              NOP      
                  |L30.60|
00003c  e7fe              B        |L30.60|
;;;1162   }	
;;;1163   //================================================================================
                          ENDP

00003e  0000              DCW      0x0000
                  |L30.64|
                          DCD      A7129Config_PageA
                  |L30.68|
                          DCD      A7129Config

                          AREA ||i.bsp_InitRF||, CODE, READONLY, ALIGN=2

                  bsp_InitRF PROC
;;;282    //初始化模块
;;;283    uint8_t bsp_InitRF(uint8_t st)
000000  b538              PUSH     {r3-r5,lr}
;;;284    {
000002  4604              MOV      r4,r0
;;;285    	
;;;286    	GPIO_InitTypeDef GPIO_InitStructure;
;;;287    	//initial pin
;;;288    	RCC_APB2PeriphClockCmd(RCC_ALL_A7139, ENABLE);
000004  2101              MOVS     r1,#1
000006  200c              MOVS     r0,#0xc
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;289    	
;;;290    	//==================================================================================
;;;291    	//TRIS_SCS=0;
;;;292    	//SCS = 1;
;;;293    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* ????? */
00000c  2010              MOVS     r0,#0x10
00000e  f88d0003          STRB     r0,[sp,#3]
;;;294    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO????? */	
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;295    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_SCS;
000018  2010              MOVS     r0,#0x10
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;296    	GPIO_Init(GPIO_PORT_SCS, &GPIO_InitStructure);		//????
00001e  4669              MOV      r1,sp
000020  4837              LDR      r0,|L31.256|
000022  f7fffffe          BL       GPIO_Init
;;;297    	GPIO_SetBits(GPIO_PORT_SCS,GPIO_PIN_SCS);
000026  2110              MOVS     r1,#0x10
000028  4835              LDR      r0,|L31.256|
00002a  f7fffffe          BL       GPIO_SetBits
;;;298    	 //=================================================================================
;;;299       //TRIS_SCK=0;
;;;300       //SCK = 0;
;;;301      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* ????? */
00002e  2010              MOVS     r0,#0x10
000030  f88d0003          STRB     r0,[sp,#3]
;;;302    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO????? */	
000034  2003              MOVS     r0,#3
000036  f88d0002          STRB     r0,[sp,#2]
;;;303    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_SCK;
00003a  2020              MOVS     r0,#0x20
00003c  f8ad0000          STRH     r0,[sp,#0]
;;;304    	GPIO_Init(GPIO_PORT_SCK, &GPIO_InitStructure);		//
000040  4669              MOV      r1,sp
000042  482f              LDR      r0,|L31.256|
000044  f7fffffe          BL       GPIO_Init
;;;305    	GPIO_ResetBits(GPIO_PORT_SCK,GPIO_PIN_SCK);
000048  2120              MOVS     r1,#0x20
00004a  482d              LDR      r0,|L31.256|
00004c  f7fffffe          BL       GPIO_ResetBits
;;;306    	//=================================================================================
;;;307      //TRIS_SDIO=0;
;;;308      //SDIO= 1;
;;;309      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* ????? */
000050  2010              MOVS     r0,#0x10
000052  f88d0003          STRB     r0,[sp,#3]
;;;310    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO????? */	
000056  2003              MOVS     r0,#3
000058  f88d0002          STRB     r0,[sp,#2]
;;;311    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_SDIO;
00005c  2080              MOVS     r0,#0x80
00005e  f8ad0000          STRH     r0,[sp,#0]
;;;312    	GPIO_Init(GPIO_PORT_SDIO, &GPIO_InitStructure);		//
000062  4669              MOV      r1,sp
000064  4826              LDR      r0,|L31.256|
000066  f7fffffe          BL       GPIO_Init
;;;313    	GPIO_SetBits(GPIO_PORT_SDIO,GPIO_PIN_SDIO);
00006a  2180              MOVS     r1,#0x80
00006c  4824              LDR      r0,|L31.256|
00006e  f7fffffe          BL       GPIO_SetBits
;;;314    	//=================================================================================
;;;315      //TRIS_CKO=0;
;;;316      //CKO	= 1;
;;;317    //  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	/* ????? */
;;;318    // 	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO????? */	
;;;319    // 	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_CKO;
;;;320    // 	GPIO_Init(GPIO_PORT_CKO, &GPIO_InitStructure);		//
;;;321    	//================================================================================
;;;322      //TRIS_GIO1=1;
;;;323      //GIO1= 1;
;;;324      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;	/* ????? */
000072  2048              MOVS     r0,#0x48
000074  f88d0003          STRB     r0,[sp,#3]
;;;325    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO????? */	
000078  2003              MOVS     r0,#3
00007a  f88d0002          STRB     r0,[sp,#2]
;;;326    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_GIO1;
00007e  2001              MOVS     r0,#1
000080  f8ad0000          STRH     r0,[sp,#0]
;;;327    	GPIO_Init(GPIO_PORT_GIO1, &GPIO_InitStructure);		//
000084  4669              MOV      r1,sp
000086  481f              LDR      r0,|L31.260|
000088  f7fffffe          BL       GPIO_Init
;;;328    	//=================================================================================
;;;329      //TRIS_GIO2=1;
;;;330      //GIO2= 1;
;;;331      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;	/* ????? */
00008c  2048              MOVS     r0,#0x48
00008e  f88d0003          STRB     r0,[sp,#3]
;;;332    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO????? */	
000092  2003              MOVS     r0,#3
000094  f88d0002          STRB     r0,[sp,#2]
;;;333    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_GIO2;
000098  2040              MOVS     r0,#0x40
00009a  f8ad0000          STRH     r0,[sp,#0]
;;;334    	GPIO_Init(GPIO_PORT_GIO2, &GPIO_InitStructure);		//
00009e  4669              MOV      r1,sp
0000a0  4817              LDR      r0,|L31.256|
0000a2  f7fffffe          BL       GPIO_Init
;;;335    	//=====================================================================================
;;;336    	Write_SDIO_HI();
0000a6  2180              MOVS     r1,#0x80
0000a8  4815              LDR      r0,|L31.256|
0000aa  f7fffffe          BL       GPIO_SetBits
;;;337    	Write_SCS_HI();
0000ae  2110              MOVS     r1,#0x10
0000b0  4813              LDR      r0,|L31.256|
0000b2  f7fffffe          BL       GPIO_SetBits
;;;338    	//=====================================================================================
;;;339    	//开始初始化
;;;340      init_err=0;									//初始化错误标记 //clf add 2016.1.14
0000b6  2000              MOVS     r0,#0
0000b8  4913              LDR      r1,|L31.264|
0000ba  7008              STRB     r0,[r1,#0]
;;;341    	
;;;342    	if(st!=0)
0000bc  b1e4              CBZ      r4,|L31.248|
;;;343    	{
;;;344    				A7139_Delay10us(80);	
0000be  2050              MOVS     r0,#0x50
0000c0  f7fffffe          BL       A7139_Delay10us
;;;345    				StrobeCMD(CMD_RF_RST);			//reset A7129 chip
0000c4  20ff              MOVS     r0,#0xff
0000c6  f7fffffe          BL       StrobeCMD
;;;346    				A7139_Delay10us(80);	
0000ca  2050              MOVS     r0,#0x50
0000cc  f7fffffe          BL       A7139_Delay10us
;;;347    				A7129_Config();							//config A7129 chip
0000d0  f7fffffe          BL       A7129_Config
;;;348    				A7139_Delay10us(80);				//delay 800us for crystal stabilized
0000d4  2050              MOVS     r0,#0x50
0000d6  f7fffffe          BL       A7139_Delay10us
;;;349    				A7129_WriteID();						//write ID code
0000da  f7fffffe          BL       A7129_WriteID
;;;350    				A7129_Cal();								//IF and VCO calibration
0000de  f7fffffe          BL       A7129_Cal
;;;351    				StrobeCMD(CMD_STBY);
0000e2  2014              MOVS     r0,#0x14
0000e4  f7fffffe          BL       StrobeCMD
;;;352    				StrobeCMD(CMD_RX);
0000e8  2018              MOVS     r0,#0x18
0000ea  f7fffffe          BL       StrobeCMD
;;;353    				A7139_Delay10us(1);
0000ee  2001              MOVS     r0,#1
0000f0  f7fffffe          BL       A7139_Delay10us
;;;354    
;;;355    				#ifdef USE_DSSS_MODE
;;;356    				DSSS_MODE();
0000f4  f7fffffe          BL       DSSS_MODE
                  |L31.248|
;;;357    				#endif
;;;358    	}  
;;;359      return init_err;                                 //clf add 2016.1.14
0000f8  4803              LDR      r0,|L31.264|
0000fa  7800              LDRB     r0,[r0,#0]  ; init_err
;;;360    }
0000fc  bd38              POP      {r3-r5,pc}
;;;361    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L31.256|
                          DCD      0x40010800
                  |L31.260|
                          DCD      0x40010c00
                  |L31.264|
                          DCD      init_err

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  ID_Tab
000000  d391d391          DCB      0xd3,0x91,0xd3,0x91
000004  c73345e7          DCB      0xc7,0x33,0x45,0xe7
                  RCOSC_TGNUM
000008  018b              DCW      0x018b
                  A7129Config
00000a  0021              DCW      0x0021
00000c  0a43da05          DCW      0x0a43,0xda05
000010  00001a20          DCW      0x0000,0x1a20
000014  00240000          DCW      0x0024,0x0000
000018  00150000          DCW      0x0015,0x0000
00001c  000018d4          DCW      0x0000,0x18d4
000020  70094000          DCW      0x7009,0x4000
000024  08004c45          DCW      0x0800,0x4c45
000028  20c0              DCW      0x20c0
                  A7129Config_PageA
00002a  f706              DCW      0xf706
00002c  0000f800          DCW      0x0000,0xf800
000030  11070170          DCW      0x1107,0x0170
000034  0402400f          DCW      0x0402,0x400f
000038  2ac00041          DCW      0x2ac0,0x0041
00003c  db810064          DCW      0xdb81,0x0064
000040  13430044          DCW      0x1343,0x0044
000044  00201507          DCW      0x0020,0x1507
000048  8000              DCW      0x8000
                  A7129Config_PageB
00004a  0307              DCW      0x0307
00004c  84000000          DCW      0x8400,0x0000
000050  00000000          DCW      0x0000,0x0000
000054  00000000          DCW      0x0000,0x0000
000058  00000000          DCW      0x0000,0x0000
00005c  00000000          DCW      0x0000,0x0000
000060  00000000          DCW      0x0000,0x0000
000064  00000000          DCW      0x0000,0x0000
000068  00000000          DCW      0x0000,0x0000
00006c  00000000          DCW      0x0000,0x0000
000070  00000000          DCW      0x0000,0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  init_err
000000  00                DCB      0x00
                  WaitForTime
000001  00                DCB      0x00
                  WaitFlag
000002  0000              DCB      0x00,0x00
                  RSSI
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_A7139.C"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_bsp_A7139_C_ID_Tab____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_A7139_C_ID_Tab____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_bsp_A7139_C_ID_Tab____REVSH|
#line 128
|__asm___11_bsp_A7139_C_ID_Tab____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
