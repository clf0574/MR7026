; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outupt\acalg.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\outupt\acalg.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\outupt\acalg.crf ..\..\User\AcAlg.c]
                          THUMB

                          AREA ||i.Ir_Decode||, CODE, READONLY, ALIGN=1

                  Ir_Decode PROC
;;;34     //参数4：输出波形数据
;;;35     uint8_t Ir_Decode(uint8_t *indat1,uint8_t *indat2,uint16_t *freq,uint16_t *outdat,uint16_t *outnum,uint8_t *repeat) 
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;36     //uint8_t Ir_Decode(void)
;;;37     {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;38     #if 0
;;;39     	uint16_t out[1024], retNum;//脉冲个数数组，元素个数
;;;40     	uint8_t frameCount = 1;
;;;41         	uint32_t pulse;
;;;42         	uint16_t i = 0;
;;;43     	uint16_t j = 0;
;;;44     	
;;;45     	#ifdef ARRAYTRANSMIT
;;;46     	//遥控器参数     每套遥控器是唯一的 所以只需传给设备一次
;;;47     	uint8_t params[] = {0x00,0x24,0x0E,0xD8,0x01,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x10,0x00,
;;;48     			  0x31,0x01,0x00,0x00,0x02,0x00,0x05,0x1E,0x09,0x00,0x00,0x10,0x03,0xCA,0x00,
;;;49     			  0x84,0x00,0x42,0x09,0x08,0x00,0x10,0x05,0x34,0x00,0x84,0x00,0x42,0x09,0x10,
;;;50     			  0x00,0x10,0x05,0x34,0x00,0x84,0x00,0x42,0x00};
;;;51     	//按键参数   每按键一次传送给设备
;;;52     	uint8_t bytes[] ={0x00,0x00,0x11,0xDA,0x27,0x00,0xC5,0x00,0x00,0xD7,0x11,0xDA,0x27,0x00,0x42,
;;;53     			0x00,0x00,0x54,0x11,0xDA,0x27,0x00,0x00,0x49,0x28,0x00,0xAF,0x00,0x00,0x06,
;;;54     			0x60,0x00,0x00,0xC1,0x80,0x00,0xD9}; 
;;;55     			
;;;56     	//根据收到的遥控参数，生成解码用的遥控器系列
;;;57     	create(params,sizeof(params));
;;;58     	//根据收到的按键参数，解码成红外具体发送的数组
;;;59     	enc(bytes, sizeof(bytes), out,(sizeof(out) / (sizeof(unsigned short))), &retNum, &frameCount);
;;;60     	#endif 
;;;61     #endif
;;;62     //=====================================================================================================
;;;63     //实际程序使用
;;;64     	create(indat1,sizeof(indat1));
000010  2104              MOVS     r1,#4
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       create
;;;65     	enc(indat2, sizeof(indat2), outdat,500, outnum ,repeat);
000018  f44f73fa          MOV      r3,#0x1f4
00001c  4632              MOV      r2,r6
00001e  2104              MOVS     r1,#4
000020  4620              MOV      r0,r4
000022  e9cd8900          STRD     r8,r9,[sp,#0]
000026  f7fffffe          BL       enc
;;;66       *freq=getFrequency();
00002a  f7fffffe          BL       getFrequency
00002e  8028              STRH     r0,[r5,#0]
;;;67     
;;;68     //===================================================================================================
;;;69     
;;;70     //#ifdef STRINGTRANSMIT//解析字符串
;;;71     //	//遥控器参数 
;;;72     //	UBYTE params[200]={0};//注意这个数组必须保留
;;;73     //	//按键参数
;;;74     //	UBYTE bytes[200]={0};//注意这个数组必须保留
;;;75     //	//遥控器参数 字符串，   每套遥控器是唯一的 所以只需传给设备一次
;;;76     //	UBYTE params_str[] = {"00240ED80100000000100010001000310100000200051E0900001003CA00840042090800100534008400420910001005340084004200"};
;;;77     //	//按键参数字符串，  每按键一次传送给设备
;;;78     //	UBYTE bytes_str[] ={"000011DA2700C50000D711DA27004200005411DA270000492800AF000006600000C18000D9"}; 
;;;79     //
;;;80     //	for(i=0;i<sizeof(params_str)-1;i++){
;;;81     //		if(params_str[i]>='A'){
;;;82     //		params[i]=params_str[i]-'7';
;;;83     //			}
;;;84     //		else {
;;;85     //			params[i]=params_str[i]-'0';
;;;86     //			}
;;;87     //	}
;;;88     //	for(i=0;i<(sizeof(params_str)-1)/2;i++){
;;;89     //			params[i]=(params[2*i]<<4)+params[2*i+1];
;;;90     //	}
;;;91     //	
;;;92     //	for(i=0;i<sizeof(bytes_str)-1;i++){
;;;93     //	if(bytes_str[i]>='A'){
;;;94     //		bytes[i]=bytes_str[i]-'7';
;;;95     //			}
;;;96     //		else {
;;;97     //			bytes[i]=bytes_str[i]-'0';
;;;98     //			}
;;;99     //	}
;;;100    //	for(i=0;i<(sizeof(bytes_str)-1)/2;i++){
;;;101    // 		bytes[i]=(bytes[2*i]<<4)+bytes[2*i+1];
;;;102    //	}
;;;103    //	create(params,(sizeof(params_str)-1)/2);
;;;104    //	if ((enc(bytes, (sizeof(bytes_str)-1)/2, out,(sizeof(out) / (sizeof(unsigned short))),		
;;;105    //		 &retNum, &frameCount))!=0){
;;;106    //		 printf("enc error\n");
;;;107    //
;;;108    //		 	return 0;
;;;109    //		}
;;;110    //#endif 	
;;;111    //=================================================================================================
;;;112    #if 0
;;;113    
;;;114    	//printf("retNum=%d\n", retNum);
;;;115    	//printf("getFrequency=%d\n", getFrequency());//频率
;;;116    	//printf("frameCount=%d\n", frameCount);
;;;117    	
;;;118    	
;;;119    	//一帧的数据通过out数组返回，单位为(1000000 /频率)，重复的帧数通过frameCount返回，如果要得到完整的高低电平时间序列(单位us)使用下面代码。
;;;120    	pulse = (double) 1000000 / getFrequency();
;;;121    	
;;;122    	
;;;123    	//for(i = 0;i < frameCount;i++){//重复发送
;;;124    	//	for (j = 0; j < retNum; j++) {
;;;125    	//	printf("%02X,", (int) (out[j]));//得到out数组
;;;126    	//	}
;;;127    	//}
;;;128    	
;;;129    	//printf("\n");
;;;130    	//printf("\n");
;;;131    	
;;;132    	for(i = 0;i < frameCount;i++){//重复发送
;;;133    		for (j = 0; j < retNum; j++) {
;;;134    		printf("%d,", (int) (out[j] * pulse));//得到时间序列单位us
;;;135    		}
;;;136    
;;;137    	}
;;;138    #endif
;;;139    
;;;140    //==================================================================================================
;;;141    	//printf("\n");
;;;142    //	#ifdef _DEBUG
;;;143    //	_CrtDumpMemoryLeaks();
;;;144    //	#endif
;;;145    //===================================================================================================
;;;146    	return 0;
000030  2000              MOVS     r0,#0
;;;147    }
000032  e8bd87fc          POP      {r2-r10,pc}
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\AcAlg.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_AcAlg_c_3c9af182____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_AcAlg_c_3c9af182____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_AcAlg_c_3c9af182____REVSH|
#line 128
|__asm___7_AcAlg_c_3c9af182____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
