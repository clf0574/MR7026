; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outupt\bsp_cc1101.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\outupt\bsp_cc1101.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\outupt\bsp_cc1101.crf ..\..\User\bsp\src\bsp_CC1101.c]
                          THUMB

                          AREA ||i.CC1100WakeUp||, CODE, READONLY, ALIGN=1

                  CC1100WakeUp PROC
;;;780    //**************************************************************************************** 
;;;781    void CC1100WakeUp(void) 
000000  4770              BX       lr
;;;782    { 
;;;783    //	unsigned int n,m;
;;;784    //	
;;;785    //	//TRISC2 = 0;
;;;786    //	TRISCbits.TRISC2 = 0;
;;;787    //	CCS = 1; 	 
;;;788    //	for(n=0;n<10;n++); 
;;;789    //	CCS = 0; 
;;;790    //	//for(n=0;n<30;n++) 
;;;791    //	for(m=0;m<1000;m++); 
;;;792    //	CCS = 1; 
;;;793    //	for(n=0;n<10;n++);
;;;794    	
;;;795    } 
;;;796    /*
                          ENDP


                          AREA ||i.Delay2us||, CODE, READONLY, ALIGN=1

                  Delay2us PROC
;;;914    //========================================================================================
;;;915    void Delay2us(void)
000000  2164              MOVS     r1,#0x64
;;;916    {
;;;917    		uint8_t i,j;
;;;918    	  j=100;
;;;919    	  while(j>0)
000002  e007              B        |L2.20|
                  |L2.4|
;;;920    		{
;;;921    				j--;
000004  1e4a              SUBS     r2,r1,#1
000006  b2d1              UXTB     r1,r2
;;;922    			  for(i=0;i<50;i++);
000008  2000              MOVS     r0,#0
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  1c42              ADDS     r2,r0,#1
00000e  b2d0              UXTB     r0,r2
                  |L2.16|
000010  2832              CMP      r0,#0x32
000012  dbfb              BLT      |L2.12|
                  |L2.20|
000014  2900              CMP      r1,#0                 ;919
000016  dcf5              BGT      |L2.4|
;;;923    		}
;;;924    }
000018  4770              BX       lr
;;;925    //=========================================================================================
                          ENDP


                          AREA ||i.Delayx10us||, CODE, READONLY, ALIGN=1

                  Delayx10us PROC
;;;926    //
;;;927    void Delayx10us(uint8_t n)
000000  e00d              B        |L3.30|
                  |L3.2|
;;;928    {
;;;929    		uint8_t i,j;
;;;930    	  while(n>0)
;;;931    		{
;;;932    			  n--;
000002  1e43              SUBS     r3,r0,#1
000004  b2d8              UXTB     r0,r3
;;;933    				j=100;
000006  2264              MOVS     r2,#0x64
;;;934    				while(j>0)
000008  e007              B        |L3.26|
                  |L3.10|
;;;935    				{
;;;936    						j--;
00000a  1e53              SUBS     r3,r2,#1
00000c  b2da              UXTB     r2,r3
;;;937    						for(i=0;i<100;i++);
00000e  2100              MOVS     r1,#0
000010  e001              B        |L3.22|
                  |L3.18|
000012  1c4b              ADDS     r3,r1,#1
000014  b2d9              UXTB     r1,r3
                  |L3.22|
000016  2964              CMP      r1,#0x64
000018  dbfb              BLT      |L3.18|
                  |L3.26|
00001a  2a00              CMP      r2,#0                 ;934
00001c  dcf5              BGT      |L3.10|
                  |L3.30|
00001e  2800              CMP      r0,#0                 ;930
000020  dcef              BGT      |L3.2|
;;;938    				}
;;;939    	  }
;;;940    }
000022  4770              BX       lr
;;;941    
                          ENDP


                          AREA ||i.InitSPI||, CODE, READONLY, ALIGN=2

                  InitSPI PROC
;;;868    
;;;869    void InitSPI(void)
000000  b510              PUSH     {r4,lr}
;;;870    {
;;;871    //	TRIS_CGDO0 = 1; // 输入GDO0 			
;;;872    //   	TRIS_CCS = 0; // CSN 输出 
;;;873    //  	CCS 	= 1;  	
;;;874    //   	TRIS_CSCLK = 0; // SCLK输出
;;;875    //   	CSCLK 	= 0;     		   	
;;;876    //	TRIS_CMISO = 1; // 输入
;;;877    //	CMISO	= 0;  
;;;878    //   	TRIS_CMOSI= 0; // 输出   	   
;;;879    //	CMOSI	= 0;
;;;880     //====================================
;;;881    	//GDO0
;;;882    	RCC_APB2PeriphClockCmd(RCC_GDO0, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;883      	GPIO_InitStructure.GPIO_Pin = GPIO_GDO0_PIN; 
00000a  2001              MOVS     r0,#1
00000c  4920              LDR      r1,|L4.144|
00000e  8008              STRH     r0,[r1,#0]
;;;884      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000010  2004              MOVS     r0,#4
000012  70c8              STRB     r0,[r1,#3]
;;;885      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
000014  2003              MOVS     r0,#3
000016  7088              STRB     r0,[r1,#2]
;;;886      	GPIO_Init(GPIO_GDO0_PORT, &GPIO_InitStructure);
000018  481e              LDR      r0,|L4.148|
00001a  f7fffffe          BL       GPIO_Init
;;;887    	//CCS
;;;888    	RCC_APB2PeriphClockCmd(RCC_CCS, ENABLE); 
00001e  2101              MOVS     r1,#1
000020  2004              MOVS     r0,#4
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;889      	GPIO_InitStructure.GPIO_Pin = GPIO_CCS_PIN; 
000026  2010              MOVS     r0,#0x10
000028  4919              LDR      r1,|L4.144|
00002a  8008              STRH     r0,[r1,#0]
;;;890      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00002c  70c8              STRB     r0,[r1,#3]
;;;891      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
00002e  2003              MOVS     r0,#3
000030  7088              STRB     r0,[r1,#2]
;;;892      	GPIO_Init(GPIO_CCS_PORT, &GPIO_InitStructure); 
000032  4819              LDR      r0,|L4.152|
000034  f7fffffe          BL       GPIO_Init
;;;893    	//CSCLK
;;;894    	RCC_APB2PeriphClockCmd(RCC_CSCLK, ENABLE); 
000038  2101              MOVS     r1,#1
00003a  2004              MOVS     r0,#4
00003c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;895      	GPIO_InitStructure.GPIO_Pin = GPIO_CSCLK_PIN; 
000040  2020              MOVS     r0,#0x20
000042  4913              LDR      r1,|L4.144|
000044  8008              STRH     r0,[r1,#0]
;;;896      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000046  2010              MOVS     r0,#0x10
000048  70c8              STRB     r0,[r1,#3]
;;;897      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
00004a  2003              MOVS     r0,#3
00004c  7088              STRB     r0,[r1,#2]
;;;898      	GPIO_Init(GPIO_CSCLK_PORT, &GPIO_InitStructure); 
00004e  4812              LDR      r0,|L4.152|
000050  f7fffffe          BL       GPIO_Init
;;;899    	//CMISO
;;;900    	 RCC_APB2PeriphClockCmd(RCC_CMISO, ENABLE); 
000054  2101              MOVS     r1,#1
000056  2004              MOVS     r0,#4
000058  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;901      	GPIO_InitStructure.GPIO_Pin = GPIO_CMISO_PIN; 
00005c  2080              MOVS     r0,#0x80
00005e  490c              LDR      r1,|L4.144|
000060  8008              STRH     r0,[r1,#0]
;;;902      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000062  2004              MOVS     r0,#4
000064  70c8              STRB     r0,[r1,#3]
;;;903      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
000066  2003              MOVS     r0,#3
000068  7088              STRB     r0,[r1,#2]
;;;904      	GPIO_Init(GPIO_CMISO_PORT, &GPIO_InitStructure);
00006a  480b              LDR      r0,|L4.152|
00006c  f7fffffe          BL       GPIO_Init
;;;905    	//CMOSI
;;;906        RCC_APB2PeriphClockCmd(RCC_CMOSI, ENABLE); 
000070  2101              MOVS     r1,#1
000072  2004              MOVS     r0,#4
000074  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;907      	GPIO_InitStructure.GPIO_Pin = GPIO_CMOSI_PIN; 
000078  2040              MOVS     r0,#0x40
00007a  4905              LDR      r1,|L4.144|
00007c  8008              STRH     r0,[r1,#0]
;;;908      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00007e  2010              MOVS     r0,#0x10
000080  70c8              STRB     r0,[r1,#3]
;;;909      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
000082  2003              MOVS     r0,#3
000084  7088              STRB     r0,[r1,#2]
;;;910      	GPIO_Init(GPIO_CMOSI_PORT, &GPIO_InitStructure); 
000086  4804              LDR      r0,|L4.152|
000088  f7fffffe          BL       GPIO_Init
;;;911    		
;;;912    }
00008c  bd10              POP      {r4,pc}
;;;913    
                          ENDP

00008e  0000              DCW      0x0000
                  |L4.144|
                          DCD      GPIO_InitStructure
                  |L4.148|
                          DCD      0x40010c00
                  |L4.152|
                          DCD      0x40010800

                          AREA ||i.InitWorMode||, CODE, READONLY, ALIGN=1

                  InitWorMode PROC
;;;827    */
;;;828    void InitWorMode(void)
000000  b510              PUSH     {r4,lr}
;;;829    {
;;;830    	
;;;831      SPIWriteReg(CCxxx0_RCCTRL1,  0x41);        // RC oscillator configuration
000002  2141              MOVS     r1,#0x41
000004  2027              MOVS     r0,#0x27
000006  f7fffffe          BL       SPIWriteReg
;;;832    	
;;;833      // Enable automatic initial calibration of RCosc.
;;;834      // Set T_event1 ~ 1.4 ms, enough for XOSC stabilize and FS calibration before RX.
;;;835      // Enable RC oscillator before starting with WOR (or else it will not wake up).
;;;836      //SPIWriteReg(CCxxx0_WORCTRL, 0x78);           // Not using AUTO_SYNC function.
;;;837      SPIWriteReg(CCxxx0_WORCTRL, 0x38);//关 WOR = 0XB8
00000a  2138              MOVS     r1,#0x38
00000c  2020              MOVS     r0,#0x20
00000e  f7fffffe          BL       SPIWriteReg
;;;838      // Set Event0 timeout = 1 s (RX polling interval)
;;;839      // WOR_RES = 0
;;;840      // T_event0 = 750 / f_xosc * EVENT0 * 2^(5*WOR_RES) = 1 s,f_xosc = 27 MHz
;;;841      // =>  EVENT0 = 0x8CA0
;;;842      //SPIWriteReg(CCxxx0_WOREVT1, 0x8C);                // High byte Event0 timeout
;;;843      //SPIWriteReg(CCxxx0_WOREVT0, 0xA0);                // Low byte Event0 timeout.
;;;844      SPIWriteReg(CCxxx0_WOREVT1, 0x3C);                // High byte Event0 timeout
000012  213c              MOVS     r1,#0x3c
000014  201e              MOVS     r0,#0x1e
000016  f7fffffe          BL       SPIWriteReg
;;;845      SPIWriteReg(CCxxx0_WOREVT0, 0xCC);   
00001a  21cc              MOVS     r1,#0xcc
00001c  201f              MOVS     r0,#0x1f
00001e  f7fffffe          BL       SPIWriteReg
;;;846       
;;;847      //SPIWriteReg(CCxxx0_WOREVT1, 0x06);                // High byte Event0 timeout
;;;848      //SPIWriteReg(CCxxx0_WOREVT0, 0xC5);   //TEVENT0=49.9MS,RX6.25MS
;;;849      //SPIWriteReg(CCxxx0_WOREVT1, 0xad);  //  
;;;850      //SPIWriteReg(CCxxx0_WOREVT0, 0x56);  //
;;;851      
;;;852      // Setting Rx_timeout =2.596 ms.
;;;853      // MCSM2.RX_TIME = 000b
;;;854      // => Rx_timeout = EVENT0*C(RX_TIME, WOR_RES)
;;;855      SPIWriteReg(CCxxx0_MCSM2, 0x00);
000022  2100              MOVS     r1,#0
000024  2016              MOVS     r0,#0x16
000026  f7fffffe          BL       SPIWriteReg
;;;856      SPIWriteReg(CCxxx0_MCSM1,0x30); //设置读取包后进入IDLE态 
00002a  2130              MOVS     r1,#0x30
00002c  2017              MOVS     r0,#0x17
00002e  f7fffffe          BL       SPIWriteReg
;;;857      // Enable automatic FS calibration when going from IDLE to RX/TX/FSTXON (in between EVENT0 and EVENT1)
;;;858      SPIWriteReg(CCxxx0_MCSM0, 0x18);
000032  2118              MOVS     r1,#0x18
000034  4608              MOV      r0,r1
000036  f7fffffe          BL       SPIWriteReg
;;;859      
;;;860      SPIStrobe(CCxxx0_SIDLE);
00003a  2036              MOVS     r0,#0x36
00003c  f7fffffe          BL       SPIStrobe
;;;861      SPIStrobe(CCxxx0_SWORRST);
000040  203c              MOVS     r0,#0x3c
000042  f7fffffe          BL       SPIStrobe
;;;862      SPIStrobe(CCxxx0_SWOR);  
000046  2038              MOVS     r0,#0x38
000048  f7fffffe          BL       SPIStrobe
;;;863    }
00004c  bd10              POP      {r4,pc}
;;;864    
                          ENDP


                          AREA ||i.PowerUpResetCC1100||, CODE, READONLY, ALIGN=2

                  PowerUpResetCC1100 PROC
;;;220    //时序见CC1100英文版43页
;;;221    void PowerUpResetCC1100(void) 
000000  b510              PUSH     {r4,lr}
;;;222    {
;;;223    	//CSCLK = 1;		//to avoid potential problems 
;;;224    	GPIO_SetBits(GPIO_CSCLK_PORT,GPIO_CSCLK_PIN);
000002  2120              MOVS     r1,#0x20
000004  480f              LDR      r0,|L6.68|
000006  f7fffffe          BL       GPIO_SetBits
;;;225    						
;;;226    	//CMISO = 0;		//with pin control mode
;;;227        GPIO_ResetBits(GPIO_CMISO_PORT,GPIO_CMISO_PIN);
00000a  2180              MOVS     r1,#0x80
00000c  480d              LDR      r0,|L6.68|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;228    
;;;229    	//CCS = 1; 
;;;230    	GPIO_SetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
000012  2110              MOVS     r1,#0x10
000014  480b              LDR      r0,|L6.68|
000016  f7fffffe          BL       GPIO_SetBits
;;;231    
;;;232    	//Delay2us();
;;;233    	Delayx10us(1);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       Delayx10us
;;;234    	 
;;;235    	//CCS = 0; 
;;;236    	 GPIO_ResetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
000020  2110              MOVS     r1,#0x10
000022  4808              LDR      r0,|L6.68|
000024  f7fffffe          BL       GPIO_ResetBits
;;;237    
;;;238    	//Delay2us();
;;;239    	Delayx10us(1);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       Delayx10us
;;;240    
;;;241    	//CCS = 1;
;;;242    	GPIO_SetBits(GPIO_CCS_PORT,GPIO_CCS_PIN); 
00002e  2110              MOVS     r1,#0x10
000030  4804              LDR      r0,|L6.68|
000032  f7fffffe          BL       GPIO_SetBits
;;;243    
;;;244    	Delayx10us(5);	//Hold CSn high for at least 40μs  
000036  2005              MOVS     r0,#5
000038  f7fffffe          BL       Delayx10us
;;;245    					//relative to pulling CSn low 
;;;246    	ResetCC1100();  //复位CC1100
00003c  f7fffffe          BL       ResetCC1100
;;;247    }
000040  bd10              POP      {r4,pc}
;;;248    
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      0x40010800

                          AREA ||i.ResetCC1100||, CODE, READONLY, ALIGN=2

                  ResetCC1100 PROC
;;;185    //**************************************************
;;;186    void ResetCC1100(void)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188        unsigned int i=0;
000002  2400              MOVS     r4,#0
;;;189    
;;;190    	//CCS = 0;      // CSn 脚 （芯片选择，低电平有效）
;;;191    	GPIO_ResetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
000004  2110              MOVS     r1,#0x10
000006  4814              LDR      r0,|L7.88|
000008  f7fffffe          BL       GPIO_ResetBits
;;;192    					
;;;193    	//while(CMISO)//当 CSn 变低， 在开始转换头字节之前，
;;;194    	while(GPIO_ReadInputDataBit(GPIO_CMISO_PORT,GPIO_CMISO_PIN))
00000c  e005              B        |L7.26|
                  |L7.14|
;;;195    	{
;;;196    		i++;
00000e  1c64              ADDS     r4,r4,#1
;;;197    		if(i>20000)
000010  f6446020          MOV      r0,#0x4e20
000014  4284              CMP      r4,r0
000016  d900              BLS      |L7.26|
;;;198    		  break;
000018  e005              B        |L7.38|
                  |L7.26|
00001a  2180              MOVS     r1,#0x80              ;194
00001c  480e              LDR      r0,|L7.88|
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
000022  2800              CMP      r0,#0                 ;194
000024  d1f3              BNE      |L7.14|
                  |L7.38|
000026  bf00              NOP      
;;;199    	}
;;;200    			      //MCU必须等待，直到 SO脚变低			
;;;201        SPITxRxByte(CCxxx0_SRES); 	//写入复位命令
000028  2030              MOVS     r0,#0x30
00002a  f7fffffe          BL       SPITxRxByte
;;;202    	i=0;
00002e  2400              MOVS     r4,#0
;;;203    	//while(CMISO)
;;;204    	while(GPIO_ReadInputDataBit(GPIO_CMISO_PORT,GPIO_CMISO_PIN))
000030  e005              B        |L7.62|
                  |L7.50|
;;;205    	{
;;;206    		i++;
000032  1c64              ADDS     r4,r4,#1
;;;207    		if(i>20000)
000034  f6446020          MOV      r0,#0x4e20
000038  4284              CMP      r4,r0
00003a  d900              BLS      |L7.62|
;;;208    		  break;
00003c  e005              B        |L7.74|
                  |L7.62|
00003e  2180              MOVS     r1,#0x80              ;204
000040  4805              LDR      r0,|L7.88|
000042  f7fffffe          BL       GPIO_ReadInputDataBit
000046  2800              CMP      r0,#0                 ;204
000048  d1f3              BNE      |L7.50|
                  |L7.74|
00004a  bf00              NOP      
;;;209    	}
;;;210    	 
;;;211        //CCS = 1; 	//转换结束	
;;;212    	GPIO_SetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
00004c  2110              MOVS     r1,#0x10
00004e  4802              LDR      r0,|L7.88|
000050  f7fffffe          BL       GPIO_SetBits
;;;213    }
000054  bd10              POP      {r4,pc}
;;;214    //************************************************
                          ENDP

000056  0000              DCW      0x0000
                  |L7.88|
                          DCD      0x40010800

                          AREA ||i.RfReceivePacket||, CODE, READONLY, ALIGN=2

                  RfReceivePacket PROC
;;;646    
;;;647    unsigned char RfReceivePacket(unsigned char *rxBuffer,unsigned char *len)
000000  b5f8              PUSH     {r3-r7,lr}
;;;648    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;649    	  unsigned char status[2];
;;;650        unsigned char packetLength;
;;;651    	
;;;652    	  static uint8_t flag_recv=0;
;;;653    	
;;;654    //	  unsigned char i;  // 具体多少要根据datarate和length来决定
;;;655    //	  i=MIN_LENGTH*4;
;;;656    	  //while (CGDO0)
;;;657    // 	  while(1==GPIO_ReadInputDataBit(GPIO_GDO0_PORT,GPIO_GDO0_PIN))
;;;658    // 		{
;;;659    // 			Delayx10us(200);
;;;660    // 			--i;
;;;661    // 			if(i<1)return 0;	    
;;;662    // 		}	
;;;663    	
;;;664    	
;;;665    	
;;;666    //	  //===================================================================
;;;667    	  if(1==GPIO_ReadInputDataBit(GPIO_GDO0_PORT,GPIO_GDO0_PIN))
000006  2101              MOVS     r1,#1
000008  481e              LDR      r0,|L8.132|
00000a  f7fffffe          BL       GPIO_ReadInputDataBit
00000e  2801              CMP      r0,#1
000010  d106              BNE      |L8.32|
;;;668    		{
;;;669    			 flag_recv++;
000012  481d              LDR      r0,|L8.136|
000014  7800              LDRB     r0,[r0,#0]  ; flag_recv
000016  1c40              ADDS     r0,r0,#1
000018  491b              LDR      r1,|L8.136|
00001a  7008              STRB     r0,[r1,#0]
;;;670    			 return 2;
00001c  2002              MOVS     r0,#2
                  |L8.30|
;;;671    			 //if(flag_recv<5)return 2;		 
;;;672    		}
;;;673    		else
;;;674    	  {
;;;675    			 if(flag_recv==0)return 0;
;;;676    		}
;;;677    		flag_recv=0;
;;;678    //	  //====================================================================
;;;679    		
;;;680    		
;;;681        if((SPIReadStatus(CCxxx0_RXBYTES) & BYTES_IN_RXFIFO)) // 如果接的字节数不为0
;;;682    		{
;;;683            packetLength = SPIReadReg(CCxxx0_RXFIFO);		// 读出第一个字节，此字节为该帧数据长度
;;;684            if(packetLength >= MIN_LENGTH) 					// 如果所要的有效数据长度小于等于接收到的数据包的长度
;;;685    				{			
;;;686    						//if(packetLength == MIN_LENGTH)length = MIN_LENGTH;	// 标准帧	
;;;687    					
;;;688                SPIReadBurstReg(CCxxx0_RXFIFO, rxBuffer,MIN_LENGTH); 	 // 读出所有接收到的数据
;;;689    			
;;;690                //SPIReadBurstReg(CCxxx0_RXFIFO, RxBuf[RxCnt],MIN_LENGTH);
;;;691    
;;;692    					  *len=packetLength;
;;;693    			      //*length = packetLength;														// 把接收数据长度的修改为当前数据的长度
;;;694                // Read the 2 appended status bytes (status[0] = RSSI, status[1] = LQI)
;;;695    					
;;;696                SPIReadBurstReg(CCxxx0_RXFIFO, status, 2); 					// 读出CRC校验位
;;;697    						SPIStrobe(CCxxx0_SFRX);															// 清洗接收缓冲区
;;;698    						SPIStrobe(CCxxx0_SIDLE);														// add
;;;699    						SPIStrobe(CCxxx0_SRX);															// 进入接收状态
;;;700    			       //return (status[1] & CRC_OK);											// 如果校验成功返回接收成功
;;;701            		//return (CRC_OK);
;;;702    					  return 1;
;;;703            }
;;;704    		else 
;;;705    		{
;;;706                //*length = packetLength;
;;;707                SPIStrobe(CCxxx0_SFRX);															//清洗接收缓冲区
;;;708                //SPIStrobe(CCxxx0_SRX);														//进入接收状态
;;;709                //SPIStrobe(CCxxx0_SIDLE);													//add
;;;710                return 0;
;;;711            }
;;;712        } 
;;;713    		else
;;;714    		{
;;;715    		//SPIStrobe(CCxxx0_SIDLE);//add
;;;716    	 		return 0;
;;;717     		}	
;;;718    }
00001e  bdf8              POP      {r3-r7,pc}
                  |L8.32|
000020  4819              LDR      r0,|L8.136|
000022  7800              LDRB     r0,[r0,#0]            ;675  ; flag_recv
000024  b908              CBNZ     r0,|L8.42|
000026  2000              MOVS     r0,#0                 ;675
000028  e7f9              B        |L8.30|
                  |L8.42|
00002a  2000              MOVS     r0,#0                 ;677
00002c  4916              LDR      r1,|L8.136|
00002e  7008              STRB     r0,[r1,#0]            ;677
000030  203b              MOVS     r0,#0x3b              ;681
000032  f7fffffe          BL       SPIReadStatus
000036  f0100f7f          TST      r0,#0x7f              ;681
00003a  d020              BEQ      |L8.126|
00003c  203f              MOVS     r0,#0x3f              ;683
00003e  f7fffffe          BL       SPIReadReg
000042  4604              MOV      r4,r0                 ;683
000044  2c10              CMP      r4,#0x10              ;684
000046  db15              BLT      |L8.116|
000048  2210              MOVS     r2,#0x10              ;688
00004a  4629              MOV      r1,r5                 ;688
00004c  203f              MOVS     r0,#0x3f              ;688
00004e  f7fffffe          BL       SPIReadBurstReg
000052  7034              STRB     r4,[r6,#0]            ;692
000054  2202              MOVS     r2,#2                 ;696
000056  4669              MOV      r1,sp                 ;696
000058  203f              MOVS     r0,#0x3f              ;696
00005a  f7fffffe          BL       SPIReadBurstReg
00005e  203a              MOVS     r0,#0x3a              ;697
000060  f7fffffe          BL       SPIStrobe
000064  2036              MOVS     r0,#0x36              ;698
000066  f7fffffe          BL       SPIStrobe
00006a  2034              MOVS     r0,#0x34              ;699
00006c  f7fffffe          BL       SPIStrobe
000070  2001              MOVS     r0,#1                 ;702
000072  e7d4              B        |L8.30|
                  |L8.116|
000074  203a              MOVS     r0,#0x3a              ;707
000076  f7fffffe          BL       SPIStrobe
00007a  2000              MOVS     r0,#0                 ;710
00007c  e7cf              B        |L8.30|
                  |L8.126|
00007e  2000              MOVS     r0,#0                 ;716
000080  e7cd              B        |L8.30|
;;;719    
                          ENDP

000082  0000              DCW      0x0000
                  |L8.132|
                          DCD      0x40010c00
                  |L8.136|
                          DCD      flag_recv

                          AREA ||i.RfSendPacket||, CODE, READONLY, ALIGN=2

                  RfSendPacket PROC
;;;555    //*****************************************************************************************
;;;556    void RfSendPacket(INT8U *txBuffer, INT8U size) 
000000  b570              PUSH     {r4-r6,lr}
;;;557    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;558    unsigned int i=0;
000006  2600              MOVS     r6,#0
;;;559    	//SPIStrobe(CCxxx0_SRX);	// 进入接收状态(CCA)	ADD
;;;560    	SPIWriteReg(CCxxx0_TXFIFO, size);
000008  4629              MOV      r1,r5
00000a  203f              MOVS     r0,#0x3f
00000c  f7fffffe          BL       SPIWriteReg
;;;561        SPIWriteBurstReg(CCxxx0_TXFIFO, txBuffer, size);	//写入要发送的数据
000010  462a              MOV      r2,r5
000012  4621              MOV      r1,r4
000014  203f              MOVS     r0,#0x3f
000016  f7fffffe          BL       SPIWriteBurstReg
;;;562    
;;;563     	SPIStrobe(CCxxx0_SIDLE);	//进入之前进入空闲,SUB
00001a  2036              MOVS     r0,#0x36
00001c  f7fffffe          BL       SPIStrobe
;;;564        SPIStrobe(CCxxx0_STX);		//进入发送模式发送数据
000020  2035              MOVS     r0,#0x35
000022  f7fffffe          BL       SPIStrobe
;;;565    
;;;566        // Wait for GDO0 to be set -> sync transmitted
;;;567    	// Delayx10ms(10);
;;;568    	i=0;
000026  bf00              NOP      
;;;569    	//while (!CGDO0)
;;;570    	//while(0==GPIO_ReadInputDataBit(GPIO_GDO0_PORT,GPIO_GDO0_PIN))
;;;571        while(!GPIO_ReadInputDataBit(GPIO_GDO0_PORT,GPIO_GDO0_PIN))
000028  e008              B        |L9.60|
                  |L9.42|
;;;572    	{
;;;573    	    Delay2us();
00002a  f7fffffe          BL       Delay2us
;;;574    		if(i++>50000)break;
00002e  4630              MOV      r0,r6
000030  1c76              ADDS     r6,r6,#1
000032  f24c3150          MOV      r1,#0xc350
000036  4288              CMP      r0,r1
000038  d900              BLS      |L9.60|
00003a  e005              B        |L9.72|
                  |L9.60|
00003c  2101              MOVS     r1,#1                 ;571
00003e  480e              LDR      r0,|L9.120|
000040  f7fffffe          BL       GPIO_ReadInputDataBit
000044  2800              CMP      r0,#0                 ;571
000046  d0f0              BEQ      |L9.42|
                  |L9.72|
000048  bf00              NOP      
;;;575    	}
;;;576        // Wait for GDO0 to be cleared -> end of packet
;;;577    	i=0;
00004a  2600              MOVS     r6,#0
;;;578     	//while (CGDO0)
;;;579    	//while(0!=GPIO_ReadInputDataBit(GPIO_GDO0_PORT,GPIO_GDO0_PIN))
;;;580        while(GPIO_ReadInputDataBit(GPIO_GDO0_PORT,GPIO_GDO0_PIN))
00004c  e008              B        |L9.96|
                  |L9.78|
;;;581    	{
;;;582    	    Delay2us();
00004e  f7fffffe          BL       Delay2us
;;;583    		if(i++>50000)break;
000052  4630              MOV      r0,r6
000054  1c76              ADDS     r6,r6,#1
000056  f24c3150          MOV      r1,#0xc350
00005a  4288              CMP      r0,r1
00005c  d900              BLS      |L9.96|
00005e  e005              B        |L9.108|
                  |L9.96|
000060  2101              MOVS     r1,#1                 ;580
000062  4805              LDR      r0,|L9.120|
000064  f7fffffe          BL       GPIO_ReadInputDataBit
000068  2800              CMP      r0,#0                 ;580
00006a  d1f0              BNE      |L9.78|
                  |L9.108|
00006c  bf00              NOP      
;;;584    	}
;;;585    	// Delayx10us(10);
;;;586    	SPIStrobe(CCxxx0_SFTX);
00006e  203b              MOVS     r0,#0x3b
000070  f7fffffe          BL       SPIStrobe
;;;587    	//SPIStrobe(CCxxx0_SFRX);		//清洗接收缓冲区
;;;588        //SPIStrobe(CCxxx0_SRX);		//进入接收状态
;;;589    	//SPIStrobe(CCxxx0_SIDLE);//add
;;;590    }
000074  bd70              POP      {r4-r6,pc}
;;;591    
                          ENDP

000076  0000              DCW      0x0000
                  |L9.120|
                          DCD      0x40010c00

                          AREA ||i.RfWriteRfSettings||, CODE, READONLY, ALIGN=1

                  RfWriteRfSettings PROC
;;;466    
;;;467    void RfWriteRfSettings(void) 
000000  b510              PUSH     {r4,lr}
;;;468    {
;;;469    /*
;;;470    	SPIWriteReg(CCxxx0_FSCTRL0,  rfSettings.FSCTRL2);//自已加的
;;;471        // Write register settings
;;;472        SPIWriteReg(CCxxx0_FSCTRL1,  rfSettings.FSCTRL1);
;;;473        SPIWriteReg(CCxxx0_FSCTRL0,  rfSettings.FSCTRL0);
;;;474        SPIWriteReg(CCxxx0_FREQ2,    rfSettings.FREQ2);
;;;475        SPIWriteReg(CCxxx0_FREQ1,    rfSettings.FREQ1);
;;;476        SPIWriteReg(CCxxx0_FREQ0,    rfSettings.FREQ0);
;;;477        SPIWriteReg(CCxxx0_MDMCFG4,  rfSettings.MDMCFG4);
;;;478        SPIWriteReg(CCxxx0_MDMCFG3,  rfSettings.MDMCFG3);
;;;479        SPIWriteReg(CCxxx0_MDMCFG2,  rfSettings.MDMCFG2);
;;;480        SPIWriteReg(CCxxx0_MDMCFG1,  rfSettings.MDMCFG1);
;;;481        SPIWriteReg(CCxxx0_MDMCFG0,  rfSettings.MDMCFG0);
;;;482        SPIWriteReg(CCxxx0_CHANNR,   rfSettings.CHANNR);
;;;483        SPIWriteReg(CCxxx0_DEVIATN,  rfSettings.DEVIATN);
;;;484        SPIWriteReg(CCxxx0_FREND1,   rfSettings.FREND1);
;;;485        SPIWriteReg(CCxxx0_FREND0,   rfSettings.FREND0);
;;;486        //SPIWriteReg(CCxxx0_MCSM1,    rfSettings.MCSM1 );//加
;;;487        SPIWriteReg(CCxxx0_MCSM0 ,   rfSettings.MCSM0 );
;;;488        SPIWriteReg(CCxxx0_FOCCFG,   rfSettings.FOCCFG);
;;;489        SPIWriteReg(CCxxx0_BSCFG,    rfSettings.BSCFG);
;;;490        SPIWriteReg(CCxxx0_AGCCTRL2, rfSettings.AGCCTRL2);
;;;491    	SPIWriteReg(CCxxx0_AGCCTRL1, rfSettings.AGCCTRL1);
;;;492        SPIWriteReg(CCxxx0_AGCCTRL0, rfSettings.AGCCTRL0);
;;;493        SPIWriteReg(CCxxx0_FSCAL3,   rfSettings.FSCAL3);
;;;494    	SPIWriteReg(CCxxx0_FSCAL2,   rfSettings.FSCAL2);
;;;495    	SPIWriteReg(CCxxx0_FSCAL1,   rfSettings.FSCAL1);
;;;496        SPIWriteReg(CCxxx0_FSCAL0,   rfSettings.FSCAL0);
;;;497        SPIWriteReg(CCxxx0_FSTEST,   rfSettings.FSTEST);
;;;498        SPIWriteReg(CCxxx0_TEST2,    rfSettings.TEST2);
;;;499        SPIWriteReg(CCxxx0_TEST1,    rfSettings.TEST1);
;;;500        SPIWriteReg(CCxxx0_TEST0,    rfSettings.TEST0);
;;;501        SPIWriteReg(CCxxx0_IOCFG2,   rfSettings.IOCFG2);
;;;502        SPIWriteReg(CCxxx0_IOCFG0,   rfSettings.IOCFG0);    
;;;503        SPIWriteReg(CCxxx0_PKTCTRL1, rfSettings.PKTCTRL1);
;;;504        SPIWriteReg(CCxxx0_PKTCTRL0, rfSettings.PKTCTRL0);
;;;505        SPIWriteReg(CCxxx0_ADDR,     rfSettings.ADDR);
;;;506        SPIWriteReg(CCxxx0_PKTLEN,   rfSettings.PKTLEN);
;;;507    */
;;;508    
;;;509    	halRfWriteReg(IOCFG0,0x06);
000002  2106              MOVS     r1,#6
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       SPIWriteReg
;;;510    	
;;;511    	halRfWriteReg(PKTCTRL0,0x05);
00000a  2105              MOVS     r1,#5
00000c  2008              MOVS     r0,#8
00000e  f7fffffe          BL       SPIWriteReg
;;;512    	
;;;513    	
;;;514    	
;;;515    	//halRfWriteReg(CHANNR,0x05);         //20170424测试用
;;;516    	halRfWriteReg(CHANNR,0x01);
000012  2101              MOVS     r1,#1
000014  200a              MOVS     r0,#0xa
000016  f7fffffe          BL       SPIWriteReg
;;;517    	
;;;518    	
;;;519    	halRfWriteReg(FSCTRL1,0x08);
00001a  2108              MOVS     r1,#8
00001c  200b              MOVS     r0,#0xb
00001e  f7fffffe          BL       SPIWriteReg
;;;520    	halRfWriteReg(FREQ2,0x21);
000022  2121              MOVS     r1,#0x21
000024  200d              MOVS     r0,#0xd
000026  f7fffffe          BL       SPIWriteReg
;;;521    	halRfWriteReg(FREQ1,0x62);
00002a  2162              MOVS     r1,#0x62
00002c  200e              MOVS     r0,#0xe
00002e  f7fffffe          BL       SPIWriteReg
;;;522    	halRfWriteReg(FREQ0,0x76);
000032  2176              MOVS     r1,#0x76
000034  200f              MOVS     r0,#0xf
000036  f7fffffe          BL       SPIWriteReg
;;;523    	halRfWriteReg(MDMCFG4,0xC7);
00003a  21c7              MOVS     r1,#0xc7
00003c  2010              MOVS     r0,#0x10
00003e  f7fffffe          BL       SPIWriteReg
;;;524    	halRfWriteReg(MDMCFG3,0x83);
000042  2183              MOVS     r1,#0x83
000044  2011              MOVS     r0,#0x11
000046  f7fffffe          BL       SPIWriteReg
;;;525    	halRfWriteReg(MDMCFG2,0x93);
00004a  2193              MOVS     r1,#0x93
00004c  2012              MOVS     r0,#0x12
00004e  f7fffffe          BL       SPIWriteReg
;;;526    	halRfWriteReg(DEVIATN,0x40);
000052  2140              MOVS     r1,#0x40
000054  2015              MOVS     r0,#0x15
000056  f7fffffe          BL       SPIWriteReg
;;;527    	halRfWriteReg(MCSM0,0x18);
00005a  2118              MOVS     r1,#0x18
00005c  4608              MOV      r0,r1
00005e  f7fffffe          BL       SPIWriteReg
;;;528    	halRfWriteReg(FOCCFG,0x16);
000062  2116              MOVS     r1,#0x16
000064  2019              MOVS     r0,#0x19
000066  f7fffffe          BL       SPIWriteReg
;;;529    	halRfWriteReg(AGCCTRL2,0x43);
00006a  2143              MOVS     r1,#0x43
00006c  201b              MOVS     r0,#0x1b
00006e  f7fffffe          BL       SPIWriteReg
;;;530    	halRfWriteReg(WORCTRL,0xFB);
000072  21fb              MOVS     r1,#0xfb
000074  2020              MOVS     r0,#0x20
000076  f7fffffe          BL       SPIWriteReg
;;;531    	halRfWriteReg(FSCAL3,0xE9);
00007a  21e9              MOVS     r1,#0xe9
00007c  2023              MOVS     r0,#0x23
00007e  f7fffffe          BL       SPIWriteReg
;;;532    	halRfWriteReg(FSCAL2,0x2A);
000082  212a              MOVS     r1,#0x2a
000084  2024              MOVS     r0,#0x24
000086  f7fffffe          BL       SPIWriteReg
;;;533    	halRfWriteReg(FSCAL1,0x00);
00008a  2100              MOVS     r1,#0
00008c  2025              MOVS     r0,#0x25
00008e  f7fffffe          BL       SPIWriteReg
;;;534    	halRfWriteReg(FSCAL0,0x1F);
000092  211f              MOVS     r1,#0x1f
000094  2026              MOVS     r0,#0x26
000096  f7fffffe          BL       SPIWriteReg
;;;535    	halRfWriteReg(TEST2,0x81);
00009a  2181              MOVS     r1,#0x81
00009c  202c              MOVS     r0,#0x2c
00009e  f7fffffe          BL       SPIWriteReg
;;;536    	halRfWriteReg(TEST1,0x35);
0000a2  2135              MOVS     r1,#0x35
0000a4  202d              MOVS     r0,#0x2d
0000a6  f7fffffe          BL       SPIWriteReg
;;;537    	halRfWriteReg(TEST0,0x09);
0000aa  2109              MOVS     r1,#9
0000ac  202e              MOVS     r0,#0x2e
0000ae  f7fffffe          BL       SPIWriteReg
;;;538    
;;;539    	//SPIWriteReg(CCxxx0_IOCFG2,   0x0e);
;;;540    	SPIWriteReg(CCxxx0_IOCFG2,   0x0b);
0000b2  210b              MOVS     r1,#0xb
0000b4  2000              MOVS     r0,#0
0000b6  f7fffffe          BL       SPIWriteReg
;;;541    	SPIWriteReg(CCxxx0_FSCTRL0,  0x00);
0000ba  2100              MOVS     r1,#0
0000bc  200c              MOVS     r0,#0xc
0000be  f7fffffe          BL       SPIWriteReg
;;;542    	SPIWriteReg(CCxxx0_BSCFG,    0x6c);
0000c2  216c              MOVS     r1,#0x6c
0000c4  201a              MOVS     r0,#0x1a
0000c6  f7fffffe          BL       SPIWriteReg
;;;543    	SPIWriteReg(CCxxx0_FSTEST,   0x59);
0000ca  2159              MOVS     r1,#0x59
0000cc  2029              MOVS     r0,#0x29
0000ce  f7fffffe          BL       SPIWriteReg
;;;544    	SPIWriteReg(CCxxx0_PKTCTRL1, 0x04);
0000d2  2104              MOVS     r1,#4
0000d4  2007              MOVS     r0,#7
0000d6  f7fffffe          BL       SPIWriteReg
;;;545    	//SPIWriteReg(CCxxx0_ADDR,     0x00);
;;;546        SPIWriteReg(CCxxx0_PKTLEN,   0xff); 
0000da  21ff              MOVS     r1,#0xff
0000dc  2006              MOVS     r0,#6
0000de  f7fffffe          BL       SPIWriteReg
;;;547    	halRfWriteReg(AGCCTRL1,0x41);
0000e2  2141              MOVS     r1,#0x41
0000e4  201c              MOVS     r0,#0x1c
0000e6  f7fffffe          BL       SPIWriteReg
;;;548    	halRfWriteReg(AGCCTRL0,0xb2);
0000ea  21b2              MOVS     r1,#0xb2
0000ec  201d              MOVS     r0,#0x1d
0000ee  f7fffffe          BL       SPIWriteReg
;;;549    }
0000f2  bd10              POP      {r4,pc}
;;;550    //*****************************************************************************************
                          ENDP


                          AREA ||i.SPIReadBurstReg||, CODE, READONLY, ALIGN=2

                  SPIReadBurstReg PROC
;;;408    //*****************************************************************************************
;;;409    void SPIReadBurstReg(unsigned char addr, unsigned char *buffer, unsigned char count) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;410    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;411        unsigned int i=0;
00000a  2400              MOVS     r4,#0
;;;412        unsigned char temp;
;;;413    	temp = addr | READ_BURST;		//写入要读的配置寄存器地址和读命令
00000c  f04508c0          ORR      r8,r5,#0xc0
;;;414        //CCS = 0;
;;;415    	GPIO_ResetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
000010  2110              MOVS     r1,#0x10
000012  4811              LDR      r0,|L11.88|
000014  f7fffffe          BL       GPIO_ResetBits
;;;416        //while (CMISO)
;;;417    	while(GPIO_ReadInputDataBit(GPIO_CMISO_PORT,GPIO_CMISO_PIN))
000018  e005              B        |L11.38|
                  |L11.26|
;;;418    	{
;;;419    		i++;
00001a  1c64              ADDS     r4,r4,#1
;;;420    		if(i>20000)
00001c  f6446020          MOV      r0,#0x4e20
000020  4284              CMP      r4,r0
000022  d900              BLS      |L11.38|
;;;421    		  break;
000024  e005              B        |L11.50|
                  |L11.38|
000026  2180              MOVS     r1,#0x80              ;417
000028  480b              LDR      r0,|L11.88|
00002a  f7fffffe          BL       GPIO_ReadInputDataBit
00002e  2800              CMP      r0,#0                 ;417
000030  d1f3              BNE      |L11.26|
                  |L11.50|
000032  bf00              NOP      
;;;422    	}
;;;423    	SPITxRxByte(temp);   
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       SPITxRxByte
;;;424        for (i = 0; i < count; i++) 
00003a  2400              MOVS     r4,#0
00003c  e004              B        |L11.72|
                  |L11.62|
;;;425    	{
;;;426            buffer[i] = SPITxRxByte(0);
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       SPITxRxByte
000044  5530              STRB     r0,[r6,r4]
000046  1c64              ADDS     r4,r4,#1              ;424
                  |L11.72|
000048  42bc              CMP      r4,r7                 ;424
00004a  d3f8              BCC      |L11.62|
;;;427        }
;;;428        //CCS = 1;
;;;429    	GPIO_SetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
00004c  2110              MOVS     r1,#0x10
00004e  4802              LDR      r0,|L11.88|
000050  f7fffffe          BL       GPIO_SetBits
;;;430    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;431    
                          ENDP

                  |L11.88|
                          DCD      0x40010800

                          AREA ||i.SPIReadReg||, CODE, READONLY, ALIGN=2

                  SPIReadReg PROC
;;;381    //*****************************************************************************************
;;;382    unsigned char SPIReadReg(unsigned char addr) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;383    {
000004  4604              MOV      r4,r0
;;;384        unsigned int i=0;
000006  2500              MOVS     r5,#0
;;;385    	unsigned char temp, value;
;;;386        temp = addr | READ_SINGLE;//读寄存器命令
000008  f0440680          ORR      r6,r4,#0x80
;;;387    	//CCS = 0;
;;;388    	GPIO_ResetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
00000c  2110              MOVS     r1,#0x10
00000e  480f              LDR      r0,|L12.76|
000010  f7fffffe          BL       GPIO_ResetBits
;;;389    	//while (CMISO)
;;;390    	while(GPIO_ReadInputDataBit(GPIO_CMISO_PORT,GPIO_CMISO_PIN))
000014  e005              B        |L12.34|
                  |L12.22|
;;;391    	{
;;;392    		i++;
000016  1c6d              ADDS     r5,r5,#1
;;;393    		if(i>20000)
000018  f6446020          MOV      r0,#0x4e20
00001c  4285              CMP      r5,r0
00001e  d900              BLS      |L12.34|
;;;394    		  break;
000020  e005              B        |L12.46|
                  |L12.34|
000022  2180              MOVS     r1,#0x80              ;390
000024  4809              LDR      r0,|L12.76|
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  2800              CMP      r0,#0                 ;390
00002c  d1f3              BNE      |L12.22|
                  |L12.46|
00002e  bf00              NOP      
;;;395    	}
;;;396    	SPITxRxByte(temp);  //发送读存器的命令
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       SPITxRxByte
;;;397    	value = SPITxRxByte(0);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       SPITxRxByte
00003c  4607              MOV      r7,r0
;;;398    	//CCS = 1;
;;;399    	GPIO_SetBits(GPIO_CCS_PORT,GPIO_CCS_PIN); 
00003e  2110              MOVS     r1,#0x10
000040  4802              LDR      r0,|L12.76|
000042  f7fffffe          BL       GPIO_SetBits
;;;400    	return value;
000046  4638              MOV      r0,r7
;;;401    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;402    
                          ENDP

                  |L12.76|
                          DCD      0x40010800

                          AREA ||i.SPIReadStatus||, CODE, READONLY, ALIGN=2

                  SPIReadStatus PROC
;;;438    //*****************************************************************************************
;;;439    unsigned char SPIReadStatus(unsigned char addr) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;440    {
000004  4604              MOV      r4,r0
;;;441        unsigned int j=0;
000006  2500              MOVS     r5,#0
;;;442        unsigned char value,temp;
;;;443    	temp = addr | READ_BURST;		//写入要读的状态寄存器的地址同时写入读命令
000008  f04406c0          ORR      r6,r4,#0xc0
;;;444        //CCS = 0;
;;;445    	GPIO_ResetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
00000c  2110              MOVS     r1,#0x10
00000e  480f              LDR      r0,|L13.76|
000010  f7fffffe          BL       GPIO_ResetBits
;;;446        //while (CMISO)
;;;447    	while(GPIO_ReadInputDataBit(GPIO_CMISO_PORT,GPIO_CMISO_PIN))
000014  e005              B        |L13.34|
                  |L13.22|
;;;448    	{
;;;449    		j++;
000016  1c6d              ADDS     r5,r5,#1
;;;450    		if(j>20000)
000018  f6446020          MOV      r0,#0x4e20
00001c  4285              CMP      r5,r0
00001e  d900              BLS      |L13.34|
;;;451    		  break;
000020  e005              B        |L13.46|
                  |L13.34|
000022  2180              MOVS     r1,#0x80              ;447
000024  4809              LDR      r0,|L13.76|
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  2800              CMP      r0,#0                 ;447
00002c  d1f3              BNE      |L13.22|
                  |L13.46|
00002e  bf00              NOP      
;;;452    	}
;;;453        SPITxRxByte(temp);
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       SPITxRxByte
;;;454    	value = SPITxRxByte(0);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       SPITxRxByte
00003c  4607              MOV      r7,r0
;;;455    	//CCS = 1;
;;;456    	GPIO_SetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
00003e  2110              MOVS     r1,#0x10
000040  4802              LDR      r0,|L13.76|
000042  f7fffffe          BL       GPIO_SetBits
;;;457    	return value;
000046  4638              MOV      r0,r7
;;;458    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;459    
                          ENDP

                  |L13.76|
                          DCD      0x40010800

                          AREA ||i.SPIStrobe||, CODE, READONLY, ALIGN=2

                  SPIStrobe PROC
;;;354    //*****************************************************************************************
;;;355    void SPIStrobe(unsigned char strobe) 
000000  b570              PUSH     {r4-r6,lr}
;;;356    {
000002  4605              MOV      r5,r0
;;;357        unsigned int i=0;
000004  2400              MOVS     r4,#0
;;;358    
;;;359        //CCS = 0;
;;;360    	GPIO_ResetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
000006  2110              MOVS     r1,#0x10
000008  480e              LDR      r0,|L14.68|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;361        //while (CMISO)
;;;362    	while(GPIO_ReadInputDataBit(GPIO_CMISO_PORT,GPIO_CMISO_PIN))
00000e  e005              B        |L14.28|
                  |L14.16|
;;;363    	{
;;;364    		i++;
000010  1c64              ADDS     r4,r4,#1
;;;365    		if(i>20000)
000012  f6446020          MOV      r0,#0x4e20
000016  4284              CMP      r4,r0
000018  d900              BLS      |L14.28|
;;;366    		  break;
00001a  e005              B        |L14.40|
                  |L14.28|
00001c  2180              MOVS     r1,#0x80              ;362
00001e  4809              LDR      r0,|L14.68|
000020  f7fffffe          BL       GPIO_ReadInputDataBit
000024  2800              CMP      r0,#0                 ;362
000026  d1f3              BNE      |L14.16|
                  |L14.40|
000028  bf00              NOP      
;;;367    	}
;;;368        SPITxRxByte(strobe);		//写入命令
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       SPITxRxByte
;;;369        //CCS = 1;
;;;370    	GPIO_SetBits(GPIO_CCS_PORT,GPIO_CCS_PIN); 
000030  2110              MOVS     r1,#0x10
000032  4804              LDR      r0,|L14.68|
000034  f7fffffe          BL       GPIO_SetBits
;;;371        
;;;372    	//CMOSI = 0;
;;;373    	GPIO_ResetBits(GPIO_CMOSI_PORT,GPIO_CMOSI_PIN);
000038  2140              MOVS     r1,#0x40
00003a  4802              LDR      r0,|L14.68|
00003c  f7fffffe          BL       GPIO_ResetBits
;;;374    }
000040  bd70              POP      {r4-r6,pc}
;;;375    
                          ENDP

000042  0000              DCW      0x0000
                  |L14.68|
                          DCD      0x40010800

                          AREA ||i.SPITxRxByte||, CODE, READONLY, ALIGN=2

                  SPITxRxByte PROC
;;;248    
;;;249    unsigned char SPITxRxByte(unsigned char xdata)
000000  b570              PUSH     {r4-r6,lr}
;;;250    {
000002  4604              MOV      r4,r0
;;;251    	INT8U i,temp;
;;;252    	temp = 0;
000004  2500              MOVS     r5,#0
;;;253    	
;;;254    	//CSCLK = 0;
;;;255    	GPIO_ResetBits(GPIO_CSCLK_PORT,GPIO_CSCLK_PIN);
000006  2120              MOVS     r1,#0x20
000008  4818              LDR      r0,|L15.108|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;256    
;;;257    	for(i=0; i<8; i++)
00000e  2600              MOVS     r6,#0
000010  e028              B        |L15.100|
                  |L15.18|
;;;258    	{
;;;259    		if(xdata & 0x80)  //将xdata写出
000012  f0140f80          TST      r4,#0x80
000016  d004              BEQ      |L15.34|
;;;260    		{
;;;261    			//CMOSI = 1;
;;;262    			GPIO_SetBits(GPIO_CMOSI_PORT,GPIO_CMOSI_PIN);
000018  2140              MOVS     r1,#0x40
00001a  4814              LDR      r0,|L15.108|
00001c  f7fffffe          BL       GPIO_SetBits
000020  e003              B        |L15.42|
                  |L15.34|
;;;263    		}
;;;264    		else 
;;;265    		{
;;;266    			//CMOSI = 0;
;;;267    			GPIO_ResetBits(GPIO_CMOSI_PORT,GPIO_CMOSI_PIN);
000022  2140              MOVS     r1,#0x40
000024  4811              LDR      r0,|L15.108|
000026  f7fffffe          BL       GPIO_ResetBits
                  |L15.42|
;;;268    		}
;;;269    		xdata <<= 1;
00002a  0660              LSLS     r0,r4,#25
00002c  0e04              LSRS     r4,r0,#24
;;;270    
;;;271    		//CSCLK = 1; 
;;;272    		GPIO_SetBits(GPIO_CSCLK_PORT,GPIO_CSCLK_PIN);
00002e  2120              MOVS     r1,#0x20
000030  480e              LDR      r0,|L15.108|
000032  f7fffffe          BL       GPIO_SetBits
;;;273    
;;;274    		NOP();
000036  bf00              NOP      
;;;275        	NOP();
000038  bf00              NOP      
;;;276    		NOP();
00003a  bf00              NOP      
;;;277    		NOP();
00003c  bf00              NOP      
;;;278        	    	
;;;279    		temp <<= 1;
00003e  0668              LSLS     r0,r5,#25
000040  0e05              LSRS     r5,r0,#24
;;;280    		//if(CMISO)temp++;    //读入temp
;;;281    		if(GPIO_ReadInputDataBit(GPIO_CMISO_PORT,GPIO_CMISO_PIN))temp++;
000042  2180              MOVS     r1,#0x80
000044  4809              LDR      r0,|L15.108|
000046  f7fffffe          BL       GPIO_ReadInputDataBit
00004a  b108              CBZ      r0,|L15.80|
00004c  1c68              ADDS     r0,r5,#1
00004e  b2c5              UXTB     r5,r0
                  |L15.80|
;;;282    
;;;283    		//CSCLK = 0;
;;;284    		GPIO_ResetBits(GPIO_CSCLK_PORT,GPIO_CSCLK_PIN);
000050  2120              MOVS     r1,#0x20
000052  4806              LDR      r0,|L15.108|
000054  f7fffffe          BL       GPIO_ResetBits
;;;285    
;;;286    		NOP();
000058  bf00              NOP      
;;;287    		NOP();
00005a  bf00              NOP      
;;;288    		NOP();
00005c  bf00              NOP      
;;;289    		NOP();
00005e  bf00              NOP      
000060  1c70              ADDS     r0,r6,#1              ;257
000062  b2c6              UXTB     r6,r0                 ;257
                  |L15.100|
000064  2e08              CMP      r6,#8                 ;257
000066  dbd4              BLT      |L15.18|
;;;290    		
;;;291    	}
;;;292    	return temp;	
000068  4628              MOV      r0,r5
;;;293    }
00006a  bd70              POP      {r4-r6,pc}
;;;294    
                          ENDP

                  |L15.108|
                          DCD      0x40010800

                          AREA ||i.SPIWriteBurstReg||, CODE, READONLY, ALIGN=2

                  SPIWriteBurstReg PROC
;;;324    //*****************************************************************************************
;;;325    void SPIWriteBurstReg(unsigned char addr, unsigned char *buffer, unsigned char count) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;326    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;327        unsigned int i=0;
00000a  2400              MOVS     r4,#0
;;;328        unsigned char temp;
;;;329    	temp = addr | WRITE_BURST;
00000c  f0450840          ORR      r8,r5,#0x40
;;;330        //CCS = 0;
;;;331    	GPIO_ResetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
000010  2110              MOVS     r1,#0x10
000012  4811              LDR      r0,|L16.88|
000014  f7fffffe          BL       GPIO_ResetBits
;;;332    	i=0;
000018  bf00              NOP      
;;;333        //while (CMISO)
;;;334    	while(GPIO_ReadInputDataBit(GPIO_CMISO_PORT,GPIO_CMISO_PIN))
00001a  e005              B        |L16.40|
                  |L16.28|
;;;335    	{
;;;336    		i++;
00001c  1c64              ADDS     r4,r4,#1
;;;337    		if(i>20000)
00001e  f6446020          MOV      r0,#0x4e20
000022  4284              CMP      r4,r0
000024  d900              BLS      |L16.40|
;;;338    		  break;
000026  e005              B        |L16.52|
                  |L16.40|
000028  2180              MOVS     r1,#0x80              ;334
00002a  480b              LDR      r0,|L16.88|
00002c  f7fffffe          BL       GPIO_ReadInputDataBit
000030  2800              CMP      r0,#0                 ;334
000032  d1f3              BNE      |L16.28|
                  |L16.52|
000034  bf00              NOP      
;;;339    	}
;;;340        SPITxRxByte(temp);
000036  4640              MOV      r0,r8
000038  f7fffffe          BL       SPITxRxByte
;;;341        for(i = 0; i < count; i++)
00003c  2400              MOVS     r4,#0
00003e  e003              B        |L16.72|
                  |L16.64|
;;;342     	{
;;;343            SPITxRxByte(buffer[i]);
000040  5d30              LDRB     r0,[r6,r4]
000042  f7fffffe          BL       SPITxRxByte
000046  1c64              ADDS     r4,r4,#1              ;341
                  |L16.72|
000048  42bc              CMP      r4,r7                 ;341
00004a  d3f9              BCC      |L16.64|
;;;344        }
;;;345        //CCS = 1;
;;;346    	GPIO_SetBits(GPIO_CCS_PORT,GPIO_CCS_PIN); 
00004c  2110              MOVS     r1,#0x10
00004e  4802              LDR      r0,|L16.88|
000050  f7fffffe          BL       GPIO_SetBits
;;;347    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;348    
                          ENDP

                  |L16.88|
                          DCD      0x40010800

                          AREA ||i.SPIWriteReg||, CODE, READONLY, ALIGN=2

                  SPIWriteReg PROC
;;;300    //*****************************************************************************************
;;;301    void SPIWriteReg(unsigned char addr, unsigned char value) 
000000  b570              PUSH     {r4-r6,lr}
;;;302    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;303        unsigned int i=0;
000006  2500              MOVS     r5,#0
;;;304        //CCS = 0;
;;;305    	GPIO_ResetBits(GPIO_CCS_PORT,GPIO_CCS_PIN);
000008  2110              MOVS     r1,#0x10
00000a  480e              LDR      r0,|L17.68|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;306        //while (CMISO)
;;;307    	while(GPIO_ReadInputDataBit(GPIO_CMISO_PORT,GPIO_CMISO_PIN))
000010  e005              B        |L17.30|
                  |L17.18|
;;;308    	{
;;;309    		i++;
000012  1c6d              ADDS     r5,r5,#1
;;;310    		if(i>20000)
000014  f6446020          MOV      r0,#0x4e20
000018  4285              CMP      r5,r0
00001a  d900              BLS      |L17.30|
;;;311    		  break;
00001c  e005              B        |L17.42|
                  |L17.30|
00001e  2180              MOVS     r1,#0x80              ;307
000020  4808              LDR      r0,|L17.68|
000022  f7fffffe          BL       GPIO_ReadInputDataBit
000026  2800              CMP      r0,#0                 ;307
000028  d1f3              BNE      |L17.18|
                  |L17.42|
00002a  bf00              NOP      
;;;312    	}
;;;313        SPITxRxByte(addr);		//写地址
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       SPITxRxByte
;;;314        SPITxRxByte(value);		//写入配置
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       SPITxRxByte
;;;315        //CCS = 1;
;;;316    	GPIO_SetBits(GPIO_CCS_PORT,GPIO_CCS_PIN); 
000038  2110              MOVS     r1,#0x10
00003a  4802              LDR      r0,|L17.68|
00003c  f7fffffe          BL       GPIO_SetBits
;;;317    }
000040  bd70              POP      {r4-r6,pc}
;;;318    
                          ENDP

000042  0000              DCW      0x0000
                  |L17.68|
                          DCD      0x40010800

                          AREA ||i.SetRxMode||, CODE, READONLY, ALIGN=1

                  SetRxMode PROC
;;;591    
;;;592    void SetRxMode(void)
000000  b510              PUSH     {r4,lr}
;;;593    {
;;;594        SPIStrobe(CCxxx0_SRX);		//进入接收状态
000002  2034              MOVS     r0,#0x34
000004  f7fffffe          BL       SPIStrobe
;;;595    }
000008  bd10              POP      {r4,pc}
;;;596    
                          ENDP


                          AREA ||i.SpiSleep||, CODE, READONLY, ALIGN=1

                  SpiSleep PROC
;;;800    */
;;;801    void SpiSleep(void)
000000  b510              PUSH     {r4,lr}
;;;802    {
;;;803    	SPIStrobe(CCxxx0_SIDLE);
000002  2036              MOVS     r0,#0x36
000004  f7fffffe          BL       SPIStrobe
;;;804    	SPIStrobe(CCxxx0_SPWD);
000008  2039              MOVS     r0,#0x39
00000a  f7fffffe          BL       SPIStrobe
;;;805    	//SPIStrobe(CCxxx0_SWOR);	
;;;806    }
00000e  bd10              POP      {r4,pc}
;;;807    
                          ENDP


                          AREA ||i.bsp_InitCC1101||, CODE, READONLY, ALIGN=2

                  bsp_InitCC1101 PROC
;;;813    //void InitCC1101(void)
;;;814    void bsp_InitCC1101(void)
000000  b510              PUSH     {r4,lr}
;;;815    {
;;;816    	InitSPI();	
000002  f7fffffe          BL       InitSPI
;;;817    	PowerUpResetCC1100();
000006  f7fffffe          BL       PowerUpResetCC1100
;;;818    	RfWriteRfSettings();
00000a  f7fffffe          BL       RfWriteRfSettings
;;;819    	SPIWriteBurstReg(CCxxx0_PATABLE, PaTabel, 8);
00000e  2208              MOVS     r2,#8
000010  4903              LDR      r1,|L20.32|
000012  203e              MOVS     r0,#0x3e
000014  f7fffffe          BL       SPIWriteBurstReg
;;;820    	SetRxMode();
000018  f7fffffe          BL       SetRxMode
;;;821    }
00001c  bd10              POP      {r4,pc}
;;;822    
                          ENDP

00001e  0000              DCW      0x0000
                  |L20.32|
                          DCD      PaTabel

                          AREA ||.data||, DATA, ALIGN=1

                  PaTabel
000000  c3c3c3c3          DCB      0xc3,0xc3,0xc3,0xc3
000004  c3c3c3c3          DCB      0xc3,0xc3,0xc3,0xc3
                  flag_recv
000008  0000              DCB      0x00,0x00
                  GPIO_InitStructure
00000a  0000              DCB      0x00,0x00
00000c  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_CC1101.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_CC1101_c_PaTabel____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_CC1101_c_PaTabel____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_CC1101_c_PaTabel____REVSH|
#line 128
|__asm___12_bsp_CC1101_c_PaTabel____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
