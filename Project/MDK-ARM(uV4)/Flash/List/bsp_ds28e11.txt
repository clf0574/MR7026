; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outupt\bsp_ds28e11.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\outupt\bsp_ds28e11.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\outupt\bsp_ds28e11.crf ..\..\User\bsp\src\bsp_DS28E11.c]
                          THUMB

                          AREA ||i.AuthenticatedWriteBlockProtection||, CODE, READONLY, ALIGN=2

                  AuthenticatedWriteBlockProtection PROC
;;;799    
;;;800    unsigned char AuthenticatedWriteBlockProtection(unsigned char Block ,unsigned char ProtectOption)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;801    
;;;802    {
000004  b08e              SUB      sp,sp,#0x38
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;803      
;;;804         unsigned char pbuf[20],cnt=0,i,outcome,Mac_value[32],status[4];
00000a  2500              MOVS     r5,#0
;;;805         blockindex=Block;
00000c  486f              LDR      r0,|L1.460|
00000e  7006              STRB     r6,[r0,#0]
;;;806         ReadBlockStatus(blockindex,(bool)0, status);
000010  466a              MOV      r2,sp
000012  2100              MOVS     r1,#0
000014  7800              LDRB     r0,[r0,#0]  ; blockindex
000016  f7fffffe          BL       ReadBlockStatus
;;;807         memcpy_clf(&MAC_Computer_Datainput[32],RomID_Buffer,32);
00001a  2220              MOVS     r2,#0x20
00001c  496c              LDR      r1,|L1.464|
00001e  486d              LDR      r0,|L1.468|
000020  f7fffffe          BL       memcpy_clf
;;;808         memcpy_clf(&MAC_Computer_Datainput[40],&Personality_Value[2],2);
000024  2202              MOVS     r2,#2
000026  496c              LDR      r1,|L1.472|
000028  486a              LDR      r0,|L1.468|
00002a  3008              ADDS     r0,r0,#8
00002c  f7fffffe          BL       memcpy_clf
;;;809         MAC_Computer_Datainput[42]=Block&0x03;
000030  f0060003          AND      r0,r6,#3
000034  4967              LDR      r1,|L1.468|
000036  3920              SUBS     r1,r1,#0x20
000038  f881002a          STRB     r0,[r1,#0x2a]
;;;810         
;;;811         for(i=0 ;i <4 ; i++)
00003c  2400              MOVS     r4,#0
00003e  e010              B        |L1.98|
                  |L1.64|
;;;812         {
;;;813           
;;;814           MAC_Computer_Datainput[44+i]=((*status>>(4+i))&0x01)==0x01? 0x01:0x00;
000040  f89d0000          LDRB     r0,[sp,#0]
000044  1d21              ADDS     r1,r4,#4
000046  4108              ASRS     r0,r0,r1
000048  f0000001          AND      r0,r0,#1
00004c  f0800001          EOR      r0,r0,#1
000050  f0800101          EOR      r1,r0,#1
000054  f104002c          ADD      r0,r4,#0x2c
000058  4a5e              LDR      r2,|L1.468|
00005a  3a20              SUBS     r2,r2,#0x20
00005c  5411              STRB     r1,[r2,r0]
00005e  1c60              ADDS     r0,r4,#1              ;811
000060  b2c4              UXTB     r4,r0                 ;811
                  |L1.98|
000062  2c04              CMP      r4,#4                 ;811
000064  dbec              BLT      |L1.64|
;;;815         }
;;;816         for(i=0 ;i <4 ; i++)
000066  2400              MOVS     r4,#0
000068  e00f              B        |L1.138|
                  |L1.106|
;;;817         {
;;;818           
;;;819           MAC_Computer_Datainput[48+i]=((ProtectOption>>(4+i))&0x01)==0x01? 0x01:0x00;
00006a  1d20              ADDS     r0,r4,#4
00006c  fa47f000          ASR      r0,r7,r0
000070  f0000001          AND      r0,r0,#1
000074  f0800001          EOR      r0,r0,#1
000078  f0800101          EOR      r1,r0,#1
00007c  f1040030          ADD      r0,r4,#0x30
000080  4a54              LDR      r2,|L1.468|
000082  3a20              SUBS     r2,r2,#0x20
000084  5411              STRB     r1,[r2,r0]
000086  1c60              ADDS     r0,r4,#1              ;816
000088  b2c4              UXTB     r4,r0                 ;816
                  |L1.138|
00008a  2c04              CMP      r4,#4                 ;816
00008c  dbed              BLT      |L1.106|
;;;820         }
;;;821         
;;;822           ComputeMAC256(MAC_Computer_Datainput, 55, Mac_value);
00008e  aa01              ADD      r2,sp,#4
000090  2137              MOVS     r1,#0x37
000092  4850              LDR      r0,|L1.468|
000094  3820              SUBS     r0,r0,#0x20
000096  f7fffffe          BL       ComputeMAC256
;;;823      
;;;824        if ( (ow_reset())!=0 ) return 0;
00009a  f7fffffe          BL       ow_reset
00009e  b118              CBZ      r0,|L1.168|
0000a0  2000              MOVS     r0,#0
                  |L1.162|
;;;825        write_byte(0xCC);		                                         //Skip ROM command
;;;826      
;;;827      /* construct a packet to send */
;;;828        pbuf[cnt++] = AuthenticatedWriteBlockProtection_Command;             // write WriteMemory_Function command
;;;829        pbuf[cnt++] = ProtectOption|Block;                                   // Segment and Page ,Assure Bit4~Bit1:0000
;;;830        	        
;;;831    
;;;832        /* Send Data */
;;;833        for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;834        
;;;835        /* Receive CRC */
;;;836          pbuf[cnt++]=read_byte();
;;;837          pbuf[cnt++]=read_byte();
;;;838        
;;;839        /* calculate the CRC over this part */
;;;840          CRC16 = 0;
;;;841          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;842          if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;843           return 0xFF;
;;;844      
;;;845         
;;;846      
;;;847           Delay_us(3000);                                   //Wait for 1 times for SHA-256 Calculation; 
;;;848      
;;;849          for(i = 0 ,cnt = 0; i < 32 ;i++, cnt++)
;;;850          { 
;;;851            write_byte(Mac_value[i]);
;;;852            pbuf[cnt]=Mac_value[i];
;;;853          }
;;;854           /* Receive CRC */
;;;855           pbuf[cnt++]=read_byte();
;;;856           pbuf[cnt++]=read_byte();
;;;857           
;;;858              /* calculate the CRC over this part */
;;;859          CRC16 = 0;
;;;860          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;861          if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;862          return 0xFF;
;;;863          
;;;864          outcome=read_byte();
;;;865          if(outcome!=0xAA)
;;;866          return outcome;
;;;867          
;;;868          
;;;869            /* Send Release Byte */
;;;870           write_byte(0xAA); 
;;;871           for(i=0 ;i<10;i++)                               //Waiting for 100ms for Secreting Loading
;;;872           Delay_us(10000);
;;;873      
;;;874           outcome=read_byte();
;;;875           ow_reset();
;;;876           return outcome;
;;;877       
;;;878    }
0000a2  b00e              ADD      sp,sp,#0x38
0000a4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.168|
0000a8  20cc              MOVS     r0,#0xcc              ;825
0000aa  f7fffffe          BL       write_byte
0000ae  22cc              MOVS     r2,#0xcc              ;828
0000b0  4628              MOV      r0,r5                 ;828
0000b2  1c69              ADDS     r1,r5,#1              ;828
0000b4  b2cd              UXTB     r5,r1                 ;828
0000b6  a909              ADD      r1,sp,#0x24           ;828
0000b8  540a              STRB     r2,[r1,r0]            ;828
0000ba  ea470006          ORR      r0,r7,r6              ;829
0000be  4629              MOV      r1,r5                 ;829
0000c0  1c6a              ADDS     r2,r5,#1              ;829
0000c2  b2d5              UXTB     r5,r2                 ;829
0000c4  aa09              ADD      r2,sp,#0x24           ;829
0000c6  5450              STRB     r0,[r2,r1]            ;829
0000c8  2400              MOVS     r4,#0                 ;833
0000ca  e005              B        |L1.216|
                  |L1.204|
0000cc  a909              ADD      r1,sp,#0x24           ;833
0000ce  5d08              LDRB     r0,[r1,r4]            ;833
0000d0  f7fffffe          BL       write_byte
0000d4  1c60              ADDS     r0,r4,#1              ;833
0000d6  b2c4              UXTB     r4,r0                 ;833
                  |L1.216|
0000d8  42ac              CMP      r4,r5                 ;833
0000da  dbf7              BLT      |L1.204|
0000dc  f7fffffe          BL       read_byte
0000e0  4629              MOV      r1,r5                 ;836
0000e2  1c6a              ADDS     r2,r5,#1              ;836
0000e4  b2d5              UXTB     r5,r2                 ;836
0000e6  aa09              ADD      r2,sp,#0x24           ;836
0000e8  5450              STRB     r0,[r2,r1]            ;836
0000ea  f7fffffe          BL       read_byte
0000ee  4629              MOV      r1,r5                 ;837
0000f0  1c6a              ADDS     r2,r5,#1              ;837
0000f2  b2d5              UXTB     r5,r2                 ;837
0000f4  aa09              ADD      r2,sp,#0x24           ;837
0000f6  5450              STRB     r0,[r2,r1]            ;837
0000f8  2000              MOVS     r0,#0                 ;840
0000fa  4938              LDR      r1,|L1.476|
0000fc  6008              STR      r0,[r1,#0]            ;840  ; CRC16
0000fe  2400              MOVS     r4,#0                 ;841
000100  e005              B        |L1.270|
                  |L1.258|
000102  a909              ADD      r1,sp,#0x24           ;841
000104  5d08              LDRB     r0,[r1,r4]            ;841
000106  f7fffffe          BL       docrc16
00010a  1c60              ADDS     r0,r4,#1              ;841
00010c  b2c4              UXTB     r4,r0                 ;841
                  |L1.270|
00010e  42ac              CMP      r4,r5                 ;841
000110  dbf7              BLT      |L1.258|
000112  4832              LDR      r0,|L1.476|
000114  6800              LDR      r0,[r0,#0]            ;842  ; CRC16
000116  f24b0101          MOV      r1,#0xb001            ;842
00011a  4288              CMP      r0,r1                 ;842
00011c  d001              BEQ      |L1.290|
00011e  20ff              MOVS     r0,#0xff              ;843
000120  e7bf              B        |L1.162|
                  |L1.290|
000122  f64030b8          MOV      r0,#0xbb8             ;847
000126  f7fffffe          BL       Delay_us
00012a  2400              MOVS     r4,#0                 ;849
00012c  2500              MOVS     r5,#0                 ;849
00012e  e00b              B        |L1.328|
                  |L1.304|
000130  a901              ADD      r1,sp,#4              ;851
000132  5d08              LDRB     r0,[r1,r4]            ;851
000134  f7fffffe          BL       write_byte
000138  a801              ADD      r0,sp,#4              ;852
00013a  5d00              LDRB     r0,[r0,r4]            ;852
00013c  a909              ADD      r1,sp,#0x24           ;852
00013e  5548              STRB     r0,[r1,r5]            ;852
000140  1c60              ADDS     r0,r4,#1              ;849
000142  b2c4              UXTB     r4,r0                 ;849
000144  1c68              ADDS     r0,r5,#1              ;849
000146  b2c5              UXTB     r5,r0                 ;849
                  |L1.328|
000148  2c20              CMP      r4,#0x20              ;849
00014a  dbf1              BLT      |L1.304|
00014c  f7fffffe          BL       read_byte
000150  4629              MOV      r1,r5                 ;855
000152  1c6a              ADDS     r2,r5,#1              ;855
000154  b2d5              UXTB     r5,r2                 ;855
000156  aa09              ADD      r2,sp,#0x24           ;855
000158  5450              STRB     r0,[r2,r1]            ;855
00015a  f7fffffe          BL       read_byte
00015e  4629              MOV      r1,r5                 ;856
000160  1c6a              ADDS     r2,r5,#1              ;856
000162  b2d5              UXTB     r5,r2                 ;856
000164  aa09              ADD      r2,sp,#0x24           ;856
000166  5450              STRB     r0,[r2,r1]            ;856
000168  2000              MOVS     r0,#0                 ;859
00016a  491c              LDR      r1,|L1.476|
00016c  6008              STR      r0,[r1,#0]            ;859  ; CRC16
00016e  2400              MOVS     r4,#0                 ;860
000170  e005              B        |L1.382|
                  |L1.370|
000172  a909              ADD      r1,sp,#0x24           ;860
000174  5d08              LDRB     r0,[r1,r4]            ;860
000176  f7fffffe          BL       docrc16
00017a  1c60              ADDS     r0,r4,#1              ;860
00017c  b2c4              UXTB     r4,r0                 ;860
                  |L1.382|
00017e  42ac              CMP      r4,r5                 ;860
000180  dbf7              BLT      |L1.370|
000182  4816              LDR      r0,|L1.476|
000184  6800              LDR      r0,[r0,#0]            ;861  ; CRC16
000186  f24b0101          MOV      r1,#0xb001            ;861
00018a  4288              CMP      r0,r1                 ;861
00018c  d001              BEQ      |L1.402|
00018e  20ff              MOVS     r0,#0xff              ;862
000190  e787              B        |L1.162|
                  |L1.402|
000192  f7fffffe          BL       read_byte
000196  4680              MOV      r8,r0                 ;864
000198  f1b80faa          CMP      r8,#0xaa              ;865
00019c  d001              BEQ      |L1.418|
00019e  4640              MOV      r0,r8                 ;866
0001a0  e77f              B        |L1.162|
                  |L1.418|
0001a2  20aa              MOVS     r0,#0xaa              ;870
0001a4  f7fffffe          BL       write_byte
0001a8  2400              MOVS     r4,#0                 ;871
0001aa  e005              B        |L1.440|
                  |L1.428|
0001ac  f2427010          MOV      r0,#0x2710            ;872
0001b0  f7fffffe          BL       Delay_us
0001b4  1c60              ADDS     r0,r4,#1              ;871
0001b6  b2c4              UXTB     r4,r0                 ;871
                  |L1.440|
0001b8  2c0a              CMP      r4,#0xa               ;871
0001ba  dbf7              BLT      |L1.428|
0001bc  f7fffffe          BL       read_byte
0001c0  4680              MOV      r8,r0                 ;874
0001c2  f7fffffe          BL       ow_reset
0001c6  4640              MOV      r0,r8                 ;876
0001c8  e76b              B        |L1.162|
;;;879    
                          ENDP

0001ca  0000              DCW      0x0000
                  |L1.460|
                          DCD      blockindex
                  |L1.464|
                          DCD      RomID_Buffer
                  |L1.468|
                          DCD      MAC_Computer_Datainput+0x20
                  |L1.472|
                          DCD      Personality_Value+0x2
                  |L1.476|
                          DCD      CRC16

                          AREA ||i.AuthenticatedWriteMemory||, CODE, READONLY, ALIGN=2

                  AuthenticatedWriteMemory PROC
;;;1227   */
;;;1228   unsigned char AuthenticatedWriteMemory(unsigned char Segment ,unsigned char Page, unsigned char *Buffer,unsigned char *MAC)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1229   {
000004  b086              SUB      sp,sp,#0x18
000006  4681              MOV      r9,r0
000008  468a              MOV      r10,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;1230     
;;;1231       unsigned char pbuf[20],cnt=0,i,outcome;
00000e  2500              MOVS     r5,#0
;;;1232       if ( (ow_reset())!=0 ) return 0;
000010  f7fffffe          BL       ow_reset
000014  b118              CBZ      r0,|L2.30|
000016  2000              MOVS     r0,#0
                  |L2.24|
;;;1233       write_byte(0xCC);		                                       //Skip ROM command  
;;;1234       
;;;1235       
;;;1236           /* construct a packet to send */
;;;1237       pbuf[cnt++] = AuthenticatedWriteMemory_Command;                        // Read Memory Block Status or PersonalityByteindicator
;;;1238       pbuf[cnt++]= ((Segment<<5)|Page)&0xE1;   
;;;1239       
;;;1240          /* Send Data */
;;;1241       for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;1242       
;;;1243          /* Receive CRC */
;;;1244       pbuf[cnt++]=read_byte();
;;;1245       pbuf[cnt++]=read_byte();
;;;1246       
;;;1247       /* calculate the CRC over this part */
;;;1248         CRC16 = 0;
;;;1249         for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;1250         if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;1251         return 0xFF;
;;;1252         
;;;1253         for(i = 0 ,cnt = 0; i < 4 ;i++, cnt++)
;;;1254         { 
;;;1255           write_byte(Buffer[i]);
;;;1256           pbuf[cnt]=Buffer[i];
;;;1257         }
;;;1258         
;;;1259         /* Receive CRC */
;;;1260          pbuf[cnt++]=read_byte();
;;;1261          pbuf[cnt++]=read_byte();
;;;1262          
;;;1263             /* calculate the CRC over this part */
;;;1264         CRC16 = 0;
;;;1265         for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;1266         if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;1267         return 0xFF;
;;;1268         
;;;1269         Delay_us(3000);                                   //Wait for 1 times for SHA-256 Calculation; 
;;;1270     
;;;1271         for(i = 0 ,cnt = 0; i < 32 ;i++, cnt++)
;;;1272         { 
;;;1273           write_byte(MAC[i]);
;;;1274           pbuf[cnt]=MAC[i];
;;;1275         }
;;;1276          /* Receive CRC */
;;;1277          pbuf[cnt++]=read_byte();
;;;1278          pbuf[cnt++]=read_byte();
;;;1279          
;;;1280             /* calculate the CRC over this part */
;;;1281         CRC16 = 0;
;;;1282         for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;1283         if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;1284         return 0xFF;
;;;1285         
;;;1286         outcome=read_byte();
;;;1287         if(outcome!=0xAA)
;;;1288         return outcome;
;;;1289         
;;;1290          /* Send Release Byte */
;;;1291          write_byte(0xAA); 
;;;1292          Delay_us(10000); 
;;;1293          outcome=read_byte();
;;;1294          ow_reset();
;;;1295          return outcome;
;;;1296   }
000018  b006              ADD      sp,sp,#0x18
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L2.30|
00001e  20cc              MOVS     r0,#0xcc              ;1233
000020  f7fffffe          BL       write_byte
000024  225a              MOVS     r2,#0x5a              ;1237
000026  4628              MOV      r0,r5                 ;1237
000028  1c69              ADDS     r1,r5,#1              ;1237
00002a  b2cd              UXTB     r5,r1                 ;1237
00002c  a901              ADD      r1,sp,#4              ;1237
00002e  540a              STRB     r2,[r1,r0]            ;1237
000030  ea4a1049          ORR      r0,r10,r9,LSL #5      ;1238
000034  f00002e1          AND      r2,r0,#0xe1           ;1238
000038  4628              MOV      r0,r5                 ;1238
00003a  1c69              ADDS     r1,r5,#1              ;1238
00003c  b2cd              UXTB     r5,r1                 ;1238
00003e  a901              ADD      r1,sp,#4              ;1238
000040  540a              STRB     r2,[r1,r0]            ;1238
000042  2400              MOVS     r4,#0                 ;1241
000044  e005              B        |L2.82|
                  |L2.70|
000046  a901              ADD      r1,sp,#4              ;1241
000048  5d08              LDRB     r0,[r1,r4]            ;1241
00004a  f7fffffe          BL       write_byte
00004e  1c60              ADDS     r0,r4,#1              ;1241
000050  b2c4              UXTB     r4,r0                 ;1241
                  |L2.82|
000052  42ac              CMP      r4,r5                 ;1241
000054  dbf7              BLT      |L2.70|
000056  f7fffffe          BL       read_byte
00005a  4629              MOV      r1,r5                 ;1244
00005c  1c6a              ADDS     r2,r5,#1              ;1244
00005e  b2d5              UXTB     r5,r2                 ;1244
000060  aa01              ADD      r2,sp,#4              ;1244
000062  5450              STRB     r0,[r2,r1]            ;1244
000064  f7fffffe          BL       read_byte
000068  4629              MOV      r1,r5                 ;1245
00006a  1c6a              ADDS     r2,r5,#1              ;1245
00006c  b2d5              UXTB     r5,r2                 ;1245
00006e  aa01              ADD      r2,sp,#4              ;1245
000070  5450              STRB     r0,[r2,r1]            ;1245
000072  2000              MOVS     r0,#0                 ;1248
000074  4948              LDR      r1,|L2.408|
000076  6008              STR      r0,[r1,#0]            ;1248  ; CRC16
000078  2400              MOVS     r4,#0                 ;1249
00007a  e005              B        |L2.136|
                  |L2.124|
00007c  a901              ADD      r1,sp,#4              ;1249
00007e  5d08              LDRB     r0,[r1,r4]            ;1249
000080  f7fffffe          BL       docrc16
000084  1c60              ADDS     r0,r4,#1              ;1249
000086  b2c4              UXTB     r4,r0                 ;1249
                  |L2.136|
000088  42ac              CMP      r4,r5                 ;1249
00008a  dbf7              BLT      |L2.124|
00008c  4842              LDR      r0,|L2.408|
00008e  6800              LDR      r0,[r0,#0]            ;1250  ; CRC16
000090  f24b0101          MOV      r1,#0xb001            ;1250
000094  4288              CMP      r0,r1                 ;1250
000096  d001              BEQ      |L2.156|
000098  20ff              MOVS     r0,#0xff              ;1251
00009a  e7bd              B        |L2.24|
                  |L2.156|
00009c  2400              MOVS     r4,#0                 ;1253
00009e  2500              MOVS     r5,#0                 ;1253
0000a0  e009              B        |L2.182|
                  |L2.162|
0000a2  5d30              LDRB     r0,[r6,r4]            ;1255
0000a4  f7fffffe          BL       write_byte
0000a8  5d30              LDRB     r0,[r6,r4]            ;1256
0000aa  a901              ADD      r1,sp,#4              ;1256
0000ac  5548              STRB     r0,[r1,r5]            ;1256
0000ae  1c60              ADDS     r0,r4,#1              ;1253
0000b0  b2c4              UXTB     r4,r0                 ;1253
0000b2  1c68              ADDS     r0,r5,#1              ;1253
0000b4  b2c5              UXTB     r5,r0                 ;1253
                  |L2.182|
0000b6  2c04              CMP      r4,#4                 ;1253
0000b8  dbf3              BLT      |L2.162|
0000ba  f7fffffe          BL       read_byte
0000be  4629              MOV      r1,r5                 ;1260
0000c0  1c6a              ADDS     r2,r5,#1              ;1260
0000c2  b2d5              UXTB     r5,r2                 ;1260
0000c4  aa01              ADD      r2,sp,#4              ;1260
0000c6  5450              STRB     r0,[r2,r1]            ;1260
0000c8  f7fffffe          BL       read_byte
0000cc  4629              MOV      r1,r5                 ;1261
0000ce  1c6a              ADDS     r2,r5,#1              ;1261
0000d0  b2d5              UXTB     r5,r2                 ;1261
0000d2  aa01              ADD      r2,sp,#4              ;1261
0000d4  5450              STRB     r0,[r2,r1]            ;1261
0000d6  2000              MOVS     r0,#0                 ;1264
0000d8  492f              LDR      r1,|L2.408|
0000da  6008              STR      r0,[r1,#0]            ;1264  ; CRC16
0000dc  2400              MOVS     r4,#0                 ;1265
0000de  e005              B        |L2.236|
                  |L2.224|
0000e0  a901              ADD      r1,sp,#4              ;1265
0000e2  5d08              LDRB     r0,[r1,r4]            ;1265
0000e4  f7fffffe          BL       docrc16
0000e8  1c60              ADDS     r0,r4,#1              ;1265
0000ea  b2c4              UXTB     r4,r0                 ;1265
                  |L2.236|
0000ec  42ac              CMP      r4,r5                 ;1265
0000ee  dbf7              BLT      |L2.224|
0000f0  4829              LDR      r0,|L2.408|
0000f2  6800              LDR      r0,[r0,#0]            ;1266  ; CRC16
0000f4  f24b0101          MOV      r1,#0xb001            ;1266
0000f8  4288              CMP      r0,r1                 ;1266
0000fa  d001              BEQ      |L2.256|
0000fc  20ff              MOVS     r0,#0xff              ;1267
0000fe  e78b              B        |L2.24|
                  |L2.256|
000100  f64030b8          MOV      r0,#0xbb8             ;1269
000104  f7fffffe          BL       Delay_us
000108  2400              MOVS     r4,#0                 ;1271
00010a  2500              MOVS     r5,#0                 ;1271
00010c  e009              B        |L2.290|
                  |L2.270|
00010e  5d38              LDRB     r0,[r7,r4]            ;1273
000110  f7fffffe          BL       write_byte
000114  5d38              LDRB     r0,[r7,r4]            ;1274
000116  a901              ADD      r1,sp,#4              ;1274
000118  5548              STRB     r0,[r1,r5]            ;1274
00011a  1c60              ADDS     r0,r4,#1              ;1271
00011c  b2c4              UXTB     r4,r0                 ;1271
00011e  1c68              ADDS     r0,r5,#1              ;1271
000120  b2c5              UXTB     r5,r0                 ;1271
                  |L2.290|
000122  2c20              CMP      r4,#0x20              ;1271
000124  dbf3              BLT      |L2.270|
000126  f7fffffe          BL       read_byte
00012a  4629              MOV      r1,r5                 ;1277
00012c  1c6a              ADDS     r2,r5,#1              ;1277
00012e  b2d5              UXTB     r5,r2                 ;1277
000130  aa01              ADD      r2,sp,#4              ;1277
000132  5450              STRB     r0,[r2,r1]            ;1277
000134  f7fffffe          BL       read_byte
000138  4629              MOV      r1,r5                 ;1278
00013a  1c6a              ADDS     r2,r5,#1              ;1278
00013c  b2d5              UXTB     r5,r2                 ;1278
00013e  aa01              ADD      r2,sp,#4              ;1278
000140  5450              STRB     r0,[r2,r1]            ;1278
000142  2000              MOVS     r0,#0                 ;1281
000144  4914              LDR      r1,|L2.408|
000146  6008              STR      r0,[r1,#0]            ;1281  ; CRC16
000148  2400              MOVS     r4,#0                 ;1282
00014a  e005              B        |L2.344|
                  |L2.332|
00014c  a901              ADD      r1,sp,#4              ;1282
00014e  5d08              LDRB     r0,[r1,r4]            ;1282
000150  f7fffffe          BL       docrc16
000154  1c60              ADDS     r0,r4,#1              ;1282
000156  b2c4              UXTB     r4,r0                 ;1282
                  |L2.344|
000158  42ac              CMP      r4,r5                 ;1282
00015a  dbf7              BLT      |L2.332|
00015c  480e              LDR      r0,|L2.408|
00015e  6800              LDR      r0,[r0,#0]            ;1283  ; CRC16
000160  f24b0101          MOV      r1,#0xb001            ;1283
000164  4288              CMP      r0,r1                 ;1283
000166  d001              BEQ      |L2.364|
000168  20ff              MOVS     r0,#0xff              ;1284
00016a  e755              B        |L2.24|
                  |L2.364|
00016c  f7fffffe          BL       read_byte
000170  4680              MOV      r8,r0                 ;1286
000172  f1b80faa          CMP      r8,#0xaa              ;1287
000176  d001              BEQ      |L2.380|
000178  4640              MOV      r0,r8                 ;1288
00017a  e74d              B        |L2.24|
                  |L2.380|
00017c  20aa              MOVS     r0,#0xaa              ;1291
00017e  f7fffffe          BL       write_byte
000182  f2427010          MOV      r0,#0x2710            ;1292
000186  f7fffffe          BL       Delay_us
00018a  f7fffffe          BL       read_byte
00018e  4680              MOV      r8,r0                 ;1293
000190  f7fffffe          BL       ow_reset
000194  4640              MOV      r0,r8                 ;1295
000196  e73f              B        |L2.24|
;;;1297   
                          ENDP

                  |L2.408|
                          DCD      CRC16

                          AREA ||i.AuthenticatedWriteNewData||, CODE, READONLY, ALIGN=2

                  AuthenticatedWriteNewData PROC
;;;1311   
;;;1312   unsigned char AuthenticatedWriteNewData(unsigned char Segment ,unsigned char Page, unsigned char *Bufferdata)
000000  b570              PUSH     {r4-r6,lr}
;;;1313   
;;;1314   {
000002  b092              SUB      sp,sp,#0x48
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;1315     unsigned char buffer[32],Mac_value[32],newdata[4];
;;;1316     segmentindex=Segment;pageindex=Page;
00000a  4818              LDR      r0,|L3.108|
00000c  7005              STRB     r5,[r0,#0]
00000e  4818              LDR      r0,|L3.112|
000010  7004              STRB     r4,[r0,#0]
;;;1317     memcpy_clf(newdata,Bufferdata,4);
000012  2204              MOVS     r2,#4
000014  4631              MOV      r1,r6
000016  a801              ADD      r0,sp,#4
000018  f7fffffe          BL       memcpy_clf
;;;1318     ReadMemory(Segment, Page,buffer);
00001c  aa0a              ADD      r2,sp,#0x28
00001e  4621              MOV      r1,r4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       ReadMemory
;;;1319     memcpy_clf(&MAC_Computer_Datainput[32],RomID_Buffer,32);
000026  2220              MOVS     r2,#0x20
000028  4912              LDR      r1,|L3.116|
00002a  4813              LDR      r0,|L3.120|
00002c  f7fffffe          BL       memcpy_clf
;;;1320     memcpy_clf(&MAC_Computer_Datainput[40],&Personality_Value[2],2);
000030  2202              MOVS     r2,#2
000032  4912              LDR      r1,|L3.124|
000034  4810              LDR      r0,|L3.120|
000036  3008              ADDS     r0,r0,#8
000038  f7fffffe          BL       memcpy_clf
;;;1321     MAC_Computer_Datainput[42]=Page&0x01;
00003c  f0040001          AND      r0,r4,#1
000040  490d              LDR      r1,|L3.120|
000042  3920              SUBS     r1,r1,#0x20
000044  f881002a          STRB     r0,[r1,#0x2a]
;;;1322     memcpy(&(MAC_Computer_Datainput[44]),buffer,4);
000048  4608              MOV      r0,r1
00004a  990a              LDR      r1,[sp,#0x28]
00004c  62c1              STR      r1,[r0,#0x2c]  ; MAC_Computer_Datainput
;;;1323     memcpy(&MAC_Computer_Datainput[48],newdata,4);
00004e  9901              LDR      r1,[sp,#4]
000050  6301              STR      r1,[r0,#0x30]  ; MAC_Computer_Datainput
;;;1324     ComputeMAC256(MAC_Computer_Datainput, 55, Mac_value);
000052  aa02              ADD      r2,sp,#8
000054  2137              MOVS     r1,#0x37
000056  f7fffffe          BL       ComputeMAC256
;;;1325     return(AuthenticatedWriteMemory(segmentindex,segmentindex,newdata,Mac_value));
00005a  ab02              ADD      r3,sp,#8
00005c  aa01              ADD      r2,sp,#4
00005e  4803              LDR      r0,|L3.108|
000060  7801              LDRB     r1,[r0,#0]  ; segmentindex
000062  7800              LDRB     r0,[r0,#0]  ; segmentindex
000064  f7fffffe          BL       AuthenticatedWriteMemory
;;;1326     
;;;1327     
;;;1328   }
000068  b012              ADD      sp,sp,#0x48
00006a  bd70              POP      {r4-r6,pc}
;;;1329   
                          ENDP

                  |L3.108|
                          DCD      segmentindex
                  |L3.112|
                          DCD      pageindex
                  |L3.116|
                          DCD      RomID_Buffer
                  |L3.120|
                          DCD      MAC_Computer_Datainput+0x20
                  |L3.124|
                          DCD      Personality_Value+0x2

                          AREA ||i.CalculateNextSecret256||, CODE, READONLY, ALIGN=2

                  CalculateNextSecret256 PROC
;;;1451   */
;;;1452   void  CalculateNextSecret256(unsigned char* binding, unsigned char* partial, int page_num, unsigned char* manid)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1453   {
000002  b0b1              SUB      sp,sp,#0xc4
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;1454      unsigned char MT[128];
;;;1455      unsigned char MAC[64];
;;;1456   
;;;1457      // clear 
;;;1458      memset_clf(MT,0,128);
00000c  2280              MOVS     r2,#0x80
00000e  2100              MOVS     r1,#0
000010  a811              ADD      r0,sp,#0x44
000012  f7fffffe          BL       memset_clf
;;;1459   
;;;1460      // insert page data
;;;1461      memcpy_clf(&MT[0],binding,32);
000016  2220              MOVS     r2,#0x20
000018  4629              MOV      r1,r5
00001a  a811              ADD      r0,sp,#0x44
00001c  f7fffffe          BL       memcpy_clf
;;;1462   
;;;1463      // insert challenge
;;;1464      memcpy(&MT[32],partial,32);
000020  2220              MOVS     r2,#0x20
000022  4639              MOV      r1,r7
000024  a819              ADD      r0,sp,#0x64
000026  f7fffffe          BL       __aeabi_memcpy
;;;1465   
;;;1466      // insert ROM number or FF
;;;1467      memcpy(&MT[96],RomID_Buffer,8);
00002a  490b              LDR      r1,|L4.88|
00002c  c903              LDM      r1,{r0,r1}
00002e  e9cd0129          STRD     r0,r1,[sp,#0xa4]
;;;1468   
;;;1469      MT[106] = page_num;
000032  b2f0              UXTB     r0,r6
000034  f88d00ae          STRB     r0,[sp,#0xae]
;;;1470      MT[105] = manid[0];
000038  7820              LDRB     r0,[r4,#0]
00003a  f88d00ad          STRB     r0,[sp,#0xad]
;;;1471      MT[104] = manid[1];
00003e  7860              LDRB     r0,[r4,#1]
000040  f88d00ac          STRB     r0,[sp,#0xac]
;;;1472   
;;;1473      ComputeMAC256(MT, 119, MAC);
000044  aa01              ADD      r2,sp,#4
000046  2177              MOVS     r1,#0x77
000048  a811              ADD      r0,sp,#0x44
00004a  f7fffffe          BL       ComputeMAC256
;;;1474   
;;;1475      // set the new secret to the first 32 bytes of MAC
;;;1476      set_secret(MAC);
00004e  a801              ADD      r0,sp,#4
000050  f7fffffe          BL       set_secret
;;;1477   
;;;1478   }
000054  b031              ADD      sp,sp,#0xc4
000056  bdf0              POP      {r4-r7,pc}
;;;1479   
                          ENDP

                  |L4.88|
                          DCD      RomID_Buffer

                          AREA ||i.ComputeAndLock_Secret||, CODE, READONLY, ALIGN=2

                  ComputeAndLock_Secret PROC
;;;1109   
;;;1110   unsigned char ComputeAndLock_Secret(unsigned char PageNum, bool LockEnable)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1111   
;;;1112   {
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;1113       unsigned char pbuf[20],cnt=0,i,outcome;
00000a  2500              MOVS     r5,#0
;;;1114       if ( (ow_reset())!=0 ) return 0;
00000c  f7fffffe          BL       ow_reset
000010  b118              CBZ      r0,|L5.26|
000012  2000              MOVS     r0,#0
                  |L5.20|
;;;1115       write_byte(0xCC);		                                       //Skip ROM command
;;;1116       
;;;1117          /* construct a packet to send */
;;;1118       pbuf[cnt++] = ComputeAndLockSecret_Command;                        // Read Memory Block Status or PersonalityByteindicator
;;;1119       pbuf[cnt++]= LockEnable? (PageNum|0xE0):(PageNum);
;;;1120       
;;;1121        /* Send Data */
;;;1122       for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;1123       
;;;1124         /* Receive CRC */
;;;1125       pbuf[cnt++]=read_byte();
;;;1126       pbuf[cnt++]=read_byte();
;;;1127       
;;;1128       /* calculate the CRC over this part */
;;;1129         CRC16 = 0;
;;;1130         for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;1131         if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;1132         return 0xFF;
;;;1133         
;;;1134          /* Send Release Byte */
;;;1135          write_byte(0xAA); 
;;;1136          Delay_us(6000);                                   //Wait for 2 times for SHA-256 Calculation; 
;;;1137          for(i=0 ;i<10;i++)                               //Waiting for 100ms for Secreting Loading
;;;1138          Delay_us(10000);
;;;1139     
;;;1140          outcome=read_byte();
;;;1141          ow_reset();
;;;1142          return outcome;
;;;1143    }
000014  b006              ADD      sp,sp,#0x18
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L5.26|
00001a  20cc              MOVS     r0,#0xcc              ;1115
00001c  f7fffffe          BL       write_byte
000020  223c              MOVS     r2,#0x3c              ;1118
000022  4629              MOV      r1,r5                 ;1118
000024  1c68              ADDS     r0,r5,#1              ;1118
000026  b2c5              UXTB     r5,r0                 ;1118
000028  a801              ADD      r0,sp,#4              ;1118
00002a  5442              STRB     r2,[r0,r1]            ;1118
00002c  b117              CBZ      r7,|L5.52|
00002e  f04600e0          ORR      r0,r6,#0xe0           ;1119
000032  e000              B        |L5.54|
                  |L5.52|
000034  4630              MOV      r0,r6                 ;1119
                  |L5.54|
000036  4629              MOV      r1,r5                 ;1119
000038  1c6a              ADDS     r2,r5,#1              ;1119
00003a  b2d5              UXTB     r5,r2                 ;1119
00003c  aa01              ADD      r2,sp,#4              ;1119
00003e  5450              STRB     r0,[r2,r1]            ;1119
000040  2400              MOVS     r4,#0                 ;1122
000042  e005              B        |L5.80|
                  |L5.68|
000044  a901              ADD      r1,sp,#4              ;1122
000046  5d08              LDRB     r0,[r1,r4]            ;1122
000048  f7fffffe          BL       write_byte
00004c  1c60              ADDS     r0,r4,#1              ;1122
00004e  b2c4              UXTB     r4,r0                 ;1122
                  |L5.80|
000050  42ac              CMP      r4,r5                 ;1122
000052  dbf7              BLT      |L5.68|
000054  f7fffffe          BL       read_byte
000058  4629              MOV      r1,r5                 ;1125
00005a  1c6a              ADDS     r2,r5,#1              ;1125
00005c  b2d5              UXTB     r5,r2                 ;1125
00005e  aa01              ADD      r2,sp,#4              ;1125
000060  5450              STRB     r0,[r2,r1]            ;1125
000062  f7fffffe          BL       read_byte
000066  4629              MOV      r1,r5                 ;1126
000068  1c6a              ADDS     r2,r5,#1              ;1126
00006a  b2d5              UXTB     r5,r2                 ;1126
00006c  aa01              ADD      r2,sp,#4              ;1126
00006e  5450              STRB     r0,[r2,r1]            ;1126
000070  2000              MOVS     r0,#0                 ;1129
000072  4916              LDR      r1,|L5.204|
000074  6008              STR      r0,[r1,#0]            ;1129  ; CRC16
000076  2400              MOVS     r4,#0                 ;1130
000078  e005              B        |L5.134|
                  |L5.122|
00007a  a901              ADD      r1,sp,#4              ;1130
00007c  5d08              LDRB     r0,[r1,r4]            ;1130
00007e  f7fffffe          BL       docrc16
000082  1c60              ADDS     r0,r4,#1              ;1130
000084  b2c4              UXTB     r4,r0                 ;1130
                  |L5.134|
000086  42ac              CMP      r4,r5                 ;1130
000088  dbf7              BLT      |L5.122|
00008a  4810              LDR      r0,|L5.204|
00008c  6800              LDR      r0,[r0,#0]            ;1131  ; CRC16
00008e  f24b0101          MOV      r1,#0xb001            ;1131
000092  4288              CMP      r0,r1                 ;1131
000094  d001              BEQ      |L5.154|
000096  20ff              MOVS     r0,#0xff              ;1132
000098  e7bc              B        |L5.20|
                  |L5.154|
00009a  20aa              MOVS     r0,#0xaa              ;1135
00009c  f7fffffe          BL       write_byte
0000a0  f2417070          MOV      r0,#0x1770            ;1136
0000a4  f7fffffe          BL       Delay_us
0000a8  2400              MOVS     r4,#0                 ;1137
0000aa  e005              B        |L5.184|
                  |L5.172|
0000ac  f2427010          MOV      r0,#0x2710            ;1138
0000b0  f7fffffe          BL       Delay_us
0000b4  1c60              ADDS     r0,r4,#1              ;1137
0000b6  b2c4              UXTB     r4,r0                 ;1137
                  |L5.184|
0000b8  2c0a              CMP      r4,#0xa               ;1137
0000ba  dbf7              BLT      |L5.172|
0000bc  f7fffffe          BL       read_byte
0000c0  4680              MOV      r8,r0                 ;1140
0000c2  f7fffffe          BL       ow_reset
0000c6  4640              MOV      r0,r8                 ;1142
0000c8  e7a4              B        |L5.20|
;;;1144   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L5.204|
                          DCD      CRC16

                          AREA ||i.ComputeAndReadPageMAC||, CODE, READONLY, ALIGN=2

                  ComputeAndReadPageMAC PROC
;;;1161   
;;;1162   unsigned char ComputeAndReadPageMAC(bool Anonymous_Mode,unsigned char PageNum,unsigned char *MAC_Value)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1163   {
000004  b08d              SUB      sp,sp,#0x34
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
;;;1164     
;;;1165       unsigned char pbuf[50],cnt=0,i,outcome;
00000c  2500              MOVS     r5,#0
;;;1166       if ( (ow_reset())!=0 ) return 0;
00000e  f7fffffe          BL       ow_reset
000012  b118              CBZ      r0,|L6.28|
000014  2000              MOVS     r0,#0
                  |L6.22|
;;;1167       write_byte(0xCC);		                                       //Skip ROM command  
;;;1168       
;;;1169           /* construct a packet to send */
;;;1170       pbuf[cnt++] = ComputeAndReadPageMAC_Command;                        // Read Memory Block Status or PersonalityByteindicator
;;;1171       pbuf[cnt++]= Anonymous_Mode? (PageNum|0xE0):(PageNum);   
;;;1172       
;;;1173        /* Send Data */
;;;1174       for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;1175       
;;;1176         /* Receive CRC */
;;;1177       pbuf[cnt++]=read_byte();
;;;1178       pbuf[cnt++]=read_byte();
;;;1179       
;;;1180       /* calculate the CRC over this part */
;;;1181         CRC16 = 0;
;;;1182         for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;1183         if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;1184         return 0xFF;
;;;1185         
;;;1186         Delay_us(6000);                                   //Wait for 2 times for SHA-256 Calculation;  
;;;1187     
;;;1188         outcome=read_byte();
;;;1189         
;;;1190         for (i = 0,cnt=0 ; i < 32; i++,cnt++)
;;;1191         {
;;;1192           MAC_Value[i]=read_byte();
;;;1193           pbuf[cnt]=MAC_Value[i];
;;;1194         }
;;;1195         
;;;1196             /* Receive CRC */
;;;1197         pbuf[cnt++]=read_byte();
;;;1198         pbuf[cnt++]=read_byte();
;;;1199         
;;;1200          /* calculate the CRC over this part */
;;;1201         CRC16 = 0;
;;;1202         for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;1203         if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;1204         return 0xFF;
;;;1205         return outcome;
;;;1206         
;;;1207         
;;;1208         
;;;1209   }
000016  b00d              ADD      sp,sp,#0x34
000018  e8bd83f0          POP      {r4-r9,pc}
                  |L6.28|
00001c  20cc              MOVS     r0,#0xcc              ;1167
00001e  f7fffffe          BL       write_byte
000022  22a5              MOVS     r2,#0xa5              ;1170
000024  4628              MOV      r0,r5                 ;1170
000026  1c69              ADDS     r1,r5,#1              ;1170
000028  b2cd              UXTB     r5,r1                 ;1170
00002a  f80d2000          STRB     r2,[sp,r0]            ;1170
00002e  b117              CBZ      r7,|L6.54|
000030  f04800e0          ORR      r0,r8,#0xe0           ;1171
000034  e000              B        |L6.56|
                  |L6.54|
000036  4640              MOV      r0,r8                 ;1171
                  |L6.56|
000038  4629              MOV      r1,r5                 ;1171
00003a  1c6a              ADDS     r2,r5,#1              ;1171
00003c  b2d5              UXTB     r5,r2                 ;1171
00003e  f80d0001          STRB     r0,[sp,r1]            ;1171
000042  2400              MOVS     r4,#0                 ;1174
000044  e005              B        |L6.82|
                  |L6.70|
000046  f81d0004          LDRB     r0,[sp,r4]            ;1174
00004a  f7fffffe          BL       write_byte
00004e  1c60              ADDS     r0,r4,#1              ;1174
000050  b2c4              UXTB     r4,r0                 ;1174
                  |L6.82|
000052  42ac              CMP      r4,r5                 ;1174
000054  dbf7              BLT      |L6.70|
000056  f7fffffe          BL       read_byte
00005a  4629              MOV      r1,r5                 ;1177
00005c  1c6a              ADDS     r2,r5,#1              ;1177
00005e  b2d5              UXTB     r5,r2                 ;1177
000060  f80d0001          STRB     r0,[sp,r1]            ;1177
000064  f7fffffe          BL       read_byte
000068  4629              MOV      r1,r5                 ;1178
00006a  1c6a              ADDS     r2,r5,#1              ;1178
00006c  b2d5              UXTB     r5,r2                 ;1178
00006e  f80d0001          STRB     r0,[sp,r1]            ;1178
000072  2000              MOVS     r0,#0                 ;1181
000074  4927              LDR      r1,|L6.276|
000076  6008              STR      r0,[r1,#0]            ;1181  ; CRC16
000078  2400              MOVS     r4,#0                 ;1182
00007a  e005              B        |L6.136|
                  |L6.124|
00007c  f81d0004          LDRB     r0,[sp,r4]            ;1182
000080  f7fffffe          BL       docrc16
000084  1c60              ADDS     r0,r4,#1              ;1182
000086  b2c4              UXTB     r4,r0                 ;1182
                  |L6.136|
000088  42ac              CMP      r4,r5                 ;1182
00008a  dbf7              BLT      |L6.124|
00008c  4821              LDR      r0,|L6.276|
00008e  6800              LDR      r0,[r0,#0]            ;1183  ; CRC16
000090  f24b0101          MOV      r1,#0xb001            ;1183
000094  4288              CMP      r0,r1                 ;1183
000096  d001              BEQ      |L6.156|
000098  20ff              MOVS     r0,#0xff              ;1184
00009a  e7bc              B        |L6.22|
                  |L6.156|
00009c  f2417070          MOV      r0,#0x1770            ;1186
0000a0  f7fffffe          BL       Delay_us
0000a4  f7fffffe          BL       read_byte
0000a8  4681              MOV      r9,r0                 ;1188
0000aa  2400              MOVS     r4,#0                 ;1190
0000ac  2500              MOVS     r5,#0                 ;1190
0000ae  e009              B        |L6.196|
                  |L6.176|
0000b0  f7fffffe          BL       read_byte
0000b4  5530              STRB     r0,[r6,r4]            ;1192
0000b6  5d30              LDRB     r0,[r6,r4]            ;1193
0000b8  f80d0005          STRB     r0,[sp,r5]            ;1193
0000bc  1c60              ADDS     r0,r4,#1              ;1190
0000be  b2c4              UXTB     r4,r0                 ;1190
0000c0  1c68              ADDS     r0,r5,#1              ;1190
0000c2  b2c5              UXTB     r5,r0                 ;1190
                  |L6.196|
0000c4  2c20              CMP      r4,#0x20              ;1190
0000c6  dbf3              BLT      |L6.176|
0000c8  f7fffffe          BL       read_byte
0000cc  4629              MOV      r1,r5                 ;1197
0000ce  1c6a              ADDS     r2,r5,#1              ;1197
0000d0  b2d5              UXTB     r5,r2                 ;1197
0000d2  f80d0001          STRB     r0,[sp,r1]            ;1197
0000d6  f7fffffe          BL       read_byte
0000da  4629              MOV      r1,r5                 ;1198
0000dc  1c6a              ADDS     r2,r5,#1              ;1198
0000de  b2d5              UXTB     r5,r2                 ;1198
0000e0  f80d0001          STRB     r0,[sp,r1]            ;1198
0000e4  2000              MOVS     r0,#0                 ;1201
0000e6  490b              LDR      r1,|L6.276|
0000e8  6008              STR      r0,[r1,#0]            ;1201  ; CRC16
0000ea  2400              MOVS     r4,#0                 ;1202
0000ec  e005              B        |L6.250|
                  |L6.238|
0000ee  f81d0004          LDRB     r0,[sp,r4]            ;1202
0000f2  f7fffffe          BL       docrc16
0000f6  1c60              ADDS     r0,r4,#1              ;1202
0000f8  b2c4              UXTB     r4,r0                 ;1202
                  |L6.250|
0000fa  42ac              CMP      r4,r5                 ;1202
0000fc  dbf7              BLT      |L6.238|
0000fe  4805              LDR      r0,|L6.276|
000100  6800              LDR      r0,[r0,#0]            ;1203  ; CRC16
000102  f24b0101          MOV      r1,#0xb001            ;1203
000106  4288              CMP      r0,r1                 ;1203
000108  d001              BEQ      |L6.270|
00010a  20ff              MOVS     r0,#0xff              ;1204
00010c  e783              B        |L6.22|
                  |L6.270|
00010e  4648              MOV      r0,r9                 ;1205
000110  e781              B        |L6.22|
;;;1210   
                          ENDP

000112  0000              DCW      0x0000
                  |L6.276|
                          DCD      CRC16

                          AREA ||i.ComputeMAC256||, CODE, READONLY, ALIGN=2

                  ComputeMAC256 PROC
;;;1358   */
;;;1359   void ComputeMAC256(unsigned char *MT, short length, unsigned char *MAC)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;1360   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;1361      unsigned char i,j;  
;;;1362      unsigned char tmp[4]; 
;;;1363   
;;;1364      // check for two block format
;;;1365      if (length == 119)
00000a  f1b80f77          CMP      r8,#0x77
00000e  d12c              BNE      |L7.106|
;;;1366      {
;;;1367         // insert secret
;;;1368        memcpy_clf(&MT[64], &Secret_256bit[0], 32);
000010  2220              MOVS     r2,#0x20
000012  492c              LDR      r1,|L7.196|
000014  f1060040          ADD      r0,r6,#0x40
000018  f7fffffe          BL       memcpy_clf
;;;1369   
;;;1370         // change to little endian for A1 devices
;;;1371         if (reverse_endian)
00001c  482a              LDR      r0,|L7.200|
00001e  6800              LDR      r0,[r0,#0]  ; reverse_endian
000020  b1d8              CBZ      r0,|L7.90|
;;;1372         {
;;;1373            for (i = 0; i < 108; i+=4)
000022  2500              MOVS     r5,#0
000024  e017              B        |L7.86|
                  |L7.38|
;;;1374            {
;;;1375               for (j = 0; j < 4; j++)
000026  2400              MOVS     r4,#0
000028  e007              B        |L7.58|
                  |L7.42|
;;;1376                  tmp[3 - j] = MT[i + j];
00002a  1928              ADDS     r0,r5,r4
00002c  5c30              LDRB     r0,[r6,r0]
00002e  f1c40103          RSB      r1,r4,#3
000032  aa01              ADD      r2,sp,#4
000034  5450              STRB     r0,[r2,r1]
000036  1c60              ADDS     r0,r4,#1              ;1375
000038  b2c4              UXTB     r4,r0                 ;1375
                  |L7.58|
00003a  2c04              CMP      r4,#4                 ;1375
00003c  dbf5              BLT      |L7.42|
;;;1377         
;;;1378               for (j = 0; j < 4; j++)
00003e  2400              MOVS     r4,#0
000040  e005              B        |L7.78|
                  |L7.66|
;;;1379                  MT[i + j] = tmp[j];
000042  a801              ADD      r0,sp,#4
000044  5d00              LDRB     r0,[r0,r4]
000046  1929              ADDS     r1,r5,r4
000048  5470              STRB     r0,[r6,r1]
00004a  1c60              ADDS     r0,r4,#1              ;1378
00004c  b2c4              UXTB     r4,r0                 ;1378
                  |L7.78|
00004e  2c04              CMP      r4,#4                 ;1378
000050  dbf7              BLT      |L7.66|
000052  1d28              ADDS     r0,r5,#4              ;1373
000054  b2c5              UXTB     r5,r0                 ;1373
                  |L7.86|
000056  2d6c              CMP      r5,#0x6c              ;1373
000058  dbe5              BLT      |L7.38|
                  |L7.90|
;;;1380            }
;;;1381         }
;;;1382      
;;;1383         ComputeSHA256(MT, 119, TRUE, TRUE, MAC);
00005a  2301              MOVS     r3,#1
00005c  461a              MOV      r2,r3
00005e  2177              MOVS     r1,#0x77
000060  4630              MOV      r0,r6
000062  9700              STR      r7,[sp,#0]
000064  f7fffffe          BL       ComputeSHA256
000068  e02a              B        |L7.192|
                  |L7.106|
;;;1384      }
;;;1385      // one block format
;;;1386      else
;;;1387      {
;;;1388         // insert secret
;;;1389         memcpy_clf(&MT[0], &Secret_256bit[0], 32);
00006a  2220              MOVS     r2,#0x20
00006c  4915              LDR      r1,|L7.196|
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       memcpy_clf
;;;1390   
;;;1391         // change to little endian for A1 devices
;;;1392         if (reverse_endian)
000074  4814              LDR      r0,|L7.200|
000076  6800              LDR      r0,[r0,#0]  ; reverse_endian
000078  b1d8              CBZ      r0,|L7.178|
;;;1393         {
;;;1394            for (i = 0; i < 56; i+=4)
00007a  2500              MOVS     r5,#0
00007c  e017              B        |L7.174|
                  |L7.126|
;;;1395            {
;;;1396               for (j = 0; j < 4; j++)
00007e  2400              MOVS     r4,#0
000080  e007              B        |L7.146|
                  |L7.130|
;;;1397                  tmp[3 - j] = MT[i + j];
000082  1928              ADDS     r0,r5,r4
000084  5c30              LDRB     r0,[r6,r0]
000086  f1c40103          RSB      r1,r4,#3
00008a  aa01              ADD      r2,sp,#4
00008c  5450              STRB     r0,[r2,r1]
00008e  1c60              ADDS     r0,r4,#1              ;1396
000090  b2c4              UXTB     r4,r0                 ;1396
                  |L7.146|
000092  2c04              CMP      r4,#4                 ;1396
000094  dbf5              BLT      |L7.130|
;;;1398         
;;;1399               for (j = 0; j < 4; j++)
000096  2400              MOVS     r4,#0
000098  e005              B        |L7.166|
                  |L7.154|
;;;1400                  MT[i + j] = tmp[j];
00009a  a801              ADD      r0,sp,#4
00009c  5d00              LDRB     r0,[r0,r4]
00009e  1929              ADDS     r1,r5,r4
0000a0  5470              STRB     r0,[r6,r1]
0000a2  1c60              ADDS     r0,r4,#1              ;1399
0000a4  b2c4              UXTB     r4,r0                 ;1399
                  |L7.166|
0000a6  2c04              CMP      r4,#4                 ;1399
0000a8  dbf7              BLT      |L7.154|
0000aa  1d28              ADDS     r0,r5,#4              ;1394
0000ac  b2c5              UXTB     r5,r0                 ;1394
                  |L7.174|
0000ae  2d38              CMP      r5,#0x38              ;1394
0000b0  dbe5              BLT      |L7.126|
                  |L7.178|
;;;1401            }
;;;1402         }
;;;1403   
;;;1404         ComputeSHA256(MT, 55, TRUE, TRUE, MAC);
0000b2  2301              MOVS     r3,#1
0000b4  461a              MOV      r2,r3
0000b6  2137              MOVS     r1,#0x37
0000b8  4630              MOV      r0,r6
0000ba  9700              STR      r7,[sp,#0]
0000bc  f7fffffe          BL       ComputeSHA256
                  |L7.192|
;;;1405      }
;;;1406   
;;;1407   
;;;1408   }
0000c0  e8bd81fc          POP      {r2-r8,pc}
;;;1409   
                          ENDP

                  |L7.196|
                          DCD      Secret_256bit
                  |L7.200|
                          DCD      reverse_endian

                          AREA ||i.ComputeSHA256||, CODE, READONLY, ALIGN=2

                  ComputeSHA256 PROC
;;;1726   //
;;;1727   void ComputeSHA256(unsigned char* message, short length, ushort skipconst, ushort reverse, unsigned char* digest)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1728   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;1729      ushort bytes_per_block;
;;;1730      ushort nonpaddedlength;
;;;1731      ushort numblocks;
;;;1732      ushort i,j;
;;;1733      ulong bitlength;
;;;1734      ushort markerwritten;
;;;1735      ushort lastblock;
;;;1736   
;;;1737      ushort wordsize = 32;
00000a  f04f0a20          MOV      r10,#0x20
;;;1738   
;;;1739     
;;;1740   
;;;1741      // if wordsize is 32 bits, we need 512 bit blocks.  else 1024 bit blocks.
;;;1742      // that means 16 words are in one message.
;;;1743      bytes_per_block = 16 * (wordsize / 8);
00000e  ea4f00da          LSR      r0,r10,#3
000012  0106              LSLS     r6,r0,#4
;;;1744      // 1 byte for the '80' that follows the message, 8 or 16 bytes of length
;;;1745      nonpaddedlength = length + 1 + (wordsize/4);
000014  1c60              ADDS     r0,r4,#1
000016  eb00009a          ADD      r0,r0,r10,LSR #2
00001a  9002              STR      r0,[sp,#8]
;;;1746      numblocks = nonpaddedlength / bytes_per_block;
00001c  9802              LDR      r0,[sp,#8]
00001e  fbb0f8f6          UDIV     r8,r0,r6
;;;1747      if ((nonpaddedlength % bytes_per_block) != 0) 
000022  9802              LDR      r0,[sp,#8]
000024  fbb0f1f6          UDIV     r1,r0,r6
000028  fb060011          MLS      r0,r6,r1,r0
00002c  b108              CBZ      r0,|L8.50|
;;;1748      {
;;;1749         // then there is some remainder we need to pad
;;;1750         numblocks++;
00002e  f1080801          ADD      r8,r8,#1
                  |L8.50|
;;;1751      }
;;;1752   
;;;1753      sha_copy32(SHA_256_Initial, H32, SHA_256_INITIAL_LENGTH); 
000032  2208              MOVS     r2,#8
000034  4932              LDR      r1,|L8.256|
000036  4833              LDR      r0,|L8.260|
000038  f7fffffe          BL       sha_copy32
;;;1754   
;;;1755      bitlength = 8 * length;
00003c  ea4f09c4          LSL      r9,r4,#3
;;;1756      markerwritten = 0;
000040  2000              MOVS     r0,#0
000042  9001              STR      r0,[sp,#4]
;;;1757      // 'length' is our number of bytes remaining.
;;;1758      for (i = 0; i < numblocks; i++)
000044  2700              MOVS     r7,#0
000046  e051              B        |L8.236|
                  |L8.72|
;;;1759      {
;;;1760         if (length > bytes_per_block)
000048  42b4              CMP      r4,r6
00004a  d907              BLS      |L8.92|
;;;1761         {
;;;1762            memcpy_clf(workbuffer, message, bytes_per_block);
00004c  b2f2              UXTB     r2,r6
00004e  4629              MOV      r1,r5
000050  482d              LDR      r0,|L8.264|
000052  f7fffffe          BL       memcpy_clf
;;;1763            length -= bytes_per_block;
000056  1ba0              SUBS     r0,r4,r6
000058  b204              SXTH     r4,r0
00005a  e021              B        |L8.160|
                  |L8.92|
;;;1764         }
;;;1765         else if (length==bytes_per_block)
00005c  42b4              CMP      r4,r6
00005e  d106              BNE      |L8.110|
;;;1766         {
;;;1767            memcpy_clf(workbuffer, message, length);
000060  b2e2              UXTB     r2,r4
000062  4629              MOV      r1,r5
000064  4828              LDR      r0,|L8.264|
000066  f7fffffe          BL       memcpy_clf
;;;1768            length = 0;
00006a  2400              MOVS     r4,#0
00006c  e018              B        |L8.160|
                  |L8.110|
;;;1769         }
;;;1770         else // length is less than number of bytes in a block
;;;1771         {
;;;1772            memcpy_clf(workbuffer, message, length);
00006e  b2e2              UXTB     r2,r4
000070  4629              MOV      r1,r5
000072  4825              LDR      r0,|L8.264|
000074  f7fffffe          BL       memcpy_clf
;;;1773            // message is now used for temporary space
;;;1774            message = workbuffer + length;     
000078  4823              LDR      r0,|L8.264|
00007a  1905              ADDS     r5,r0,r4
;;;1775            if (markerwritten == 0)
00007c  9801              LDR      r0,[sp,#4]
00007e  b920              CBNZ     r0,|L8.138|
;;;1776            {
;;;1777               *message++ = 0x80;
000080  2080              MOVS     r0,#0x80
000082  f8050b01          STRB     r0,[r5],#1
;;;1778               length++;
000086  1c60              ADDS     r0,r4,#1
000088  b204              SXTH     r4,r0
                  |L8.138|
;;;1779            }
;;;1780   
;;;1781            while (length < bytes_per_block)
00008a  e004              B        |L8.150|
                  |L8.140|
;;;1782            {
;;;1783               // this loop is inserting padding, in this case all zeroes
;;;1784               *message++ = 0;
00008c  2000              MOVS     r0,#0
00008e  f8050b01          STRB     r0,[r5],#1
;;;1785               length++;
000092  1c60              ADDS     r0,r4,#1
000094  b204              SXTH     r4,r0
                  |L8.150|
000096  42b4              CMP      r4,r6                 ;1781
000098  d3f8              BCC      |L8.140|
;;;1786            }
;;;1787            length = 0;
00009a  2400              MOVS     r4,#0
;;;1788            // signify that we have already written the 80h
;;;1789            markerwritten = 1;
00009c  2001              MOVS     r0,#1
00009e  9001              STR      r0,[sp,#4]
                  |L8.160|
;;;1790         }
;;;1791   
;;;1792         // on the last block, put the bit length at the very end
;;;1793         lastblock = (i == (numblocks - 1));
0000a0  f1a80001          SUB      r0,r8,#1
0000a4  42b8              CMP      r0,r7
0000a6  d101              BNE      |L8.172|
0000a8  2001              MOVS     r0,#1
0000aa  e000              B        |L8.174|
                  |L8.172|
0000ac  2000              MOVS     r0,#0
                  |L8.174|
0000ae  9000              STR      r0,[sp,#0]
;;;1794         if (lastblock)
0000b0  9800              LDR      r0,[sp,#0]
0000b2  b170              CBZ      r0,|L8.210|
;;;1795         {
;;;1796            // point at the last byte in the block
;;;1797            message = workbuffer + bytes_per_block - 1;
0000b4  4814              LDR      r0,|L8.264|
0000b6  4430              ADD      r0,r0,r6
0000b8  1e45              SUBS     r5,r0,#1
;;;1798            for (j = 0; j < wordsize/4; j++)
0000ba  f04f0b00          MOV      r11,#0
0000be  e005              B        |L8.204|
                  |L8.192|
;;;1799            {
;;;1800               *message-- = (uchar)bitlength;
0000c0  f8059901          STRB     r9,[r5],#-1
;;;1801               bitlength = bitlength >> 8;
0000c4  ea4f2919          LSR      r9,r9,#8
0000c8  f10b0b01          ADD      r11,r11,#1            ;1798
                  |L8.204|
0000cc  ebbb0f9a          CMP      r11,r10,LSR #2        ;1798
0000d0  d3f6              BCC      |L8.192|
                  |L8.210|
;;;1802            }
;;;1803         }
;;;1804   
;;;1805         // SHA in software 
;;;1806         sha256_hashblock(workbuffer, (ushort)(lastblock && skipconst));
0000d2  9800              LDR      r0,[sp,#0]
0000d4  b118              CBZ      r0,|L8.222|
0000d6  9805              LDR      r0,[sp,#0x14]
0000d8  b108              CBZ      r0,|L8.222|
0000da  2001              MOVS     r0,#1
0000dc  e000              B        |L8.224|
                  |L8.222|
0000de  2000              MOVS     r0,#0
                  |L8.224|
0000e0  4601              MOV      r1,r0
0000e2  4809              LDR      r0,|L8.264|
0000e4  f7fffffe          BL       sha256_hashblock
;;;1807         message += bytes_per_block;
0000e8  4435              ADD      r5,r5,r6
0000ea  1c7f              ADDS     r7,r7,#1              ;1758
                  |L8.236|
0000ec  4547              CMP      r7,r8                 ;1758
0000ee  d3ab              BCC      |L8.72|
;;;1808      }
;;;1809   
;;;1810      sha_writeResult(reverse, digest);
0000f0  9910              LDR      r1,[sp,#0x40]
0000f2  9806              LDR      r0,[sp,#0x18]
0000f4  f7fffffe          BL       sha_writeResult
;;;1811   
;;;1812     
;;;1813   }
0000f8  b007              ADD      sp,sp,#0x1c
0000fa  e8bd8ff0          POP      {r4-r11,pc}
;;;1814   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L8.256|
                          DCD      H32
                  |L8.260|
                          DCD      SHA_256_Initial
                  |L8.264|
                          DCD      workbuffer

                          AREA ||i.Delay_us||, CODE, READONLY, ALIGN=1

                  Delay_us PROC
;;;1822   
;;;1823   void Delay_us(unsigned long t)
000000  e006              B        |L9.16|
                  |L9.2|
;;;1824   {
;;;1825   		uint8_t dly;
;;;1826   	  while(t)
;;;1827   		{
;;;1828   			  //for(dly=0;dly<36;dly++);
;;;1829   			  //for(dly=0;dly<9;dly++);
;;;1830   			  for(dly=0;dly<8;dly++);
000002  2100              MOVS     r1,#0
000004  e001              B        |L9.10|
                  |L9.6|
000006  1c4a              ADDS     r2,r1,#1
000008  b2d1              UXTB     r1,r2
                  |L9.10|
00000a  2908              CMP      r1,#8
00000c  dbfb              BLT      |L9.6|
;;;1831   				t--;
00000e  1e40              SUBS     r0,r0,#1
                  |L9.16|
000010  2800              CMP      r0,#0                 ;1826
000012  d1f6              BNE      |L9.2|
;;;1832   		}
;;;1833   }
000014  4770              BX       lr
;;;1834   
                          ENDP


                          AREA ||i.Load_and_LockSecret||, CODE, READONLY, ALIGN=2

                  Load_and_LockSecret PROC
;;;1031   
;;;1032   unsigned char Load_and_LockSecret(bool SecretLock_Enable)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1033   
;;;1034   {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
;;;1035     
;;;1036      unsigned char pbuf[20],cnt=0,i,outcome;
000006  2500              MOVS     r5,#0
;;;1037      
;;;1038        if ( (ow_reset())!=0 ) return 0;
000008  f7fffffe          BL       ow_reset
00000c  b110              CBZ      r0,|L10.20|
00000e  2000              MOVS     r0,#0
                  |L10.16|
;;;1039       write_byte(0xCC);		                           //Skip ROM command
;;;1040     
;;;1041      /* construct a packet to send */
;;;1042       pbuf[cnt++] = LoadAndLockSecret_Command;                        // Read Memory Block Status or PersonalityByteindicator
;;;1043       pbuf[cnt++]= SecretLock_Enable? 0xE0:0x00;
;;;1044       
;;;1045      /* Send Data */
;;;1046       for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;1047       
;;;1048       
;;;1049       
;;;1050      /* Receive CRC */
;;;1051       pbuf[cnt++]=read_byte();
;;;1052       pbuf[cnt++]=read_byte();
;;;1053       
;;;1054       /* calculate the CRC over this part */
;;;1055         CRC16 = 0;
;;;1056         for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;1057         if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;1058         return 0xFF;
;;;1059       
;;;1060       
;;;1061        /* Send Release Byte */
;;;1062          write_byte(0xAA); 
;;;1063          for(i=0 ;i<10;i++)                           //Waiting for 100ms for Secreting Loading
;;;1064          Delay_us(10000);
;;;1065          
;;;1066          outcome=read_byte();
;;;1067          ow_reset();
;;;1068          return outcome;
;;;1069    
;;;1070   }
000010  b005              ADD      sp,sp,#0x14
000012  bdf0              POP      {r4-r7,pc}
                  |L10.20|
000014  20cc              MOVS     r0,#0xcc              ;1039
000016  f7fffffe          BL       write_byte
00001a  2233              MOVS     r2,#0x33              ;1042
00001c  4628              MOV      r0,r5                 ;1042
00001e  1c69              ADDS     r1,r5,#1              ;1042
000020  b2cd              UXTB     r5,r1                 ;1042
000022  f80d2000          STRB     r2,[sp,r0]            ;1042
000026  b10e              CBZ      r6,|L10.44|
000028  22e0              MOVS     r2,#0xe0              ;1043
00002a  e000              B        |L10.46|
                  |L10.44|
00002c  2200              MOVS     r2,#0                 ;1043
                  |L10.46|
00002e  4629              MOV      r1,r5                 ;1043
000030  1c68              ADDS     r0,r5,#1              ;1043
000032  b2c5              UXTB     r5,r0                 ;1043
000034  f80d2001          STRB     r2,[sp,r1]            ;1043
000038  2400              MOVS     r4,#0                 ;1046
00003a  e005              B        |L10.72|
                  |L10.60|
00003c  f81d0004          LDRB     r0,[sp,r4]            ;1046
000040  f7fffffe          BL       write_byte
000044  1c60              ADDS     r0,r4,#1              ;1046
000046  b2c4              UXTB     r4,r0                 ;1046
                  |L10.72|
000048  42ac              CMP      r4,r5                 ;1046
00004a  dbf7              BLT      |L10.60|
00004c  f7fffffe          BL       read_byte
000050  4629              MOV      r1,r5                 ;1051
000052  1c6a              ADDS     r2,r5,#1              ;1051
000054  b2d5              UXTB     r5,r2                 ;1051
000056  f80d0001          STRB     r0,[sp,r1]            ;1051
00005a  f7fffffe          BL       read_byte
00005e  4629              MOV      r1,r5                 ;1052
000060  1c6a              ADDS     r2,r5,#1              ;1052
000062  b2d5              UXTB     r5,r2                 ;1052
000064  f80d0001          STRB     r0,[sp,r1]            ;1052
000068  2000              MOVS     r0,#0                 ;1055
00006a  4914              LDR      r1,|L10.188|
00006c  6008              STR      r0,[r1,#0]            ;1055  ; CRC16
00006e  2400              MOVS     r4,#0                 ;1056
000070  e005              B        |L10.126|
                  |L10.114|
000072  f81d0004          LDRB     r0,[sp,r4]            ;1056
000076  f7fffffe          BL       docrc16
00007a  1c60              ADDS     r0,r4,#1              ;1056
00007c  b2c4              UXTB     r4,r0                 ;1056
                  |L10.126|
00007e  42ac              CMP      r4,r5                 ;1056
000080  dbf7              BLT      |L10.114|
000082  480e              LDR      r0,|L10.188|
000084  6800              LDR      r0,[r0,#0]            ;1057  ; CRC16
000086  f24b0101          MOV      r1,#0xb001            ;1057
00008a  4288              CMP      r0,r1                 ;1057
00008c  d001              BEQ      |L10.146|
00008e  20ff              MOVS     r0,#0xff              ;1058
000090  e7be              B        |L10.16|
                  |L10.146|
000092  20aa              MOVS     r0,#0xaa              ;1062
000094  f7fffffe          BL       write_byte
000098  2400              MOVS     r4,#0                 ;1063
00009a  e005              B        |L10.168|
                  |L10.156|
00009c  f2427010          MOV      r0,#0x2710            ;1064
0000a0  f7fffffe          BL       Delay_us
0000a4  1c60              ADDS     r0,r4,#1              ;1063
0000a6  b2c4              UXTB     r4,r0                 ;1063
                  |L10.168|
0000a8  2c0a              CMP      r4,#0xa               ;1063
0000aa  dbf7              BLT      |L10.156|
0000ac  f7fffffe          BL       read_byte
0000b0  4607              MOV      r7,r0                 ;1066
0000b2  f7fffffe          BL       ow_reset
0000b6  4638              MOV      r0,r7                 ;1068
0000b8  e7aa              B        |L10.16|
;;;1071   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L10.188|
                          DCD      CRC16

                          AREA ||i.One_Wire_IO_Direction||, CODE, READONLY, ALIGN=2

                  One_Wire_IO_Direction PROC
;;;413    
;;;414    void One_Wire_IO_Direction(uint8_t t)
000000  b538              PUSH     {r3-r5,lr}
;;;415    {
000002  4604              MOV      r4,r0
;;;416    				GPIO_InitTypeDef GPIO_InitStructure;
;;;417    
;;;418    				RCC_APB2PeriphClockCmd(RCC_ALL_DS, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;419    	
;;;420    				if(t==OUTPUTDATA)
00000c  b94c              CBNZ     r4,|L11.34|
;;;421    				{
;;;422    						GPIO_InitStructure.GPIO_Pin = GPIO_PIN_DS; 
00000e  2008              MOVS     r0,#8
000010  f8ad0000          STRH     r0,[sp,#0]
;;;423    						GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;						//
000014  2010              MOVS     r0,#0x10
000016  f88d0003          STRB     r0,[sp,#3]
;;;424    						GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
00001a  2003              MOVS     r0,#3
00001c  f88d0002          STRB     r0,[sp,#2]
000020  e008              B        |L11.52|
                  |L11.34|
;;;425    				}
;;;426    				else
;;;427    				{
;;;428    						GPIO_InitStructure.GPIO_Pin = GPIO_PIN_DS; 
000022  2008              MOVS     r0,#8
000024  f8ad0000          STRH     r0,[sp,#0]
;;;429    						GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;						//
000028  2048              MOVS     r0,#0x48
00002a  f88d0003          STRB     r0,[sp,#3]
;;;430    						GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
00002e  2003              MOVS     r0,#3
000030  f88d0002          STRB     r0,[sp,#2]
                  |L11.52|
;;;431    				}
;;;432    				
;;;433    				GPIO_Init(GPIO_PORT_DS, &GPIO_InitStructure);
000034  4669              MOV      r1,sp
000036  4802              LDR      r0,|L11.64|
000038  f7fffffe          BL       GPIO_Init
;;;434    }
00003c  bd38              POP      {r3-r5,pc}
;;;435    
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
                          DCD      0x40010800

                          AREA ||i.ReadBlockStatus||, CODE, READONLY, ALIGN=2

                  ReadBlockStatus PROC
;;;891    */
;;;892    unsigned char ReadBlockStatus(unsigned char BlockNum,bool PersonalityByteIndicator ,unsigned char *BlockStatus)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;893    
;;;894    {
000004  b086              SUB      sp,sp,#0x18
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
;;;895        unsigned char pbuf[20],cnt=0,i;
00000c  2400              MOVS     r4,#0
;;;896        if ( (ow_reset())!=0 ) return 0;
00000e  f7fffffe          BL       ow_reset
000012  b118              CBZ      r0,|L12.28|
000014  2000              MOVS     r0,#0
                  |L12.22|
;;;897        write_byte(0xCC);		                            //Skip ROM command
;;;898         
;;;899        
;;;900     /* construct a packet to send */
;;;901        pbuf[cnt++] = ReadStaus_Command;                        // Read Memory Block Status or PersonalityByteindicator
;;;902        pbuf[cnt++]=PersonalityByteIndicator? 0xE0:(BlockNum&0x03);
;;;903    
;;;904        
;;;905         /* Send Data */
;;;906        for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;907        
;;;908          /* Receive CRC */
;;;909          pbuf[cnt++]=read_byte();
;;;910          pbuf[cnt++]=read_byte();
;;;911        
;;;912        /* calculate the CRC over this part */
;;;913          CRC16 = 0;
;;;914          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;915          if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;916          return 0xFF;
;;;917          
;;;918          if(PersonalityByteIndicator)
;;;919          {
;;;920            
;;;921            for (cnt =0, i=0; i<4 ; i++,cnt++)
;;;922                 {
;;;923                    BlockStatus[cnt]=read_byte();
;;;924                    pbuf[cnt]=BlockStatus[cnt];  
;;;925                  } 
;;;926              
;;;927          }
;;;928          else
;;;929          {
;;;930           
;;;931               for (cnt =0, i=BlockNum; i<4 ; i++,cnt++)
;;;932                 {
;;;933                    BlockStatus[cnt]=read_byte();
;;;934                    pbuf[cnt]=BlockStatus[cnt];  
;;;935                  } 
;;;936          
;;;937          }
;;;938          /* Receive CRC */
;;;939          pbuf[cnt++]=read_byte();
;;;940          pbuf[cnt++]=read_byte();
;;;941      /* calculate the CRC over this part */
;;;942          CRC16 = 0;
;;;943          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;944          if (CRC16 != 0xB001)                           //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;945           return 0xFF;
;;;946           ow_reset();
;;;947           return 0xAA;
;;;948          
;;;949      
;;;950      
;;;951    }
000016  b006              ADD      sp,sp,#0x18
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L12.28|
00001c  20cc              MOVS     r0,#0xcc              ;897
00001e  f7fffffe          BL       write_byte
000022  22aa              MOVS     r2,#0xaa              ;901
000024  4620              MOV      r0,r4                 ;901
000026  1c61              ADDS     r1,r4,#1              ;901
000028  b2cc              UXTB     r4,r1                 ;901
00002a  a901              ADD      r1,sp,#4              ;901
00002c  540a              STRB     r2,[r1,r0]            ;901
00002e  f1b80f00          CMP      r8,#0                 ;902
000032  d001              BEQ      |L12.56|
000034  20e0              MOVS     r0,#0xe0              ;902
000036  e001              B        |L12.60|
                  |L12.56|
000038  f0070003          AND      r0,r7,#3              ;902
                  |L12.60|
00003c  4621              MOV      r1,r4                 ;902
00003e  1c62              ADDS     r2,r4,#1              ;902
000040  b2d4              UXTB     r4,r2                 ;902
000042  aa01              ADD      r2,sp,#4              ;902
000044  5450              STRB     r0,[r2,r1]            ;902
000046  2500              MOVS     r5,#0                 ;906
000048  e005              B        |L12.86|
                  |L12.74|
00004a  a901              ADD      r1,sp,#4              ;906
00004c  5d48              LDRB     r0,[r1,r5]            ;906
00004e  f7fffffe          BL       write_byte
000052  1c68              ADDS     r0,r5,#1              ;906
000054  b2c5              UXTB     r5,r0                 ;906
                  |L12.86|
000056  42a5              CMP      r5,r4                 ;906
000058  dbf7              BLT      |L12.74|
00005a  f7fffffe          BL       read_byte
00005e  4621              MOV      r1,r4                 ;909
000060  1c62              ADDS     r2,r4,#1              ;909
000062  b2d4              UXTB     r4,r2                 ;909
000064  aa01              ADD      r2,sp,#4              ;909
000066  5450              STRB     r0,[r2,r1]            ;909
000068  f7fffffe          BL       read_byte
00006c  4621              MOV      r1,r4                 ;910
00006e  1c62              ADDS     r2,r4,#1              ;910
000070  b2d4              UXTB     r4,r2                 ;910
000072  aa01              ADD      r2,sp,#4              ;910
000074  5450              STRB     r0,[r2,r1]            ;910
000076  2000              MOVS     r0,#0                 ;913
000078  492e              LDR      r1,|L12.308|
00007a  6008              STR      r0,[r1,#0]            ;913  ; CRC16
00007c  2500              MOVS     r5,#0                 ;914
00007e  e005              B        |L12.140|
                  |L12.128|
000080  a901              ADD      r1,sp,#4              ;914
000082  5d48              LDRB     r0,[r1,r5]            ;914
000084  f7fffffe          BL       docrc16
000088  1c68              ADDS     r0,r5,#1              ;914
00008a  b2c5              UXTB     r5,r0                 ;914
                  |L12.140|
00008c  42a5              CMP      r5,r4                 ;914
00008e  dbf7              BLT      |L12.128|
000090  4828              LDR      r0,|L12.308|
000092  6800              LDR      r0,[r0,#0]            ;915  ; CRC16
000094  f24b0101          MOV      r1,#0xb001            ;915
000098  4288              CMP      r0,r1                 ;915
00009a  d001              BEQ      |L12.160|
00009c  20ff              MOVS     r0,#0xff              ;916
00009e  e7ba              B        |L12.22|
                  |L12.160|
0000a0  f1b80f00          CMP      r8,#0                 ;918
0000a4  d00f              BEQ      |L12.198|
0000a6  2400              MOVS     r4,#0                 ;921
0000a8  2500              MOVS     r5,#0                 ;921
0000aa  e009              B        |L12.192|
                  |L12.172|
0000ac  f7fffffe          BL       read_byte
0000b0  5530              STRB     r0,[r6,r4]            ;923
0000b2  5d30              LDRB     r0,[r6,r4]            ;924
0000b4  a901              ADD      r1,sp,#4              ;924
0000b6  5508              STRB     r0,[r1,r4]            ;924
0000b8  1c68              ADDS     r0,r5,#1              ;921
0000ba  b2c5              UXTB     r5,r0                 ;921
0000bc  1c60              ADDS     r0,r4,#1              ;921
0000be  b2c4              UXTB     r4,r0                 ;921
                  |L12.192|
0000c0  2d04              CMP      r5,#4                 ;921
0000c2  dbf3              BLT      |L12.172|
0000c4  e00e              B        |L12.228|
                  |L12.198|
0000c6  2400              MOVS     r4,#0                 ;931
0000c8  463d              MOV      r5,r7                 ;931
0000ca  e009              B        |L12.224|
                  |L12.204|
0000cc  f7fffffe          BL       read_byte
0000d0  5530              STRB     r0,[r6,r4]            ;933
0000d2  5d30              LDRB     r0,[r6,r4]            ;934
0000d4  a901              ADD      r1,sp,#4              ;934
0000d6  5508              STRB     r0,[r1,r4]            ;934
0000d8  1c68              ADDS     r0,r5,#1              ;931
0000da  b2c5              UXTB     r5,r0                 ;931
0000dc  1c60              ADDS     r0,r4,#1              ;931
0000de  b2c4              UXTB     r4,r0                 ;931
                  |L12.224|
0000e0  2d04              CMP      r5,#4                 ;931
0000e2  dbf3              BLT      |L12.204|
                  |L12.228|
0000e4  f7fffffe          BL       read_byte
0000e8  4621              MOV      r1,r4                 ;939
0000ea  1c62              ADDS     r2,r4,#1              ;939
0000ec  b2d4              UXTB     r4,r2                 ;939
0000ee  aa01              ADD      r2,sp,#4              ;939
0000f0  5450              STRB     r0,[r2,r1]            ;939
0000f2  f7fffffe          BL       read_byte
0000f6  4621              MOV      r1,r4                 ;940
0000f8  1c62              ADDS     r2,r4,#1              ;940
0000fa  b2d4              UXTB     r4,r2                 ;940
0000fc  aa01              ADD      r2,sp,#4              ;940
0000fe  5450              STRB     r0,[r2,r1]            ;940
000100  2000              MOVS     r0,#0                 ;942
000102  490c              LDR      r1,|L12.308|
000104  6008              STR      r0,[r1,#0]            ;942  ; CRC16
000106  2500              MOVS     r5,#0                 ;943
000108  e005              B        |L12.278|
                  |L12.266|
00010a  a901              ADD      r1,sp,#4              ;943
00010c  5d48              LDRB     r0,[r1,r5]            ;943
00010e  f7fffffe          BL       docrc16
000112  1c68              ADDS     r0,r5,#1              ;943
000114  b2c5              UXTB     r5,r0                 ;943
                  |L12.278|
000116  42a5              CMP      r5,r4                 ;943
000118  dbf7              BLT      |L12.266|
00011a  4806              LDR      r0,|L12.308|
00011c  6800              LDR      r0,[r0,#0]            ;944  ; CRC16
00011e  f24b0101          MOV      r1,#0xb001            ;944
000122  4288              CMP      r0,r1                 ;944
000124  d001              BEQ      |L12.298|
000126  20ff              MOVS     r0,#0xff              ;945
000128  e775              B        |L12.22|
                  |L12.298|
00012a  f7fffffe          BL       ow_reset
00012e  20aa              MOVS     r0,#0xaa              ;947
000130  e771              B        |L12.22|
;;;952    
                          ENDP

000132  0000              DCW      0x0000
                  |L12.308|
                          DCD      CRC16

                          AREA ||i.ReadMemory||, CODE, READONLY, ALIGN=2

                  ReadMemory PROC
;;;689    
;;;690    unsigned char   ReadMemory(unsigned char Segment, unsigned char Page,unsigned char *Receive)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;691    {
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
000008  4688              MOV      r8,r1
00000a  4617              MOV      r7,r2
;;;692      unsigned char pbuf[20],cnt=0,i;
00000c  2400              MOVS     r4,#0
;;;693      if ( (ow_reset())!=0 ) return 0;
00000e  f7fffffe          BL       ow_reset
000012  b118              CBZ      r0,|L13.28|
000014  2000              MOVS     r0,#0
                  |L13.22|
;;;694        write_byte(0xCC);		                   //Skip ROM command
;;;695        /* construct a packet to send */
;;;696        pbuf[cnt++] = ReadMemory_Function;            // write WriteMemory_Function command
;;;697        pbuf[cnt++] = ((Segment<<5)|Page)&(0xE1);      // Segment and Page ,Assure Bit4~Bit1:0000
;;;698        	        
;;;699    
;;;700        /* Send Data */
;;;701        for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;702        
;;;703        /* Receive CRC */
;;;704          pbuf[cnt++]=read_byte();
;;;705          pbuf[cnt++]=read_byte();
;;;706      
;;;707            /* calculate the CRC over this part */
;;;708          CRC16 = 0;
;;;709          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);
;;;710    
;;;711         /* return result of inverted CRC */
;;;712          if (CRC16 != 0xB001)                      //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;713            return 0xFF;
;;;714      
;;;715          /* Receive DS28E15 EEPROM Data */  
;;;716          for (cnt=0, i=Segment*4 ; i<32 ;i++,cnt++)
;;;717          { 
;;;718            Receive[cnt]= read_byte();
;;;719            pbuf[cnt]= Receive[cnt];
;;;720          }
;;;721           
;;;722          
;;;723         /* Receive CRC */
;;;724          pbuf[cnt++]=read_byte();
;;;725          pbuf[cnt++]=read_byte();
;;;726          
;;;727             /* calculate the CRC over this part */
;;;728          CRC16 = 0;
;;;729          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);
;;;730           
;;;731          ow_reset();
;;;732         /* return result of inverted CRC */
;;;733          if (CRC16 != 0xB001)                      //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;734            return 0xFF;
;;;735            return 0xAA; 
;;;736                  
;;;737    }
000016  b006              ADD      sp,sp,#0x18
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L13.28|
00001c  20cc              MOVS     r0,#0xcc              ;694
00001e  f7fffffe          BL       write_byte
000022  22f0              MOVS     r2,#0xf0              ;696
000024  4620              MOV      r0,r4                 ;696
000026  1c61              ADDS     r1,r4,#1              ;696
000028  b2cc              UXTB     r4,r1                 ;696
00002a  a901              ADD      r1,sp,#4              ;696
00002c  540a              STRB     r2,[r1,r0]            ;696
00002e  ea481046          ORR      r0,r8,r6,LSL #5       ;697
000032  f00002e1          AND      r2,r0,#0xe1           ;697
000036  4620              MOV      r0,r4                 ;697
000038  1c61              ADDS     r1,r4,#1              ;697
00003a  b2cc              UXTB     r4,r1                 ;697
00003c  a901              ADD      r1,sp,#4              ;697
00003e  540a              STRB     r2,[r1,r0]            ;697
000040  2500              MOVS     r5,#0                 ;701
000042  e005              B        |L13.80|
                  |L13.68|
000044  a901              ADD      r1,sp,#4              ;701
000046  5d48              LDRB     r0,[r1,r5]            ;701
000048  f7fffffe          BL       write_byte
00004c  1c68              ADDS     r0,r5,#1              ;701
00004e  b2c5              UXTB     r5,r0                 ;701
                  |L13.80|
000050  42a5              CMP      r5,r4                 ;701
000052  dbf7              BLT      |L13.68|
000054  f7fffffe          BL       read_byte
000058  4621              MOV      r1,r4                 ;704
00005a  1c62              ADDS     r2,r4,#1              ;704
00005c  b2d4              UXTB     r4,r2                 ;704
00005e  aa01              ADD      r2,sp,#4              ;704
000060  5450              STRB     r0,[r2,r1]            ;704
000062  f7fffffe          BL       read_byte
000066  4621              MOV      r1,r4                 ;705
000068  1c62              ADDS     r2,r4,#1              ;705
00006a  b2d4              UXTB     r4,r2                 ;705
00006c  aa01              ADD      r2,sp,#4              ;705
00006e  5450              STRB     r0,[r2,r1]            ;705
000070  2000              MOVS     r0,#0                 ;708
000072  4925              LDR      r1,|L13.264|
000074  6008              STR      r0,[r1,#0]            ;708  ; CRC16
000076  2500              MOVS     r5,#0                 ;709
000078  e005              B        |L13.134|
                  |L13.122|
00007a  a901              ADD      r1,sp,#4              ;709
00007c  5d48              LDRB     r0,[r1,r5]            ;709
00007e  f7fffffe          BL       docrc16
000082  1c68              ADDS     r0,r5,#1              ;709
000084  b2c5              UXTB     r5,r0                 ;709
                  |L13.134|
000086  42a5              CMP      r5,r4                 ;709
000088  dbf7              BLT      |L13.122|
00008a  481f              LDR      r0,|L13.264|
00008c  6800              LDR      r0,[r0,#0]            ;712  ; CRC16
00008e  f24b0101          MOV      r1,#0xb001            ;712
000092  4288              CMP      r0,r1                 ;712
000094  d001              BEQ      |L13.154|
000096  20ff              MOVS     r0,#0xff              ;713
000098  e7bd              B        |L13.22|
                  |L13.154|
00009a  2400              MOVS     r4,#0                 ;716
00009c  06b0              LSLS     r0,r6,#26             ;716
00009e  0e05              LSRS     r5,r0,#24             ;716
0000a0  e009              B        |L13.182|
                  |L13.162|
0000a2  f7fffffe          BL       read_byte
0000a6  5538              STRB     r0,[r7,r4]            ;718
0000a8  5d38              LDRB     r0,[r7,r4]            ;719
0000aa  a901              ADD      r1,sp,#4              ;719
0000ac  5508              STRB     r0,[r1,r4]            ;719
0000ae  1c68              ADDS     r0,r5,#1              ;716
0000b0  b2c5              UXTB     r5,r0                 ;716
0000b2  1c60              ADDS     r0,r4,#1              ;716
0000b4  b2c4              UXTB     r4,r0                 ;716
                  |L13.182|
0000b6  2d20              CMP      r5,#0x20              ;716
0000b8  dbf3              BLT      |L13.162|
0000ba  f7fffffe          BL       read_byte
0000be  4621              MOV      r1,r4                 ;724
0000c0  1c62              ADDS     r2,r4,#1              ;724
0000c2  b2d4              UXTB     r4,r2                 ;724
0000c4  aa01              ADD      r2,sp,#4              ;724
0000c6  5450              STRB     r0,[r2,r1]            ;724
0000c8  f7fffffe          BL       read_byte
0000cc  4621              MOV      r1,r4                 ;725
0000ce  1c62              ADDS     r2,r4,#1              ;725
0000d0  b2d4              UXTB     r4,r2                 ;725
0000d2  aa01              ADD      r2,sp,#4              ;725
0000d4  5450              STRB     r0,[r2,r1]            ;725
0000d6  2000              MOVS     r0,#0                 ;728
0000d8  490b              LDR      r1,|L13.264|
0000da  6008              STR      r0,[r1,#0]            ;728  ; CRC16
0000dc  2500              MOVS     r5,#0                 ;729
0000de  e005              B        |L13.236|
                  |L13.224|
0000e0  a901              ADD      r1,sp,#4              ;729
0000e2  5d48              LDRB     r0,[r1,r5]            ;729
0000e4  f7fffffe          BL       docrc16
0000e8  1c68              ADDS     r0,r5,#1              ;729
0000ea  b2c5              UXTB     r5,r0                 ;729
                  |L13.236|
0000ec  42a5              CMP      r5,r4                 ;729
0000ee  dbf7              BLT      |L13.224|
0000f0  f7fffffe          BL       ow_reset
0000f4  4804              LDR      r0,|L13.264|
0000f6  6800              LDR      r0,[r0,#0]            ;733  ; CRC16
0000f8  f24b0101          MOV      r1,#0xb001            ;733
0000fc  4288              CMP      r0,r1                 ;733
0000fe  d001              BEQ      |L13.260|
000100  20ff              MOVS     r0,#0xff              ;734
000102  e788              B        |L13.22|
                  |L13.260|
000104  20aa              MOVS     r0,#0xaa              ;735
000106  e786              B        |L13.22|
;;;738    
                          ENDP

                  |L13.264|
                          DCD      CRC16

                          AREA ||i.ReadWriteScratchpad||, CODE, READONLY, ALIGN=2

                  ReadWriteScratchpad PROC
;;;963    
;;;964    unsigned char ReadWriteScratchpad(bool ReadMode, unsigned char *Buffer)
000000  b5f0              PUSH     {r4-r7,lr}
;;;965    {
000002  b08d              SUB      sp,sp,#0x34
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;966        unsigned char pbuf[50]/*pbuf[20]*/,cnt=0,i;
000008  2500              MOVS     r5,#0
;;;967        if ( (ow_reset())!=0 ) return 0;
00000a  f7fffffe          BL       ow_reset
00000e  b110              CBZ      r0,|L14.22|
000010  2000              MOVS     r0,#0
                  |L14.18|
;;;968        write_byte(0xCC);		                           //Skip ROM command
;;;969         
;;;970        
;;;971     /* construct a packet to send */
;;;972        pbuf[cnt++] = ReadWriteScratchPad_Command;            //  ReadWriteScratchpad command
;;;973        pbuf[cnt++]= ReadMode? 0x0F:0x00;
;;;974     
;;;975        /* Send Data */
;;;976        for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;977        
;;;978         /* Receive CRC */
;;;979          pbuf[cnt++]=read_byte();
;;;980          pbuf[cnt++]=read_byte();
;;;981        
;;;982        /* calculate the CRC over this part */
;;;983          CRC16 = 0;
;;;984          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;985          if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;986          return 0xFF;
;;;987          
;;;988          if(ReadMode)
;;;989          {
;;;990            for (i=0 ,cnt=0 ; i<32 ; cnt++,i++)
;;;991            {
;;;992             Buffer[cnt]=read_byte();
;;;993             pbuf[i]=Buffer[cnt];
;;;994            }
;;;995          }
;;;996          else
;;;997            
;;;998          {
;;;999              for (i=0 ,cnt=0 ; i<32 ; cnt++,i++)
;;;1000            {
;;;1001              write_byte(Buffer[i]);
;;;1002              pbuf[cnt]=Buffer[i];
;;;1003            }
;;;1004          }  
;;;1005            /* Receive CRC */
;;;1006         pbuf[cnt++]=read_byte();
;;;1007         pbuf[cnt++]=read_byte();
;;;1008         
;;;1009         
;;;1010         ow_reset();
;;;1011            /* calculate the CRC over this part */
;;;1012         CRC16 = 0;
;;;1013         for (i = 0; i < cnt; i++) docrc16(pbuf[i]);  
;;;1014         if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;1015         return 0xFF;
;;;1016         return 0xAA;
;;;1017        
;;;1018     
;;;1019   }
000012  b00d              ADD      sp,sp,#0x34
000014  bdf0              POP      {r4-r7,pc}
                  |L14.22|
000016  20cc              MOVS     r0,#0xcc              ;968
000018  f7fffffe          BL       write_byte
00001c  220f              MOVS     r2,#0xf               ;972
00001e  4628              MOV      r0,r5                 ;972
000020  1c69              ADDS     r1,r5,#1              ;972
000022  b2cd              UXTB     r5,r1                 ;972
000024  f80d2000          STRB     r2,[sp,r0]            ;972
000028  b107              CBZ      r7,|L14.44|
00002a  e000              B        |L14.46|
                  |L14.44|
00002c  2200              MOVS     r2,#0                 ;973
                  |L14.46|
00002e  4628              MOV      r0,r5                 ;973
000030  1c69              ADDS     r1,r5,#1              ;973
000032  b2cd              UXTB     r5,r1                 ;973
000034  f80d2000          STRB     r2,[sp,r0]            ;973
000038  2400              MOVS     r4,#0                 ;976
00003a  e005              B        |L14.72|
                  |L14.60|
00003c  f81d0004          LDRB     r0,[sp,r4]            ;976
000040  f7fffffe          BL       write_byte
000044  1c60              ADDS     r0,r4,#1              ;976
000046  b2c4              UXTB     r4,r0                 ;976
                  |L14.72|
000048  42ac              CMP      r4,r5                 ;976
00004a  dbf7              BLT      |L14.60|
00004c  f7fffffe          BL       read_byte
000050  4629              MOV      r1,r5                 ;979
000052  1c6a              ADDS     r2,r5,#1              ;979
000054  b2d5              UXTB     r5,r2                 ;979
000056  f80d0001          STRB     r0,[sp,r1]            ;979
00005a  f7fffffe          BL       read_byte
00005e  4629              MOV      r1,r5                 ;980
000060  1c6a              ADDS     r2,r5,#1              ;980
000062  b2d5              UXTB     r5,r2                 ;980
000064  f80d0001          STRB     r0,[sp,r1]            ;980
000068  2000              MOVS     r0,#0                 ;983
00006a  492d              LDR      r1,|L14.288|
00006c  6008              STR      r0,[r1,#0]            ;983  ; CRC16
00006e  2400              MOVS     r4,#0                 ;984
000070  e005              B        |L14.126|
                  |L14.114|
000072  f81d0004          LDRB     r0,[sp,r4]            ;984
000076  f7fffffe          BL       docrc16
00007a  1c60              ADDS     r0,r4,#1              ;984
00007c  b2c4              UXTB     r4,r0                 ;984
                  |L14.126|
00007e  42ac              CMP      r4,r5                 ;984
000080  dbf7              BLT      |L14.114|
000082  4827              LDR      r0,|L14.288|
000084  6800              LDR      r0,[r0,#0]            ;985  ; CRC16
000086  f24b0101          MOV      r1,#0xb001            ;985
00008a  4288              CMP      r0,r1                 ;985
00008c  d001              BEQ      |L14.146|
00008e  20ff              MOVS     r0,#0xff              ;986
000090  e7bf              B        |L14.18|
                  |L14.146|
000092  b17f              CBZ      r7,|L14.180|
000094  2400              MOVS     r4,#0                 ;990
000096  2500              MOVS     r5,#0                 ;990
000098  e009              B        |L14.174|
                  |L14.154|
00009a  f7fffffe          BL       read_byte
00009e  5570              STRB     r0,[r6,r5]            ;992
0000a0  5d70              LDRB     r0,[r6,r5]            ;993
0000a2  f80d0004          STRB     r0,[sp,r4]            ;993
0000a6  1c68              ADDS     r0,r5,#1              ;990
0000a8  b2c5              UXTB     r5,r0                 ;990
0000aa  1c60              ADDS     r0,r4,#1              ;990
0000ac  b2c4              UXTB     r4,r0                 ;990
                  |L14.174|
0000ae  2c20              CMP      r4,#0x20              ;990
0000b0  dbf3              BLT      |L14.154|
0000b2  e00e              B        |L14.210|
                  |L14.180|
0000b4  2400              MOVS     r4,#0                 ;999
0000b6  2500              MOVS     r5,#0                 ;999
0000b8  e009              B        |L14.206|
                  |L14.186|
0000ba  5d30              LDRB     r0,[r6,r4]            ;1001
0000bc  f7fffffe          BL       write_byte
0000c0  5d30              LDRB     r0,[r6,r4]            ;1002
0000c2  f80d0005          STRB     r0,[sp,r5]            ;1002
0000c6  1c68              ADDS     r0,r5,#1              ;999
0000c8  b2c5              UXTB     r5,r0                 ;999
0000ca  1c60              ADDS     r0,r4,#1              ;999
0000cc  b2c4              UXTB     r4,r0                 ;999
                  |L14.206|
0000ce  2c20              CMP      r4,#0x20              ;999
0000d0  dbf3              BLT      |L14.186|
                  |L14.210|
0000d2  f7fffffe          BL       read_byte
0000d6  4629              MOV      r1,r5                 ;1006
0000d8  1c6a              ADDS     r2,r5,#1              ;1006
0000da  b2d5              UXTB     r5,r2                 ;1006
0000dc  f80d0001          STRB     r0,[sp,r1]            ;1006
0000e0  f7fffffe          BL       read_byte
0000e4  4629              MOV      r1,r5                 ;1007
0000e6  1c6a              ADDS     r2,r5,#1              ;1007
0000e8  b2d5              UXTB     r5,r2                 ;1007
0000ea  f80d0001          STRB     r0,[sp,r1]            ;1007
0000ee  f7fffffe          BL       ow_reset
0000f2  2000              MOVS     r0,#0                 ;1012
0000f4  490a              LDR      r1,|L14.288|
0000f6  6008              STR      r0,[r1,#0]            ;1012  ; CRC16
0000f8  2400              MOVS     r4,#0                 ;1013
0000fa  e005              B        |L14.264|
                  |L14.252|
0000fc  f81d0004          LDRB     r0,[sp,r4]            ;1013
000100  f7fffffe          BL       docrc16
000104  1c60              ADDS     r0,r4,#1              ;1013
000106  b2c4              UXTB     r4,r0                 ;1013
                  |L14.264|
000108  42ac              CMP      r4,r5                 ;1013
00010a  dbf7              BLT      |L14.252|
00010c  4804              LDR      r0,|L14.288|
00010e  6800              LDR      r0,[r0,#0]            ;1014  ; CRC16
000110  f24b0101          MOV      r1,#0xb001            ;1014
000114  4288              CMP      r0,r1                 ;1014
000116  d001              BEQ      |L14.284|
000118  20ff              MOVS     r0,#0xff              ;1015
00011a  e77a              B        |L14.18|
                  |L14.284|
00011c  20aa              MOVS     r0,#0xaa              ;1016
00011e  e778              B        |L14.18|
;;;1020   
                          ENDP

                  |L14.288|
                          DCD      CRC16

                          AREA ||i.Read_RomID||, CODE, READONLY, ALIGN=2

                  Read_RomID PROC
;;;577    
;;;578    unsigned char Read_RomID(unsigned char *RomID)
000000  b570              PUSH     {r4-r6,lr}
;;;579    {
000002  4605              MOV      r5,r0
;;;580       unsigned char i;
;;;581       if ( (ow_reset())!=0 ) return 0;
000004  f7fffffe          BL       ow_reset
000008  b108              CBZ      r0,|L15.14|
00000a  2000              MOVS     r0,#0
                  |L15.12|
;;;582       write_byte(0x33);
;;;583       Delay_us(10);
;;;584       for(i = 0;i < 8;i++)
;;;585       {
;;;586          RomID[i] = read_byte();
;;;587       }
;;;588      
;;;589      
;;;590        /*CRC8 Check */
;;;591        CRC8=0;
;;;592        for(i=0;i<8;i++)
;;;593        	dowcrc(RomID[i]);     //if Receiving No  Error ,CRC =0;
;;;594        if(CRC8!=0) return 0;
;;;595        else return 1; 
;;;596       
;;;597      
;;;598    }
00000c  bd70              POP      {r4-r6,pc}
                  |L15.14|
00000e  2033              MOVS     r0,#0x33              ;582
000010  f7fffffe          BL       write_byte
000014  200a              MOVS     r0,#0xa               ;583
000016  f7fffffe          BL       Delay_us
00001a  2400              MOVS     r4,#0                 ;584
00001c  e004              B        |L15.40|
                  |L15.30|
00001e  f7fffffe          BL       read_byte
000022  5528              STRB     r0,[r5,r4]            ;586
000024  1c60              ADDS     r0,r4,#1              ;584
000026  b2c4              UXTB     r4,r0                 ;584
                  |L15.40|
000028  2c08              CMP      r4,#8                 ;584
00002a  dbf8              BLT      |L15.30|
00002c  2000              MOVS     r0,#0                 ;591
00002e  4909              LDR      r1,|L15.84|
000030  7008              STRB     r0,[r1,#0]            ;591
000032  2400              MOVS     r4,#0                 ;592
000034  e004              B        |L15.64|
                  |L15.54|
000036  5d28              LDRB     r0,[r5,r4]            ;593
000038  f7fffffe          BL       dowcrc
00003c  1c60              ADDS     r0,r4,#1              ;592
00003e  b2c4              UXTB     r4,r0                 ;592
                  |L15.64|
000040  2c08              CMP      r4,#8                 ;592
000042  dbf8              BLT      |L15.54|
000044  4803              LDR      r0,|L15.84|
000046  7800              LDRB     r0,[r0,#0]            ;594  ; CRC8
000048  b108              CBZ      r0,|L15.78|
00004a  2000              MOVS     r0,#0                 ;594
00004c  e7de              B        |L15.12|
                  |L15.78|
00004e  2001              MOVS     r0,#1                 ;595
000050  e7dc              B        |L15.12|
;;;599    
                          ENDP

000052  0000              DCW      0x0000
                  |L15.84|
                          DCD      CRC8

                          AREA ||i.SettingAndLock_Secret||, CODE, READONLY, ALIGN=2

                  SettingAndLock_Secret PROC
;;;1083   
;;;1084   unsigned char SettingAndLock_Secret(unsigned char *secret, bool LockEnable)
000000  b570              PUSH     {r4-r6,lr}
;;;1085   {   
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1086       BoolValue= LockEnable;
000006  4807              LDR      r0,|L16.36|
000008  7005              STRB     r5,[r0,#0]
;;;1087       if(ReadWriteScratchpad((bool)0,secret)!=0xAA)
00000a  4621              MOV      r1,r4
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       ReadWriteScratchpad
000012  28aa              CMP      r0,#0xaa
000014  d001              BEQ      |L16.26|
;;;1088         return 0xff;
000016  20ff              MOVS     r0,#0xff
                  |L16.24|
;;;1089       return Load_and_LockSecret(BoolValue);
;;;1090        
;;;1091   }
000018  bd70              POP      {r4-r6,pc}
                  |L16.26|
00001a  4802              LDR      r0,|L16.36|
00001c  7800              LDRB     r0,[r0,#0]            ;1089  ; BoolValue
00001e  f7fffffe          BL       Load_and_LockSecret
000022  e7f9              B        |L16.24|
;;;1092   
                          ENDP

                  |L16.36|
                          DCD      BoolValue

                          AREA ||i.TEST_28E11||, CODE, READONLY, ALIGN=2

                  TEST_28E11 PROC
;;;200    *********************************************************************************************************/
;;;201    void 	TEST_28E11(uint8_t *pDatIn,uint8_t *pDatOut)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;202    {
000004  b09a              SUB      sp,sp,#0x68
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
;;;203        unsigned char NewPageData[32] = {   0x11,0x24,0x4d,0x2a,0x43,0x29,0x4d,0x2a,
00000a  2220              MOVS     r2,#0x20
00000c  a140              ADR      r1,|L17.272|
00000e  a812              ADD      r0,sp,#0x48
000010  f7fffffe          BL       __aeabi_memcpy4
;;;204                                            0x22,0x25,0x62,0x21,0x43,0x39,0x4e,0x2b,
;;;205                                            0x33,0x26,0x4d,0x2a,0x43,0x09,0x4d,0x5e,
;;;206                                            0x44,0x27,0x5d,0x20,0x03,0x29,0x0d,0x43,
;;;207                                        };
;;;208        
;;;209        unsigned char Newupdata[8]={ 0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,};
000014  a146              ADR      r1,|L17.304|
000016  c903              LDM      r1,{r0,r1}
000018  e9cd0110          STRD     r0,r1,[sp,#0x40]
;;;210    		
;;;211        unsigned char GetPageData[32],PageNumber=0,i;
00001c  2500              MOVS     r5,#0
;;;212    		
;;;213    		unsigned char EEPROM[8],Block_Status[2];
;;;214    		unsigned char Scratch_Writebuffer[8],Scratch_Readbuffer[8],MAC_Read_Value[32];
;;;215    		unsigned char Verify_outcome;
;;;216    		
;;;217    		
;;;218        bsp_Init28E11();
00001e  f7fffffe          BL       bsp_Init28E11
;;;219    
;;;220      
;;;221       //while(1)
;;;222       {
;;;223         
;;;224    						/*test how to read 64bits ROM ID */
;;;225    						Read_RomID(RomID_Buffer);
000022  4845              LDR      r0,|L17.312|
000024  f7fffffe          BL       Read_RomID
;;;226    						
;;;227    						/*test how to read MAN_ID_L, MAN_ID_H value ,which will be used in MAC Computation */
;;;228    		        //16
;;;229    						ReadBlockStatus(0,(bool) 1 ,Personality_Value);
000028  4a44              LDR      r2,|L17.316|
00002a  2101              MOVS     r1,#1
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       ReadBlockStatus
;;;230    						
;;;231    						/*test how to read and write EEPROM   Segment0-7;*/
;;;232    		        //
;;;233    		        //2pages(32),page4blocks(8)8segment(4)
;;;234    						if( ReadMemory(Segment0, Page0,EEPROM)==0xaa)
000032  aa0e              ADD      r2,sp,#0x38
000034  2100              MOVS     r1,#0
000036  4608              MOV      r0,r1
000038  f7fffffe          BL       ReadMemory
00003c  28aa              CMP      r0,#0xaa
00003e  d10d              BNE      |L17.92|
;;;235    						{ 
;;;236    								for( i=0 ; i <8 ;i++)
000040  2400              MOVS     r4,#0
000042  e009              B        |L17.88|
                  |L17.68|
;;;237    								WriteMemory(i, Page0,&NewPageData[4*i]);
000044  a812              ADD      r0,sp,#0x48
000046  2104              MOVS     r1,#4
000048  fb010204          MLA      r2,r1,r4,r0
00004c  2100              MOVS     r1,#0
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       WriteMemory
000054  1c60              ADDS     r0,r4,#1              ;236
000056  b2c4              UXTB     r4,r0                 ;236
                  |L17.88|
000058  2c08              CMP      r4,#8                 ;236
00005a  dbf3              BLT      |L17.68|
                  |L17.92|
;;;238    						}
;;;239    												
;;;240    						/*test how to set specified Block Protecting Mode and read Block protection status */
;;;241    						//  
;;;242    					  if(ReadBlockStatus(Block0,(bool)0,Block_Status)==0xaa)
00005c  aa0d              ADD      r2,sp,#0x34
00005e  2100              MOVS     r1,#0
000060  4608              MOV      r0,r1
000062  f7fffffe          BL       ReadBlockStatus
000066  28aa              CMP      r0,#0xaa
000068  d103              BNE      |L17.114|
;;;243    					  {
;;;244    								WriteBlockProtection(Block0 ,Authentication_Protection);
00006a  2110              MOVS     r1,#0x10
00006c  2000              MOVS     r0,#0
00006e  f7fffffe          BL       WriteBlockProtection
                  |L17.114|
;;;245    					  }
;;;246    
;;;247    
;;;248    						 /*test how to read and write  Scratchpad buffer */
;;;249    						//
;;;250    						 if(ReadWriteScratchpad((bool)0, Scratch_Writebuffer)==0xaa)
000072  a90b              ADD      r1,sp,#0x2c
000074  2000              MOVS     r0,#0
000076  f7fffffe          BL       ReadWriteScratchpad
00007a  28aa              CMP      r0,#0xaa
00007c  d103              BNE      |L17.134|
;;;251    								ReadWriteScratchpad((bool)1, Scratch_Readbuffer);
00007e  a909              ADD      r1,sp,#0x24
000080  2001              MOVS     r0,#1
000082  f7fffffe          BL       ReadWriteScratchpad
                  |L17.134|
;;;252    						 
;;;253    						 /*test how to load 256bit basic secret */
;;;254    						 //
;;;255    						 SettingAndLock_Secret(Secret_256bit, (bool)0);
000086  2100              MOVS     r1,#0
000088  482d              LDR      r0,|L17.320|
00008a  f7fffffe          BL       SettingAndLock_Secret
;;;256    						 
;;;257    						 /* test how to use Computer and Lock Secret command  */
;;;258    						 //
;;;259    						 ComputeAndLock_Secret(Page1, (bool)0);
00008e  2100              MOVS     r1,#0
000090  2001              MOVS     r0,#1
000092  f7fffffe          BL       ComputeAndLock_Secret
;;;260    						 
;;;261    							
;;;262    						 /*test how to Computer and read SHA-256 MAC according to specified  page num, ROM ID ,256bits secret etc. */
;;;263    						 //(page)ROM_ID(ROM_ID0XFF),MAC()
;;;264    						 ComputeAndReadPageMAC(ANONYMOUS,Page0,MAC_Read_Value);
000096  aa01              ADD      r2,sp,#4
000098  2100              MOVS     r1,#0
00009a  2001              MOVS     r0,#1
00009c  f7fffffe          BL       ComputeAndReadPageMAC
;;;265    	
;;;266    
;;;267    //=============================================================================================================>>>>>>>						 
;;;268    						 /*test how to compare MAC value between host's computation and DS28E15's computation */
;;;269    						 //MACDS28E15MAC					
;;;270    						 // 1. firstly read MAC Value computed by DS28E15 according to Scratch value, secret ,page data ,rom id etc.
;;;271    									SettingAndLock_Secret(Secret_256bit, (bool)0);									
0000a0  2100              MOVS     r1,#0
0000a2  4827              LDR      r0,|L17.320|
0000a4  f7fffffe          BL       SettingAndLock_Secret
;;;272    									ReadWriteScratchpad((bool)0, Scratch_Writebuffer);
0000a8  a90b              ADD      r1,sp,#0x2c
0000aa  2000              MOVS     r0,#0
0000ac  f7fffffe          BL       ReadWriteScratchpad
;;;273    									ComputeAndReadPageMAC((bool) 0,Page0,MAC_Read_Value);
0000b0  aa01              ADD      r2,sp,#4
0000b2  2100              MOVS     r1,#0
0000b4  4608              MOV      r0,r1
0000b6  f7fffffe          BL       ComputeAndReadPageMAC
;;;274    							 
;;;275    						// 2. get MAC value computed by Host according to expected secret, specified EEPROM data,ROM ID etc.
;;;276    								 if( ReadMemory(0, 0,MAC_Computer_Datainput)==0xaa) 
0000ba  4a22              LDR      r2,|L17.324|
0000bc  2100              MOVS     r1,#0
0000be  4608              MOV      r0,r1
0000c0  f7fffffe          BL       ReadMemory
0000c4  28aa              CMP      r0,#0xaa
0000c6  d120              BNE      |L17.266|
;;;277    								{
;;;278    							 
;;;279    									ReadWriteScratchpad((bool)0, Scratch_Writebuffer); 
0000c8  a90b              ADD      r1,sp,#0x2c
0000ca  2000              MOVS     r0,#0
0000cc  f7fffffe          BL       ReadWriteScratchpad
;;;280    									memcpy_clf(&MAC_Computer_Datainput[32],Scratch_Writebuffer,32);
0000d0  2220              MOVS     r2,#0x20
0000d2  a90b              ADD      r1,sp,#0x2c
0000d4  481b              LDR      r0,|L17.324|
0000d6  3020              ADDS     r0,r0,#0x20
0000d8  f7fffffe          BL       memcpy_clf
;;;281    									memcpy_clf(&MAC_Computer_Datainput[96],RomID_Buffer,8);
0000dc  2208              MOVS     r2,#8
0000de  4916              LDR      r1,|L17.312|
0000e0  4818              LDR      r0,|L17.324|
0000e2  3060              ADDS     r0,r0,#0x60
0000e4  f7fffffe          BL       memcpy_clf
;;;282    									memcpy_clf(&MAC_Computer_Datainput[104],&Personality_Value[2],2);
0000e8  2202              MOVS     r2,#2
0000ea  4914              LDR      r1,|L17.316|
0000ec  1c89              ADDS     r1,r1,#2
0000ee  4815              LDR      r0,|L17.324|
0000f0  3068              ADDS     r0,r0,#0x68
0000f2  f7fffffe          BL       memcpy_clf
;;;283    									MAC_Computer_Datainput[106]=0x00;
0000f6  2000              MOVS     r0,#0
0000f8  4912              LDR      r1,|L17.324|
0000fa  f881006a          STRB     r0,[r1,#0x6a]
;;;284    								
;;;285    							// 3. compare MAC value between host's computation and DS28E15's computation; if matchs, Verify_outcome=0x01; 
;;;286    								 Verify_outcome=VerifyMAC256(MAC_Computer_Datainput, 119, MAC_Read_Value);
0000fe  aa01              ADD      r2,sp,#4
000100  2177              MOVS     r1,#0x77
000102  4810              LDR      r0,|L17.324|
000104  f7fffffe          BL       VerifyMAC256
000108  4606              MOV      r6,r0
                  |L17.266|
;;;287    							 
;;;288    								 }
;;;289    //======================================================================================================<<<<<<<<<<<
;;;290    
;;;291    
;;;292    //==================================================================================================================		
;;;293    #if 0								 
;;;294    							/* test how to update EEPROM data which is alreday in authenticated protection */							
;;;295    							//1. Set Block0 in Authenticated protection 
;;;296    							if(ReadBlockStatus(Block0,(bool)0 ,Block_Status)==0xaa)
;;;297    							WriteBlockProtection(Block0 ,Authentication_Protection);						
;;;298    							//2. WriteMemory should be failure because Block0 is in authenticated protection 
;;;299    							for( i=0 ; i <4 ;i++)
;;;300    							WriteMemory(i, Page0,&NewPageData[4*i]);				
;;;301    							//3. Using Authenticate write EEPROM  command to update EEPROM  should be OK, provided MAC is right 
;;;302    							AuthenticatedWriteNewData(Segment0 ,Page0, Newupdata);
;;;303    #endif 
;;;304    //==================================================================================================================						
;;;305    
;;;306    //==================================================================================================================	
;;;307    #if 0							
;;;308    							 /* test how to complete  Authenticate Protection Setting*/
;;;309    							 //1. Set block0 read protection should be failure,beacuse Block0 is already Authenticated protection
;;;310    							 if(ReadBlockStatus(Block0,0 ,Block_Status)==0xaa)
;;;311    								WriteBlockProtection(Block0 ,Read_Protection);							 
;;;312    							 //2. Using AuthenticatedWriteBlockProtection to set Block0 reading protection  should be success provided MAC is right 
;;;313    							 AuthenticatedWriteBlockProtection(Block0 ,Read_Protection);
;;;314    #endif
;;;315    //===================================================================================================================      
;;;316       }
;;;317    
;;;318    
;;;319    }
00010a  b01a              ADD      sp,sp,#0x68
00010c  e8bd81f0          POP      {r4-r8,pc}
;;;320    
                          ENDP

                  |L17.272|
000110  11244d2a          DCB      17,"$$M*C)M*""%b!C9N+3&M*C\tM^D'] ",3,")\rC"
000114  43294d2a
000118  22256221
00011c  43394e2b
000120  33264d2a
000124  43094d5e
000128  44275d20
00012c  03290d43
                  |L17.304|
000130  12345678          DCB      18,"4Vx",144,18,"4V"
000134  90123456
                  |L17.312|
                          DCD      RomID_Buffer
                  |L17.316|
                          DCD      Personality_Value
                  |L17.320|
                          DCD      Secret_256bit
                  |L17.324|
                          DCD      MAC_Computer_Datainput

                          AREA ||i.VerifyMAC256||, CODE, READONLY, ALIGN=1

                  VerifyMAC256 PROC
;;;1421   */
;;;1422   bool VerifyMAC256(unsigned char * MT, short length, unsigned char* compare_MAC)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1423   {
000002  b088              SUB      sp,sp,#0x20
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1424      unsigned char calc_mac[32];
;;;1425      int i;
;;;1426   
;;;1427      // calculate the MAC
;;;1428      ComputeMAC256(MT, length, calc_mac);
00000a  466a              MOV      r2,sp
00000c  4639              MOV      r1,r7
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       ComputeMAC256
;;;1429   
;;;1430      // Compare calculated mac with one read from device
;;;1431      for (i = 0; i < 32; i++)
000014  2400              MOVS     r4,#0
000016  e008              B        |L18.42|
                  |L18.24|
;;;1432      {
;;;1433         if (compare_MAC[i] != calc_mac[i])
000018  5d28              LDRB     r0,[r5,r4]
00001a  f81d1004          LDRB     r1,[sp,r4]
00001e  4288              CMP      r0,r1
000020  d002              BEQ      |L18.40|
;;;1434            return (bool)0;
000022  2000              MOVS     r0,#0
                  |L18.36|
;;;1435      }
;;;1436      return (bool)1;
;;;1437   }
000024  b008              ADD      sp,sp,#0x20
000026  bdf0              POP      {r4-r7,pc}
                  |L18.40|
000028  1c64              ADDS     r4,r4,#1              ;1431
                  |L18.42|
00002a  2c20              CMP      r4,#0x20              ;1431
00002c  dbf4              BLT      |L18.24|
00002e  2001              MOVS     r0,#1                 ;1436
000030  e7f8              B        |L18.36|
;;;1438   
                          ENDP


                          AREA ||i.WriteBlockProtection||, CODE, READONLY, ALIGN=2

                  WriteBlockProtection PROC
;;;749    */
;;;750    unsigned char WriteBlockProtection(unsigned char Block ,unsigned char ProtectOption)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;751    {
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;752        unsigned char pbuf[20],cnt=0,i,outcome;
00000a  2500              MOVS     r5,#0
;;;753        if ( (ow_reset())!=0 ) return 0;
00000c  f7fffffe          BL       ow_reset
000010  b118              CBZ      r0,|L19.26|
000012  2000              MOVS     r0,#0
                  |L19.20|
;;;754        write_byte(0xCC);		                     //Skip ROM command
;;;755         
;;;756        
;;;757     /* construct a packet to send */
;;;758        pbuf[cnt++] = WriteBlock_Protection;            // write WriteMemory_Function command
;;;759        pbuf[cnt++] = ProtectOption|Block;              // Segment and Page ,Assure Bit4~Bit1:0000
;;;760        	        
;;;761    
;;;762        /* Send Data */
;;;763        for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;764        
;;;765        /* Receive CRC */
;;;766          pbuf[cnt++]=read_byte();
;;;767          pbuf[cnt++]=read_byte();
;;;768        
;;;769        /* calculate the CRC over this part */
;;;770          CRC16 = 0;
;;;771          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);   
;;;772          if (CRC16 != 0xB001)                            //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;773           return 0xFF;
;;;774              
;;;775        /* Send Release Byte */                           // waiting for DS28E15 EEPROM programming           
;;;776           write_byte(0xAA); 
;;;777           Delay_us(10000);
;;;778           
;;;779           outcome=read_byte(); 
;;;780           ow_reset();
;;;781           return outcome;
;;;782      
;;;783      
;;;784    }
000014  b006              ADD      sp,sp,#0x18
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L19.26|
00001a  20cc              MOVS     r0,#0xcc              ;754
00001c  f7fffffe          BL       write_byte
000020  22c3              MOVS     r2,#0xc3              ;758
000022  4628              MOV      r0,r5                 ;758
000024  1c69              ADDS     r1,r5,#1              ;758
000026  b2cd              UXTB     r5,r1                 ;758
000028  a901              ADD      r1,sp,#4              ;758
00002a  540a              STRB     r2,[r1,r0]            ;758
00002c  ea470006          ORR      r0,r7,r6              ;759
000030  4629              MOV      r1,r5                 ;759
000032  1c6a              ADDS     r2,r5,#1              ;759
000034  b2d5              UXTB     r5,r2                 ;759
000036  aa01              ADD      r2,sp,#4              ;759
000038  5450              STRB     r0,[r2,r1]            ;759
00003a  2400              MOVS     r4,#0                 ;763
00003c  e005              B        |L19.74|
                  |L19.62|
00003e  a901              ADD      r1,sp,#4              ;763
000040  5d08              LDRB     r0,[r1,r4]            ;763
000042  f7fffffe          BL       write_byte
000046  1c60              ADDS     r0,r4,#1              ;763
000048  b2c4              UXTB     r4,r0                 ;763
                  |L19.74|
00004a  42ac              CMP      r4,r5                 ;763
00004c  dbf7              BLT      |L19.62|
00004e  f7fffffe          BL       read_byte
000052  4629              MOV      r1,r5                 ;766
000054  1c6a              ADDS     r2,r5,#1              ;766
000056  b2d5              UXTB     r5,r2                 ;766
000058  aa01              ADD      r2,sp,#4              ;766
00005a  5450              STRB     r0,[r2,r1]            ;766
00005c  f7fffffe          BL       read_byte
000060  4629              MOV      r1,r5                 ;767
000062  1c6a              ADDS     r2,r5,#1              ;767
000064  b2d5              UXTB     r5,r2                 ;767
000066  aa01              ADD      r2,sp,#4              ;767
000068  5450              STRB     r0,[r2,r1]            ;767
00006a  2000              MOVS     r0,#0                 ;770
00006c  4910              LDR      r1,|L19.176|
00006e  6008              STR      r0,[r1,#0]            ;770  ; CRC16
000070  2400              MOVS     r4,#0                 ;771
000072  e005              B        |L19.128|
                  |L19.116|
000074  a901              ADD      r1,sp,#4              ;771
000076  5d08              LDRB     r0,[r1,r4]            ;771
000078  f7fffffe          BL       docrc16
00007c  1c60              ADDS     r0,r4,#1              ;771
00007e  b2c4              UXTB     r4,r0                 ;771
                  |L19.128|
000080  42ac              CMP      r4,r5                 ;771
000082  dbf7              BLT      |L19.116|
000084  480a              LDR      r0,|L19.176|
000086  6800              LDR      r0,[r0,#0]            ;772  ; CRC16
000088  f24b0101          MOV      r1,#0xb001            ;772
00008c  4288              CMP      r0,r1                 ;772
00008e  d001              BEQ      |L19.148|
000090  20ff              MOVS     r0,#0xff              ;773
000092  e7bf              B        |L19.20|
                  |L19.148|
000094  20aa              MOVS     r0,#0xaa              ;776
000096  f7fffffe          BL       write_byte
00009a  f2427010          MOV      r0,#0x2710            ;777
00009e  f7fffffe          BL       Delay_us
0000a2  f7fffffe          BL       read_byte
0000a6  4680              MOV      r8,r0                 ;779
0000a8  f7fffffe          BL       ow_reset
0000ac  4640              MOV      r0,r8                 ;781
0000ae  e7b1              B        |L19.20|
;;;785    
                          ENDP

                  |L19.176|
                          DCD      CRC16

                          AREA ||i.WriteMemory||, CODE, READONLY, ALIGN=2

                  WriteMemory PROC
;;;620    
;;;621    unsigned char   WriteMemory(unsigned char Segment, unsigned char Page,unsigned char *Buffer)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;622    {
000004  b085              SUB      sp,sp,#0x14
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
;;;623        
;;;624       unsigned char pbuf[20],cnt=0,i,outcome;
00000c  2400              MOVS     r4,#0
;;;625      
;;;626    	  if ( (ow_reset())!=0 ) return 0;
00000e  f7fffffe          BL       ow_reset
000012  b118              CBZ      r0,|L20.28|
000014  2000              MOVS     r0,#0
                  |L20.22|
;;;627        write_byte(0xCC);		                   //Skip ROM command
;;;628        /* construct a packet to send */
;;;629        pbuf[cnt++] = WriteMemory_Function;            // write WriteMemory_Function command
;;;630        pbuf[cnt++] = ((Segment<<5)|Page)&(0xE1);      // Segment and Page ,Assure Bit4~Bit1:0000
;;;631        	        
;;;632    
;;;633        /* Send Data */
;;;634        for (i = 0; i < cnt; i++)  write_byte(pbuf[i]);
;;;635        
;;;636        /* Receive CRC */
;;;637          pbuf[cnt++]=read_byte();
;;;638          pbuf[cnt++]=read_byte();
;;;639    
;;;640       /* calculate the CRC over this part */
;;;641          CRC16 = 0;
;;;642          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);
;;;643    
;;;644         /* return result of inverted CRC */
;;;645          if (CRC16 != 0xB001)                     //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;646           return 0xFF;
;;;647           
;;;648          cnt=0;                                       
;;;649          /* Send Memory Data */
;;;650          for (cnt = 0; cnt < 4; cnt++) 
;;;651          {  pbuf[cnt]=Buffer[cnt];
;;;652             write_byte(Buffer[cnt]);
;;;653          }
;;;654          /* Receive CRC */
;;;655          pbuf[cnt++]=read_byte();
;;;656          pbuf[cnt++]=read_byte();
;;;657          
;;;658             /* calculate the CRC over this part */
;;;659          CRC16 = 0;
;;;660          for (i = 0; i < cnt; i++) docrc16(pbuf[i]);
;;;661    
;;;662         /* return result of inverted CRC */
;;;663          if (CRC16 != 0xB001)                      //not 0 because that the calculating result is CRC16 and the reading result is inverted CRC16
;;;664            return 0xFF;
;;;665          
;;;666         /* Send Release Byte */                    // waiting for EEPROM programming 
;;;667           write_byte(0xAA); 
;;;668           Delay_us(10000);
;;;669           
;;;670           outcome=read_byte(); 
;;;671           ow_reset();
;;;672           return outcome;
;;;673             
;;;674    }
000016  b005              ADD      sp,sp,#0x14
000018  e8bd83f0          POP      {r4-r9,pc}
                  |L20.28|
00001c  20cc              MOVS     r0,#0xcc              ;627
00001e  f7fffffe          BL       write_byte
000022  2255              MOVS     r2,#0x55              ;629
000024  4620              MOV      r0,r4                 ;629
000026  1c61              ADDS     r1,r4,#1              ;629
000028  b2cc              UXTB     r4,r1                 ;629
00002a  f80d2000          STRB     r2,[sp,r0]            ;629
00002e  ea481047          ORR      r0,r8,r7,LSL #5       ;630
000032  f00002e1          AND      r2,r0,#0xe1           ;630
000036  4620              MOV      r0,r4                 ;630
000038  1c61              ADDS     r1,r4,#1              ;630
00003a  b2cc              UXTB     r4,r1                 ;630
00003c  f80d2000          STRB     r2,[sp,r0]            ;630
000040  2500              MOVS     r5,#0                 ;634
000042  e005              B        |L20.80|
                  |L20.68|
000044  f81d0005          LDRB     r0,[sp,r5]            ;634
000048  f7fffffe          BL       write_byte
00004c  1c68              ADDS     r0,r5,#1              ;634
00004e  b2c5              UXTB     r5,r0                 ;634
                  |L20.80|
000050  42a5              CMP      r5,r4                 ;634
000052  dbf7              BLT      |L20.68|
000054  f7fffffe          BL       read_byte
000058  4621              MOV      r1,r4                 ;637
00005a  1c62              ADDS     r2,r4,#1              ;637
00005c  b2d4              UXTB     r4,r2                 ;637
00005e  f80d0001          STRB     r0,[sp,r1]            ;637
000062  f7fffffe          BL       read_byte
000066  4621              MOV      r1,r4                 ;638
000068  1c62              ADDS     r2,r4,#1              ;638
00006a  b2d4              UXTB     r4,r2                 ;638
00006c  f80d0001          STRB     r0,[sp,r1]            ;638
000070  2000              MOVS     r0,#0                 ;641
000072  4929              LDR      r1,|L20.280|
000074  6008              STR      r0,[r1,#0]            ;641  ; CRC16
000076  2500              MOVS     r5,#0                 ;642
000078  e005              B        |L20.134|
                  |L20.122|
00007a  f81d0005          LDRB     r0,[sp,r5]            ;642
00007e  f7fffffe          BL       docrc16
000082  1c68              ADDS     r0,r5,#1              ;642
000084  b2c5              UXTB     r5,r0                 ;642
                  |L20.134|
000086  42a5              CMP      r5,r4                 ;642
000088  dbf7              BLT      |L20.122|
00008a  4823              LDR      r0,|L20.280|
00008c  6800              LDR      r0,[r0,#0]            ;645  ; CRC16
00008e  f24b0101          MOV      r1,#0xb001            ;645
000092  4288              CMP      r0,r1                 ;645
000094  d001              BEQ      |L20.154|
000096  20ff              MOVS     r0,#0xff              ;646
000098  e7bd              B        |L20.22|
                  |L20.154|
00009a  2400              MOVS     r4,#0                 ;648
00009c  bf00              NOP                            ;650
00009e  e007              B        |L20.176|
                  |L20.160|
0000a0  5d30              LDRB     r0,[r6,r4]            ;651
0000a2  f80d0004          STRB     r0,[sp,r4]            ;651
0000a6  5d30              LDRB     r0,[r6,r4]            ;652
0000a8  f7fffffe          BL       write_byte
0000ac  1c60              ADDS     r0,r4,#1              ;650
0000ae  b2c4              UXTB     r4,r0                 ;650
                  |L20.176|
0000b0  2c04              CMP      r4,#4                 ;650
0000b2  dbf5              BLT      |L20.160|
0000b4  f7fffffe          BL       read_byte
0000b8  4621              MOV      r1,r4                 ;655
0000ba  1c62              ADDS     r2,r4,#1              ;655
0000bc  b2d4              UXTB     r4,r2                 ;655
0000be  f80d0001          STRB     r0,[sp,r1]            ;655
0000c2  f7fffffe          BL       read_byte
0000c6  4621              MOV      r1,r4                 ;656
0000c8  1c62              ADDS     r2,r4,#1              ;656
0000ca  b2d4              UXTB     r4,r2                 ;656
0000cc  f80d0001          STRB     r0,[sp,r1]            ;656
0000d0  2000              MOVS     r0,#0                 ;659
0000d2  4911              LDR      r1,|L20.280|
0000d4  6008              STR      r0,[r1,#0]            ;659  ; CRC16
0000d6  2500              MOVS     r5,#0                 ;660
0000d8  e005              B        |L20.230|
                  |L20.218|
0000da  f81d0005          LDRB     r0,[sp,r5]            ;660
0000de  f7fffffe          BL       docrc16
0000e2  1c68              ADDS     r0,r5,#1              ;660
0000e4  b2c5              UXTB     r5,r0                 ;660
                  |L20.230|
0000e6  42a5              CMP      r5,r4                 ;660
0000e8  dbf7              BLT      |L20.218|
0000ea  480b              LDR      r0,|L20.280|
0000ec  6800              LDR      r0,[r0,#0]            ;663  ; CRC16
0000ee  f24b0101          MOV      r1,#0xb001            ;663
0000f2  4288              CMP      r0,r1                 ;663
0000f4  d001              BEQ      |L20.250|
0000f6  20ff              MOVS     r0,#0xff              ;664
0000f8  e78d              B        |L20.22|
                  |L20.250|
0000fa  20aa              MOVS     r0,#0xaa              ;667
0000fc  f7fffffe          BL       write_byte
000100  f2427010          MOV      r0,#0x2710            ;668
000104  f7fffffe          BL       Delay_us
000108  f7fffffe          BL       read_byte
00010c  4681              MOV      r9,r0                 ;670
00010e  f7fffffe          BL       ow_reset
000112  4648              MOV      r0,r9                 ;672
000114  e77f              B        |L20.22|
;;;675    
                          ENDP

000116  0000              DCW      0x0000
                  |L20.280|
                          DCD      CRC16

                          AREA ||i.bsp_Init28E11||, CODE, READONLY, ALIGN=1

                  bsp_Init28E11 PROC
;;;330    
;;;331    void bsp_Init28E11(void)
000000  b510              PUSH     {r4,lr}
;;;332    {
;;;333    	bsp_Init28E11Hard();		/*  */
000002  f7fffffe          BL       bsp_Init28E11Hard
;;;334    	bsp_Init28E11Var();		/*  */
000006  f7fffffe          BL       bsp_Init28E11Var
;;;335    }
00000a  bd10              POP      {r4,pc}
;;;336    
                          ENDP


                          AREA ||i.bsp_Init28E11Hard||, CODE, READONLY, ALIGN=2

                  bsp_Init28E11Hard PROC
;;;345    */
;;;346    void bsp_Init28E11Hard(void)
000000  b508              PUSH     {r3,lr}
;;;347    {
;;;348    	/* */
;;;349    	GPIO_InitTypeDef GPIO_InitStructure;
;;;350    	
;;;351    	RCC_APB2PeriphClockCmd(RCC_ALL_DS, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;352    	
;;;353      GPIO_InitStructure.GPIO_Pin = GPIO_PIN_DS; 
00000a  2008              MOVS     r0,#8
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;354      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;						//
000010  2048              MOVS     r0,#0x48
000012  f88d0003          STRB     r0,[sp,#3]
;;;355      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;356      GPIO_Init(GPIO_PORT_DS, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L22.40|
000020  f7fffffe          BL       GPIO_Init
;;;357    }
000024  bd08              POP      {r3,pc}
;;;358    
                          ENDP

000026  0000              DCW      0x0000
                  |L22.40|
                          DCD      0x40010800

                          AREA ||i.bsp_Init28E11Var||, CODE, READONLY, ALIGN=1

                  bsp_Init28E11Var PROC
;;;367    */
;;;368    void bsp_Init28E11Var(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;369    {
;;;370        unsigned char i,buf[8];
;;;371    	
;;;372    	  for(i=0;i<4;i++)buf[i]=0x00;
000002  2400              MOVS     r4,#0
000004  e004              B        |L23.16|
                  |L23.6|
000006  2000              MOVS     r0,#0
000008  f80d0004          STRB     r0,[sp,r4]
00000c  1c60              ADDS     r0,r4,#1
00000e  b2c4              UXTB     r4,r0
                  |L23.16|
000010  2c04              CMP      r4,#4
000012  dbf8              BLT      |L23.6|
;;;373    		for( i=0 ; i <8 ;i++)
000014  2400              MOVS     r4,#0
000016  e006              B        |L23.38|
                  |L23.24|
;;;374    	  {
;;;375    								WriteMemory(i, Page0,&buf[0]);
000018  466a              MOV      r2,sp
00001a  2100              MOVS     r1,#0
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       WriteMemory
000022  1c60              ADDS     r0,r4,#1              ;373
000024  b2c4              UXTB     r4,r0                 ;373
                  |L23.38|
000026  2c08              CMP      r4,#8                 ;373
000028  dbf6              BLT      |L23.24|
;;;376    		}
;;;377    }
00002a  bd1c              POP      {r2-r4,pc}
;;;378    
                          ENDP


                          AREA ||i.docrc16||, CODE, READONLY, ALIGN=2

                  docrc16 PROC
;;;550    
;;;551    unsigned short docrc16(unsigned short data)
000000  4601              MOV      r1,r0
;;;552    {
;;;553       data = (data ^ (CRC16 & 0xff)) & 0xff;
000002  4818              LDR      r0,|L24.100|
000004  7800              LDRB     r0,[r0,#0]  ; CRC16
000006  4048              EORS     r0,r0,r1
000008  b2c1              UXTB     r1,r0
;;;554       CRC16 >>= 8;
00000a  4816              LDR      r0,|L24.100|
00000c  6800              LDR      r0,[r0,#0]  ; CRC16
00000e  0a00              LSRS     r0,r0,#8
000010  4a14              LDR      r2,|L24.100|
000012  6010              STR      r0,[r2,#0]  ; CRC16
;;;555    
;;;556       if (oddparity[data & 0xf] ^ oddparity[data >> 4])
000014  f001000f          AND      r0,r1,#0xf
000018  4a13              LDR      r2,|L24.104|
00001a  f9320010          LDRSH    r0,[r2,r0,LSL #1]
00001e  110a              ASRS     r2,r1,#4
000020  4b11              LDR      r3,|L24.104|
000022  f9332012          LDRSH    r2,[r3,r2,LSL #1]
000026  4050              EORS     r0,r0,r2
000028  d006              BEQ      |L24.56|
;;;557         CRC16 ^= 0xc001;
00002a  480e              LDR      r0,|L24.100|
00002c  6800              LDR      r0,[r0,#0]  ; CRC16
00002e  f24c0201          MOV      r2,#0xc001
000032  4050              EORS     r0,r0,r2
000034  4a0b              LDR      r2,|L24.100|
000036  6010              STR      r0,[r2,#0]  ; CRC16
                  |L24.56|
;;;558    
;;;559       data <<= 6;
000038  f64f70ff          MOV      r0,#0xffff
00003c  ea001181          AND      r1,r0,r1,LSL #6
;;;560       CRC16   ^= data;
000040  4808              LDR      r0,|L24.100|
000042  6800              LDR      r0,[r0,#0]  ; CRC16
000044  4048              EORS     r0,r0,r1
000046  4a07              LDR      r2,|L24.100|
000048  6010              STR      r0,[r2,#0]  ; CRC16
;;;561       data <<= 1;
00004a  f64f70ff          MOV      r0,#0xffff
00004e  ea000141          AND      r1,r0,r1,LSL #1
;;;562       CRC16   ^= data;
000052  4610              MOV      r0,r2
000054  6800              LDR      r0,[r0,#0]  ; CRC16
000056  4048              EORS     r0,r0,r1
000058  6010              STR      r0,[r2,#0]  ; CRC16
;;;563    
;;;564       return CRC16;
00005a  4610              MOV      r0,r2
00005c  8800              LDRH     r0,[r0,#0]  ; CRC16
00005e  b280              UXTH     r0,r0
;;;565    }
000060  4770              BX       lr
;;;566    
                          ENDP

000062  0000              DCW      0x0000
                  |L24.100|
                          DCD      CRC16
                  |L24.104|
                          DCD      oddparity

                          AREA ||i.dowcrc||, CODE, READONLY, ALIGN=2

                  dowcrc PROC
;;;535    
;;;536    unsigned char dowcrc(unsigned char x)
000000  4601              MOV      r1,r0
;;;537    {
;;;538       CRC8 = dscrc_table[CRC8 ^ x];
000002  4805              LDR      r0,|L25.24|
000004  7800              LDRB     r0,[r0,#0]  ; CRC8
000006  4048              EORS     r0,r0,r1
000008  4a04              LDR      r2,|L25.28|
00000a  5c10              LDRB     r0,[r2,r0]
00000c  4a02              LDR      r2,|L25.24|
00000e  7010              STRB     r0,[r2,#0]
;;;539       return CRC8;
000010  4610              MOV      r0,r2
000012  7800              LDRB     r0,[r0,#0]  ; CRC8
;;;540    }
000014  4770              BX       lr
;;;541    
                          ENDP

000016  0000              DCW      0x0000
                  |L25.24|
                          DCD      CRC8
                  |L25.28|
                          DCD      dscrc_table

                          AREA ||i.memcpy_clf||, CODE, READONLY, ALIGN=1

                  memcpy_clf PROC
;;;1834   
;;;1835   void memcpy_clf(unsigned char *p1, unsigned char *p2, unsigned char len)
000000  e005              B        |L26.14|
                  |L26.2|
;;;1836   {
;;;1837   		while(len>0)
;;;1838   		{
;;;1839   				*p1++=*p2++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
;;;1840   			  len--;
00000a  1e53              SUBS     r3,r2,#1
00000c  b2da              UXTB     r2,r3
                  |L26.14|
00000e  2a00              CMP      r2,#0                 ;1837
000010  dcf7              BGT      |L26.2|
;;;1841   		}
;;;1842   }
000012  4770              BX       lr
;;;1843   
                          ENDP


                          AREA ||i.memset_clf||, CODE, READONLY, ALIGN=1

                  memset_clf PROC
;;;1843   
;;;1844   void memset_clf(unsigned char *p1, unsigned char dat, unsigned char len)
000000  e003              B        |L27.10|
                  |L27.2|
;;;1845   {
;;;1846   		while(len>0)
;;;1847   		{
;;;1848   				*p1++=dat;
000002  f8001b01          STRB     r1,[r0],#1
;;;1849   			  len--;
000006  1e53              SUBS     r3,r2,#1
000008  b2da              UXTB     r2,r3
                  |L27.10|
00000a  2a00              CMP      r2,#0                 ;1846
00000c  dcf9              BGT      |L27.2|
;;;1850   		}
;;;1851   }
00000e  4770              BX       lr
;;;1852   
                          ENDP


                          AREA ||i.ow_reset||, CODE, READONLY, ALIGN=2

                  ow_reset PROC
;;;385    
;;;386    unsigned char ow_reset(void)
000000  b510              PUSH     {r4,lr}
;;;387    {			
;;;388    				unsigned char presence;
;;;389            One_Wire_IO_Direction(OUTPUTDATA);         	// set 1-Wire Data Pin to output
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       One_Wire_IO_Direction
;;;390           	GPIO_ResetBits(One_Wire, One_Wire_IO);       	// leave 1-Wire Data Pin low for 60us
000008  2108              MOVS     r1,#8
00000a  480d              LDR      r0,|L28.64|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;391            Delay_us(60);
000010  203c              MOVS     r0,#0x3c
000012  f7fffffe          BL       Delay_us
;;;392    				GPIO_SetBits(One_Wire, One_Wire_IO);         	// allow line to return high
000016  2108              MOVS     r1,#8
000018  4809              LDR      r0,|L28.64|
00001a  f7fffffe          BL       GPIO_SetBits
;;;393            One_Wire_IO_Direction(INPUTDATA);          	// set 1-Wire Data pin to input mode   
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       One_Wire_IO_Direction
;;;394            Delay_us(8);                                 	// wait for presence
000024  2008              MOVS     r0,#8
000026  f7fffffe          BL       Delay_us
;;;395    	
;;;396            //presence= ((One_Wire->IDR)>>8)&(0x40);
;;;397    	      presence= (unsigned char)((One_Wire->IDR)&(One_Wire_Mask));	
00002a  4805              LDR      r0,|L28.64|
00002c  3008              ADDS     r0,r0,#8
00002e  6800              LDR      r0,[r0,#0]
000030  f0000408          AND      r4,r0,#8
;;;398            Delay_us(10);
000034  200a              MOVS     r0,#0xa
000036  f7fffffe          BL       Delay_us
;;;399    //===============================================>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
;;;400    //	
;;;401    //	      One_Wire_IO_Direction(OUTPUTDATA); 
;;;402    //	      while(1)
;;;403    //				{
;;;404    //						GPIO_ResetBits(One_Wire, One_Wire_IO); 
;;;405    //					  Delay_us(1);
;;;406    //					  GPIO_SetBits(One_Wire, One_Wire_IO); 
;;;407    //					  Delay_us(1);
;;;408    //				}
;;;409    //<<<<<<<<<<<<<<<========================================================================				
;;;410    				
;;;411    				return(presence);                            	// presence signal returned
00003a  4620              MOV      r0,r4
;;;412    } 
00003c  bd10              POP      {r4,pc}
;;;413    
                          ENDP

00003e  0000              DCW      0x0000
                  |L28.64|
                          DCD      0x40010800

                          AREA ||i.read_bit||, CODE, READONLY, ALIGN=2

                  read_bit PROC
;;;440    */
;;;441    unsigned char read_bit(void)
000000  b510              PUSH     {r4,lr}
;;;442    {
;;;443    				unsigned char vamm;
;;;444            //One_Wire_IO_Direction(OUTPUTDATA); 
;;;445    				GPIOA->CRL&=0XFFFF0FFF; 
000002  4813              LDR      r0,|L29.80|
000004  6800              LDR      r0,[r0,#0]
000006  f4204070          BIC      r0,r0,#0xf000
00000a  4911              LDR      r1,|L29.80|
00000c  6008              STR      r0,[r1,#0]
;;;446    				GPIOA->CRL|=0X00003000;//PA3 
00000e  4608              MOV      r0,r1
000010  6800              LDR      r0,[r0,#0]
000012  f4405040          ORR      r0,r0,#0x3000
000016  6008              STR      r0,[r1,#0]
;;;447    	
;;;448            GPIO_ResetBits(One_Wire, One_Wire_IO);
000018  2108              MOVS     r1,#8
00001a  480d              LDR      r0,|L29.80|
00001c  f7fffffe          BL       GPIO_ResetBits
;;;449    	
;;;450            //One_Wire_IO_Direction(INPUTDATA);
;;;451    	
;;;452    	      Delay_us(1);
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       Delay_us
;;;453    	      GPIOA->CRL&=0XFFFF0FFF; 
000026  480a              LDR      r0,|L29.80|
000028  6800              LDR      r0,[r0,#0]
00002a  f4204070          BIC      r0,r0,#0xf000
00002e  4908              LDR      r1,|L29.80|
000030  6008              STR      r0,[r1,#0]
;;;454    				GPIOA->CRL|=0X00004000;//PA3 
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]
000036  f4404080          ORR      r0,r0,#0x4000
00003a  6008              STR      r0,[r1,#0]
;;;455    	
;;;456            //vamm=((One_Wire->IDR)>>8)&(0x40);
;;;457    	      vamm= (unsigned char)((One_Wire->IDR)&(One_Wire_Mask));	
00003c  4804              LDR      r0,|L29.80|
00003e  3008              ADDS     r0,r0,#8
000040  6800              LDR      r0,[r0,#0]
000042  f0000408          AND      r4,r0,#8
;;;458    				Delay_us(5);                                 //waiting for Reading slot over
000046  2005              MOVS     r0,#5
000048  f7fffffe          BL       Delay_us
;;;459    				return(vamm);                                // return value of 1-wire data pin
00004c  4620              MOV      r0,r4
;;;460    }
00004e  bd10              POP      {r4,pc}
;;;461    
                          ENDP

                  |L29.80|
                          DCD      0x40010800

                          AREA ||i.read_byte||, CODE, READONLY, ALIGN=1

                  read_byte PROC
;;;492    */
;;;493    unsigned char read_byte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;494    {
;;;495    	unsigned char i;
;;;496    	unsigned char value = 0;
000002  2500              MOVS     r5,#0
;;;497    	for (i = 0; i < 8; i++)
000004  2400              MOVS     r4,#0
000006  e008              B        |L30.26|
                  |L30.8|
;;;498    		{
;;;499    			if(read_bit()) value |= 0x01<<i;      // reads byte in, one byte at a time and then shifts it left
000008  f7fffffe          BL       read_bit
00000c  b118              CBZ      r0,|L30.22|
00000e  2001              MOVS     r0,#1
000010  40a0              LSLS     r0,r0,r4
000012  4328              ORRS     r0,r0,r5
000014  b2c5              UXTB     r5,r0
                  |L30.22|
000016  1c60              ADDS     r0,r4,#1              ;497
000018  b2c4              UXTB     r4,r0                 ;497
                  |L30.26|
00001a  2c08              CMP      r4,#8                 ;497
00001c  dbf4              BLT      |L30.8|
;;;500    			
;;;501    		}
;;;502    	return(value);
00001e  4628              MOV      r0,r5
;;;503    }
000020  bd70              POP      {r4-r6,pc}
;;;504    
                          ENDP


                          AREA ||i.set_secret||, CODE, READONLY, ALIGN=2

                  set_secret PROC
;;;1337   */
;;;1338   void set_secret(unsigned char *secret)
000000  4601              MOV      r1,r0
;;;1339   { 
;;;1340      unsigned char i;
;;;1341   
;;;1342      for (i = 0; i < 32; i++)
000002  2000              MOVS     r0,#0
000004  e004              B        |L31.16|
                  |L31.6|
;;;1343         SECRET[i] = secret[i];   
000006  5c0a              LDRB     r2,[r1,r0]
000008  4b03              LDR      r3,|L31.24|
00000a  541a              STRB     r2,[r3,r0]
00000c  1c42              ADDS     r2,r0,#1              ;1342
00000e  b2d0              UXTB     r0,r2                 ;1342
                  |L31.16|
000010  2820              CMP      r0,#0x20              ;1342
000012  dbf8              BLT      |L31.6|
;;;1344   }
000014  4770              BX       lr
;;;1345   
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      SECRET

                          AREA ||i.sha256_hashblock||, CODE, READONLY, ALIGN=2

                  sha256_hashblock PROC
;;;1644   //
;;;1645   void sha256_hashblock(unsigned char* message, ushort lastblock)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;1646   {
000004  b081              SUB      sp,sp,#4
000006  460e              MOV      r6,r1
;;;1647      ushort sha1counter = 0;
000008  2700              MOVS     r7,#0
;;;1648      ushort sha1functionselect = 0;
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;1649      ushort i;
;;;1650      unsigned long nodeT1, nodeT2;
;;;1651   
;;;1652      unsigned long Wt, Kt;
;;;1653   
;;;1654      // chunk the original message into the working schedule
;;;1655      sha_prepareSchedule(message);
00000e  9801              LDR      r0,[sp,#4]
000010  f7fffffe          BL       sha_prepareSchedule
;;;1656   
;;;1657      a32 = H32[0];
000014  4866              LDR      r0,|L32.432|
000016  6800              LDR      r0,[r0,#0]  ; H32
000018  4966              LDR      r1,|L32.436|
00001a  6008              STR      r0,[r1,#0]  ; a32
;;;1658      b32 = H32[1];
00001c  4864              LDR      r0,|L32.432|
00001e  6840              LDR      r0,[r0,#4]  ; H32
000020  4965              LDR      r1,|L32.440|
000022  6008              STR      r0,[r1,#0]  ; b32
;;;1659      c32 = H32[2];
000024  4862              LDR      r0,|L32.432|
000026  6880              LDR      r0,[r0,#8]  ; H32
000028  4964              LDR      r1,|L32.444|
00002a  6008              STR      r0,[r1,#0]  ; c32
;;;1660      d32 = H32[3];
00002c  4860              LDR      r0,|L32.432|
00002e  68c0              LDR      r0,[r0,#0xc]  ; H32
000030  4963              LDR      r1,|L32.448|
000032  6008              STR      r0,[r1,#0]  ; d32
;;;1661      e32 = H32[4];
000034  485e              LDR      r0,|L32.432|
000036  6900              LDR      r0,[r0,#0x10]  ; H32
000038  4962              LDR      r1,|L32.452|
00003a  6008              STR      r0,[r1,#0]  ; e32
;;;1662      f32 = H32[5];
00003c  485c              LDR      r0,|L32.432|
00003e  6940              LDR      r0,[r0,#0x14]  ; H32
000040  4961              LDR      r1,|L32.456|
000042  6008              STR      r0,[r1,#0]  ; f32
;;;1663      g32 = H32[6];
000044  485a              LDR      r0,|L32.432|
000046  6980              LDR      r0,[r0,#0x18]  ; H32
000048  4960              LDR      r1,|L32.460|
00004a  6008              STR      r0,[r1,#0]  ; g32
;;;1664      h32 = H32[7];
00004c  4858              LDR      r0,|L32.432|
00004e  69c0              LDR      r0,[r0,#0x1c]  ; H32
000050  495f              LDR      r1,|L32.464|
000052  6008              STR      r0,[r1,#0]  ; h32
;;;1665   
;;;1666      // rounds
;;;1667      for (i = 0; i < 64; i++)
000054  2400              MOVS     r4,#0
000056  e052              B        |L32.254|
                  |L32.88|
;;;1668      {
;;;1669         Wt = sha_getW(i);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       sha_getW
00005e  4682              MOV      r10,r0
;;;1670         Kt = SHA_CONSTANTS[i]; 
000060  485c              LDR      r0,|L32.468|
000062  f8509024          LDR      r9,[r0,r4,LSL #2]
;;;1671   
;;;1672         nodeT1 = (h32 + sha_bigsigma256_1(e32) + sha_ch(e32,f32,g32) + Kt + Wt); // & 0xFFFFFFFFL;
000066  4857              LDR      r0,|L32.452|
000068  6800              LDR      r0,[r0,#0]  ; e32
00006a  f7fffffe          BL       sha_bigsigma256_1
00006e  4958              LDR      r1,|L32.464|
000070  6809              LDR      r1,[r1,#0]  ; h32
000072  eb000b01          ADD      r11,r0,r1
000076  4855              LDR      r0,|L32.460|
000078  6802              LDR      r2,[r0,#0]  ; g32
00007a  4853              LDR      r0,|L32.456|
00007c  6801              LDR      r1,[r0,#0]  ; f32
00007e  4851              LDR      r0,|L32.452|
000080  6800              LDR      r0,[r0,#0]  ; e32
000082  f7fffffe          BL       sha_ch
000086  4458              ADD      r0,r0,r11
000088  4448              ADD      r0,r0,r9
00008a  eb00050a          ADD      r5,r0,r10
;;;1673         nodeT2 = (sha_bigsigma256_0(a32) + sha_maj(a32,b32,c32)); // & 0xFFFFFFFFL;
00008e  4849              LDR      r0,|L32.436|
000090  6800              LDR      r0,[r0,#0]  ; a32
000092  f7fffffe          BL       sha_bigsigma256_0
000096  4683              MOV      r11,r0
000098  4848              LDR      r0,|L32.444|
00009a  6802              LDR      r2,[r0,#0]  ; c32
00009c  4846              LDR      r0,|L32.440|
00009e  6801              LDR      r1,[r0,#0]  ; b32
0000a0  4844              LDR      r0,|L32.436|
0000a2  6800              LDR      r0,[r0,#0]  ; a32
0000a4  f7fffffe          BL       sha_maj
0000a8  eb0b0800          ADD      r8,r11,r0
;;;1674         h32 = g32;
0000ac  4847              LDR      r0,|L32.460|
0000ae  6800              LDR      r0,[r0,#0]  ; g32
0000b0  4947              LDR      r1,|L32.464|
0000b2  6008              STR      r0,[r1,#0]  ; h32
;;;1675         g32 = f32;
0000b4  4844              LDR      r0,|L32.456|
0000b6  6800              LDR      r0,[r0,#0]  ; f32
0000b8  4944              LDR      r1,|L32.460|
0000ba  6008              STR      r0,[r1,#0]  ; g32
;;;1676         f32 = e32;
0000bc  4841              LDR      r0,|L32.452|
0000be  6800              LDR      r0,[r0,#0]  ; e32
0000c0  4941              LDR      r1,|L32.456|
0000c2  6008              STR      r0,[r1,#0]  ; f32
;;;1677         e32 = d32 + nodeT1;
0000c4  483e              LDR      r0,|L32.448|
0000c6  6800              LDR      r0,[r0,#0]  ; d32
0000c8  4428              ADD      r0,r0,r5
0000ca  493e              LDR      r1,|L32.452|
0000cc  6008              STR      r0,[r1,#0]  ; e32
;;;1678         d32 = c32;
0000ce  483b              LDR      r0,|L32.444|
0000d0  6800              LDR      r0,[r0,#0]  ; c32
0000d2  493b              LDR      r1,|L32.448|
0000d4  6008              STR      r0,[r1,#0]  ; d32
;;;1679         c32 = b32;
0000d6  4838              LDR      r0,|L32.440|
0000d8  6800              LDR      r0,[r0,#0]  ; b32
0000da  4938              LDR      r1,|L32.444|
0000dc  6008              STR      r0,[r1,#0]  ; c32
;;;1680         b32 = a32;
0000de  4835              LDR      r0,|L32.436|
0000e0  6800              LDR      r0,[r0,#0]  ; a32
0000e2  4935              LDR      r1,|L32.440|
0000e4  6008              STR      r0,[r1,#0]  ; b32
;;;1681         a32 = nodeT1 + nodeT2;
0000e6  eb050008          ADD      r0,r5,r8
0000ea  4932              LDR      r1,|L32.436|
0000ec  6008              STR      r0,[r1,#0]  ; a32
;;;1682   
;;;1683         sha1counter++;
0000ee  1c7f              ADDS     r7,r7,#1
;;;1684         if (sha1counter==20)
0000f0  2f14              CMP      r7,#0x14
0000f2  d103              BNE      |L32.252|
;;;1685         {
;;;1686            sha1functionselect++;
0000f4  9800              LDR      r0,[sp,#0]
0000f6  1c40              ADDS     r0,r0,#1
0000f8  9000              STR      r0,[sp,#0]
;;;1687            sha1counter = 0;
0000fa  2700              MOVS     r7,#0
                  |L32.252|
0000fc  1c64              ADDS     r4,r4,#1              ;1667
                  |L32.254|
0000fe  2c40              CMP      r4,#0x40              ;1667
000100  d3aa              BCC      |L32.88|
;;;1688         }			
;;;1689   
;;;1690      }
;;;1691   
;;;1692      if (!lastblock)
000102  bbc6              CBNZ     r6,|L32.374|
;;;1693      {
;;;1694         // now fix up our H array
;;;1695         H32[0] += a32;
000104  482a              LDR      r0,|L32.432|
000106  6800              LDR      r0,[r0,#0]  ; H32
000108  492a              LDR      r1,|L32.436|
00010a  6809              LDR      r1,[r1,#0]  ; a32
00010c  4408              ADD      r0,r0,r1
00010e  4928              LDR      r1,|L32.432|
000110  6008              STR      r0,[r1,#0]  ; H32
;;;1696         H32[1] += b32;
000112  4608              MOV      r0,r1
000114  6840              LDR      r0,[r0,#4]  ; H32
000116  4928              LDR      r1,|L32.440|
000118  6809              LDR      r1,[r1,#0]  ; b32
00011a  4408              ADD      r0,r0,r1
00011c  4924              LDR      r1,|L32.432|
00011e  6048              STR      r0,[r1,#4]  ; H32
;;;1697         H32[2] += c32;
000120  4608              MOV      r0,r1
000122  6880              LDR      r0,[r0,#8]  ; H32
000124  4925              LDR      r1,|L32.444|
000126  6809              LDR      r1,[r1,#0]  ; c32
000128  4408              ADD      r0,r0,r1
00012a  4921              LDR      r1,|L32.432|
00012c  6088              STR      r0,[r1,#8]  ; H32
;;;1698         H32[3] += d32;
00012e  4608              MOV      r0,r1
000130  68c0              LDR      r0,[r0,#0xc]  ; H32
000132  4923              LDR      r1,|L32.448|
000134  6809              LDR      r1,[r1,#0]  ; d32
000136  4408              ADD      r0,r0,r1
000138  491d              LDR      r1,|L32.432|
00013a  60c8              STR      r0,[r1,#0xc]  ; H32
;;;1699         H32[4] += e32;
00013c  4608              MOV      r0,r1
00013e  6900              LDR      r0,[r0,#0x10]  ; H32
000140  4920              LDR      r1,|L32.452|
000142  6809              LDR      r1,[r1,#0]  ; e32
000144  4408              ADD      r0,r0,r1
000146  491a              LDR      r1,|L32.432|
000148  6108              STR      r0,[r1,#0x10]  ; H32
;;;1700         H32[5] += f32;
00014a  4608              MOV      r0,r1
00014c  6940              LDR      r0,[r0,#0x14]  ; H32
00014e  491e              LDR      r1,|L32.456|
000150  6809              LDR      r1,[r1,#0]  ; f32
000152  4408              ADD      r0,r0,r1
000154  4916              LDR      r1,|L32.432|
000156  6148              STR      r0,[r1,#0x14]  ; H32
;;;1701         H32[6] += g32;
000158  4608              MOV      r0,r1
00015a  6980              LDR      r0,[r0,#0x18]  ; H32
00015c  491b              LDR      r1,|L32.460|
00015e  6809              LDR      r1,[r1,#0]  ; g32
000160  4408              ADD      r0,r0,r1
000162  4913              LDR      r1,|L32.432|
000164  6188              STR      r0,[r1,#0x18]  ; H32
;;;1702         H32[7] += h32;
000166  4608              MOV      r0,r1
000168  69c0              LDR      r0,[r0,#0x1c]  ; H32
00016a  4919              LDR      r1,|L32.464|
00016c  6809              LDR      r1,[r1,#0]  ; h32
00016e  4408              ADD      r0,r0,r1
000170  490f              LDR      r1,|L32.432|
000172  61c8              STR      r0,[r1,#0x1c]  ; H32
000174  e019              B        |L32.426|
                  |L32.374|
000176  e7ff              B        |L32.376|
                  |L32.376|
;;;1703      }
;;;1704      else
;;;1705      {
;;;1706         // now fix up our H array
;;;1707         H32[0] = a32;
000178  480e              LDR      r0,|L32.436|
00017a  6800              LDR      r0,[r0,#0]  ; a32
00017c  490c              LDR      r1,|L32.432|
00017e  6008              STR      r0,[r1,#0]  ; H32
;;;1708         H32[1] = b32;
000180  480d              LDR      r0,|L32.440|
000182  6800              LDR      r0,[r0,#0]  ; b32
000184  6048              STR      r0,[r1,#4]  ; H32
;;;1709         H32[2] = c32;
000186  480d              LDR      r0,|L32.444|
000188  6800              LDR      r0,[r0,#0]  ; c32
00018a  6088              STR      r0,[r1,#8]  ; H32
;;;1710         H32[3] = d32;
00018c  480c              LDR      r0,|L32.448|
00018e  6800              LDR      r0,[r0,#0]  ; d32
000190  60c8              STR      r0,[r1,#0xc]  ; H32
;;;1711         H32[4] = e32;
000192  480c              LDR      r0,|L32.452|
000194  6800              LDR      r0,[r0,#0]  ; e32
000196  6108              STR      r0,[r1,#0x10]  ; H32
;;;1712         H32[5] = f32;
000198  480b              LDR      r0,|L32.456|
00019a  6800              LDR      r0,[r0,#0]  ; f32
00019c  6148              STR      r0,[r1,#0x14]  ; H32
;;;1713         H32[6] = g32;
00019e  480b              LDR      r0,|L32.460|
0001a0  6800              LDR      r0,[r0,#0]  ; g32
0001a2  6188              STR      r0,[r1,#0x18]  ; H32
;;;1714         H32[7] = h32;
0001a4  480a              LDR      r0,|L32.464|
0001a6  6800              LDR      r0,[r0,#0]  ; h32
0001a8  61c8              STR      r0,[r1,#0x1c]  ; H32
                  |L32.426|
;;;1715      }
;;;1716   }
0001aa  e8bd8ffe          POP      {r1-r11,pc}
;;;1717   
                          ENDP

0001ae  0000              DCW      0x0000
                  |L32.432|
                          DCD      H32
                  |L32.436|
                          DCD      a32
                  |L32.440|
                          DCD      b32
                  |L32.444|
                          DCD      ||c32||
                  |L32.448|
                          DCD      ||d32||
                  |L32.452|
                          DCD      e32
                  |L32.456|
                          DCD      ||f32||
                  |L32.460|
                          DCD      g32
                  |L32.464|
                          DCD      h32
                  |L32.468|
                          DCD      SHA_CONSTANTS

                          AREA ||i.sha_bigsigma256_0||, CODE, READONLY, ALIGN=1

                  sha_bigsigma256_0 PROC
;;;1520   //
;;;1521   ulong sha_bigsigma256_0(ulong x)
000000  b530              PUSH     {r4,r5,lr}
;;;1522   {
000002  4604              MOV      r4,r0
;;;1523      return sha_rotr_32(x,2) ^ sha_rotr_32(x,13) ^ sha_rotr_32(x,22);
000004  2102              MOVS     r1,#2
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       sha_rotr_32
00000c  4605              MOV      r5,r0
00000e  210d              MOVS     r1,#0xd
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       sha_rotr_32
000016  4045              EORS     r5,r5,r0
000018  2116              MOVS     r1,#0x16
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       sha_rotr_32
000020  4068              EORS     r0,r0,r5
;;;1524   }
000022  bd30              POP      {r4,r5,pc}
;;;1525   
                          ENDP


                          AREA ||i.sha_bigsigma256_1||, CODE, READONLY, ALIGN=1

                  sha_bigsigma256_1 PROC
;;;1528   //
;;;1529   ulong sha_bigsigma256_1(ulong x)
000000  b530              PUSH     {r4,r5,lr}
;;;1530   {
000002  4604              MOV      r4,r0
;;;1531      return sha_rotr_32(x,6) ^ sha_rotr_32(x,11) ^ sha_rotr_32(x,25);
000004  2106              MOVS     r1,#6
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       sha_rotr_32
00000c  4605              MOV      r5,r0
00000e  210b              MOVS     r1,#0xb
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       sha_rotr_32
000016  4045              EORS     r5,r5,r0
000018  2119              MOVS     r1,#0x19
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       sha_rotr_32
000020  4068              EORS     r0,r0,r5
;;;1532   }
000022  bd30              POP      {r4,r5,pc}
;;;1533   
                          ENDP


                          AREA ||i.sha_ch||, CODE, READONLY, ALIGN=1

                  sha_ch PROC
;;;1483   //
;;;1484   unsigned long sha_ch(unsigned long x, ulong y, ulong z)
000000  b510              PUSH     {r4,lr}
;;;1485   {
000002  4603              MOV      r3,r0
;;;1486      return (x & y) ^ ((~x) & z);
000004  ea030001          AND      r0,r3,r1
000008  ea220403          BIC      r4,r2,r3
00000c  4060              EORS     r0,r0,r4
;;;1487   }
00000e  bd10              POP      {r4,pc}
;;;1488   
                          ENDP


                          AREA ||i.sha_copy32||, CODE, READONLY, ALIGN=1

                  sha_copy32 PROC
;;;1552   //
;;;1553   void sha_copy32(ulong* p1, ulong* p2, ushort length)
000000  e002              B        |L36.8|
                  |L36.2|
;;;1554   {
;;;1555      while (length > 0)
;;;1556      {
;;;1557         *p2++ = *p1++;
000002  c808              LDM      r0!,{r3}
000004  c108              STM      r1!,{r3}
;;;1558         length--;
000006  1e52              SUBS     r2,r2,#1
                  |L36.8|
000008  2a00              CMP      r2,#0                 ;1555
00000a  d1fa              BNE      |L36.2|
;;;1559      }
;;;1560   }
00000c  4770              BX       lr
;;;1561   
                          ENDP


                          AREA ||i.sha_copyWordsToBytes32||, CODE, READONLY, ALIGN=1

                  sha_copyWordsToBytes32 PROC
;;;1564   //
;;;1565   void sha_copyWordsToBytes32(ulong* input, unsigned char* output, ushort numwords)
000000  b530              PUSH     {r4,r5,lr}
;;;1566   {
000002  4603              MOV      r3,r0
;;;1567       ulong temp;
;;;1568       ushort i;
;;;1569   
;;;1570       for (i=0;i<numwords;i++)
000004  2400              MOVS     r4,#0
000006  e00c              B        |L37.34|
                  |L37.8|
;;;1571       {
;;;1572           temp = *input++;
000008  cb01              LDM      r3!,{r0}
;;;1573           *output++ = (uchar)(temp >> 24);
00000a  0e05              LSRS     r5,r0,#24
00000c  f8015b01          STRB     r5,[r1],#1
;;;1574           *output++ = (uchar)(temp >> 16);
000010  0c05              LSRS     r5,r0,#16
000012  f8015b01          STRB     r5,[r1],#1
;;;1575           *output++ = (uchar)(temp >> 8);
000016  0a05              LSRS     r5,r0,#8
000018  f8015b01          STRB     r5,[r1],#1
;;;1576           *output++ = (uchar)(temp);
00001c  f8010b01          STRB     r0,[r1],#1
000020  1c64              ADDS     r4,r4,#1              ;1570
                  |L37.34|
000022  4294              CMP      r4,r2                 ;1570
000024  d3f0              BCC      |L37.8|
;;;1577       }
;;;1578   }
000026  bd30              POP      {r4,r5,pc}
;;;1579   
                          ENDP


                          AREA ||i.sha_getW||, CODE, READONLY, ALIGN=2

                  sha_getW PROC
;;;1602   //
;;;1603   unsigned long sha_getW(int index)
000000  b570              PUSH     {r4-r6,lr}
;;;1604   {
000002  4604              MOV      r4,r0
;;;1605      unsigned long newW;
;;;1606      if (index < 16)
000004  2c10              CMP      r4,#0x10
000006  da03              BGE      |L38.16|
;;;1607      {
;;;1608         return W32[index];
000008  4813              LDR      r0,|L38.88|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
                  |L38.14|
;;;1609      }
;;;1610   
;;;1611      newW = sha_littlesigma256_1(W32[(index-2)&0x0f]) + 
;;;1612               W32[(index-7)&0x0f] + 
;;;1613             sha_littlesigma256_0(W32[(index-15)&0x0f]) + 
;;;1614               W32[(index-16)&0x0f];
;;;1615      W32[index & 0x0f] = newW & 0xFFFFFFFFL;  // just in case...
;;;1616   
;;;1617      return newW;
;;;1618   }
00000e  bd70              POP      {r4-r6,pc}
                  |L38.16|
000010  1ea1              SUBS     r1,r4,#2              ;1611
000012  f001010f          AND      r1,r1,#0xf            ;1611
000016  4a10              LDR      r2,|L38.88|
000018  f8520021          LDR      r0,[r2,r1,LSL #2]     ;1611
00001c  f7fffffe          BL       sha_littlesigma256_1
000020  1fe1              SUBS     r1,r4,#7              ;1611
000022  f001010f          AND      r1,r1,#0xf            ;1611
000026  4a0c              LDR      r2,|L38.88|
000028  f8521021          LDR      r1,[r2,r1,LSL #2]     ;1611
00002c  1846              ADDS     r6,r0,r1              ;1611
00002e  1c61              ADDS     r1,r4,#1              ;1611
000030  f001010f          AND      r1,r1,#0xf            ;1611
000034  f8520021          LDR      r0,[r2,r1,LSL #2]     ;1611
000038  f7fffffe          BL       sha_littlesigma256_0
00003c  1831              ADDS     r1,r6,r0              ;1611
00003e  f004000f          AND      r0,r4,#0xf            ;1611
000042  4a05              LDR      r2,|L38.88|
000044  f8520020          LDR      r0,[r2,r0,LSL #2]     ;1611
000048  180d              ADDS     r5,r1,r0              ;1611
00004a  f004000f          AND      r0,r4,#0xf            ;1615
00004e  4611              MOV      r1,r2                 ;1615
000050  f8415020          STR      r5,[r1,r0,LSL #2]     ;1615
000054  4628              MOV      r0,r5                 ;1617
000056  e7da              B        |L38.14|
;;;1619   
                          ENDP

                  |L38.88|
                          DCD      W32

                          AREA ||i.sha_littlesigma256_0||, CODE, READONLY, ALIGN=1

                  sha_littlesigma256_0 PROC
;;;1536   //
;;;1537   ulong sha_littlesigma256_0(ulong x)
000000  b530              PUSH     {r4,r5,lr}
;;;1538   {
000002  4604              MOV      r4,r0
;;;1539      return sha_rotr_32(x,7) ^ sha_rotr_32(x,18) ^ sha_shr_32(x,3);
000004  2107              MOVS     r1,#7
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       sha_rotr_32
00000c  4605              MOV      r5,r0
00000e  2112              MOVS     r1,#0x12
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       sha_rotr_32
000016  4045              EORS     r5,r5,r0
000018  2103              MOVS     r1,#3
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       sha_shr_32
000020  4068              EORS     r0,r0,r5
;;;1540   }
000022  bd30              POP      {r4,r5,pc}
;;;1541   
                          ENDP


                          AREA ||i.sha_littlesigma256_1||, CODE, READONLY, ALIGN=1

                  sha_littlesigma256_1 PROC
;;;1544   //
;;;1545   ulong sha_littlesigma256_1(ulong x)
000000  b530              PUSH     {r4,r5,lr}
;;;1546   {
000002  4604              MOV      r4,r0
;;;1547      return sha_rotr_32(x,17) ^ sha_rotr_32(x,19) ^ sha_shr_32(x,10);
000004  2111              MOVS     r1,#0x11
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       sha_rotr_32
00000c  4605              MOV      r5,r0
00000e  2113              MOVS     r1,#0x13
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       sha_rotr_32
000016  4045              EORS     r5,r5,r0
000018  210a              MOVS     r1,#0xa
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       sha_shr_32
000020  4068              EORS     r0,r0,r5
;;;1548   }
000022  bd30              POP      {r4,r5,pc}
;;;1549   
                          ENDP


                          AREA ||i.sha_maj||, CODE, READONLY, ALIGN=1

                  sha_maj PROC
;;;1491   //
;;;1492   ulong sha_maj(ulong x, ulong y, ulong z)
000000  b510              PUSH     {r4,lr}
;;;1493   {
000002  4603              MOV      r3,r0
;;;1494      ulong temp = x & y;
000004  ea030001          AND      r0,r3,r1
;;;1495      temp ^= (x & z);
000008  ea030402          AND      r4,r3,r2
00000c  4060              EORS     r0,r0,r4
;;;1496      temp ^= (y & z);
00000e  ea010402          AND      r4,r1,r2
000012  4060              EORS     r0,r0,r4
;;;1497      return temp;  //(x & y) ^ (x & z) ^ (y & z);
;;;1498   }
000014  bd10              POP      {r4,pc}
;;;1499   
                          ENDP


                          AREA ||i.sha_prepareSchedule||, CODE, READONLY, ALIGN=2

                  sha_prepareSchedule PROC
;;;1622   //
;;;1623   void sha_prepareSchedule(unsigned char* message)
000000  b510              PUSH     {r4,lr}
;;;1624   {
;;;1625      // we need to copy the initial message into the 16 W registers
;;;1626      unsigned char i,j;
;;;1627      unsigned long temp;
;;;1628      for (i = 0; i < 16; i++)
000002  2100              MOVS     r1,#0
000004  e00f              B        |L42.38|
                  |L42.6|
;;;1629      {
;;;1630         temp = 0;
000006  2200              MOVS     r2,#0
;;;1631         for (j = 0; j < 4;j++)
000008  2300              MOVS     r3,#0
00000a  e005              B        |L42.24|
                  |L42.12|
;;;1632         {
;;;1633            temp = temp << 8;
00000c  0212              LSLS     r2,r2,#8
;;;1634            temp = temp | (*message & 0xff);
00000e  7804              LDRB     r4,[r0,#0]
000010  4322              ORRS     r2,r2,r4
;;;1635            message++;
000012  1c40              ADDS     r0,r0,#1
000014  1c5c              ADDS     r4,r3,#1              ;1631
000016  b2e3              UXTB     r3,r4                 ;1631
                  |L42.24|
000018  2b04              CMP      r3,#4                 ;1631
00001a  dbf7              BLT      |L42.12|
;;;1636         }
;;;1637   
;;;1638         W32[i] = temp;
00001c  4c03              LDR      r4,|L42.44|
00001e  f8442021          STR      r2,[r4,r1,LSL #2]
000022  1c4c              ADDS     r4,r1,#1              ;1628
000024  b2e1              UXTB     r1,r4                 ;1628
                  |L42.38|
000026  2910              CMP      r1,#0x10              ;1628
000028  dbed              BLT      |L42.6|
;;;1639      }
;;;1640   }
00002a  bd10              POP      {r4,pc}
;;;1641   
                          ENDP

                  |L42.44|
                          DCD      W32

                          AREA ||i.sha_rotr_32||, CODE, READONLY, ALIGN=1

                  sha_rotr_32 PROC
;;;1502   //
;;;1503   ulong sha_rotr_32(ulong val, ushort r)
000000  4602              MOV      r2,r0
;;;1504   {
;;;1505      val = val & 0xFFFFFFFFL;
000002  bf00              NOP      
;;;1506      return ((val >> r) | (val << (32 - r))) & 0xFFFFFFFFL;
000004  fa22f001          LSR      r0,r2,r1
000008  f1c10320          RSB      r3,r1,#0x20
00000c  fa02f303          LSL      r3,r2,r3
000010  4318              ORRS     r0,r0,r3
;;;1507   }
000012  4770              BX       lr
;;;1508   
                          ENDP


                          AREA ||i.sha_shr_32||, CODE, READONLY, ALIGN=1

                  sha_shr_32 PROC
;;;1511   //
;;;1512   ulong sha_shr_32(ulong val, ushort r)
000000  4602              MOV      r2,r0
;;;1513   {
;;;1514      val = val & 0xFFFFFFFFL;
000002  bf00              NOP      
;;;1515      return val >> r;
000004  fa22f001          LSR      r0,r2,r1
;;;1516   }
000008  4770              BX       lr
;;;1517   
                          ENDP


                          AREA ||i.sha_writeResult||, CODE, READONLY, ALIGN=2

                  sha_writeResult PROC
;;;1582   //
;;;1583   void sha_writeResult(ushort reverse, uchar* outpointer)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1584   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1585      unsigned char i,tmp;;
;;;1586      sha_copyWordsToBytes32(H32, outpointer, 8); 
000006  2208              MOVS     r2,#8
000008  4629              MOV      r1,r5
00000a  4809              LDR      r0,|L45.48|
00000c  f7fffffe          BL       sha_copyWordsToBytes32
;;;1587   
;;;1588      if (reverse)
000010  b16e              CBZ      r6,|L45.46|
;;;1589      {
;;;1590         for (i = 0; i < 16; i++)
000012  2400              MOVS     r4,#0
000014  e009              B        |L45.42|
                  |L45.22|
;;;1591         {  
;;;1592            tmp = outpointer[i];
000016  5d2f              LDRB     r7,[r5,r4]
;;;1593            outpointer[i] = outpointer[31-i];
000018  f1c4001f          RSB      r0,r4,#0x1f
00001c  5c28              LDRB     r0,[r5,r0]
00001e  5528              STRB     r0,[r5,r4]
;;;1594            outpointer[31-i] = tmp;
000020  f1c4001f          RSB      r0,r4,#0x1f
000024  542f              STRB     r7,[r5,r0]
000026  1c60              ADDS     r0,r4,#1              ;1590
000028  b2c4              UXTB     r4,r0                 ;1590
                  |L45.42|
00002a  2c10              CMP      r4,#0x10              ;1590
00002c  dbf3              BLT      |L45.22|
                  |L45.46|
;;;1595         }
;;;1596      }
;;;1597   
;;;1598   }
00002e  bdf0              POP      {r4-r7,pc}
;;;1599   
                          ENDP

                  |L45.48|
                          DCD      H32

                          AREA ||i.write_bit||, CODE, READONLY, ALIGN=2

                  write_bit PROC
;;;470    
;;;471    void write_bit(char bitval)
000000  b510              PUSH     {r4,lr}
;;;472    {
000002  4604              MOV      r4,r0
;;;473            One_Wire_IO_Direction(OUTPUTDATA);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       One_Wire_IO_Direction
;;;474            GPIO_ResetBits(One_Wire, One_Wire_IO);
00000a  2108              MOVS     r1,#8
00000c  480a              LDR      r0,|L46.56|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;475            Delay_us(1);                                //waiting for 1 us
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       Delay_us
;;;476    
;;;477            if(bitval!=0)
000018  b11c              CBZ      r4,|L46.34|
;;;478            GPIO_SetBits(One_Wire, One_Wire_IO);
00001a  2108              MOVS     r1,#8
00001c  4806              LDR      r0,|L46.56|
00001e  f7fffffe          BL       GPIO_SetBits
                  |L46.34|
;;;479            Delay_us(12);                              // waiting for 12us      
000022  200c              MOVS     r0,#0xc
000024  f7fffffe          BL       Delay_us
;;;480            GPIO_SetBits(One_Wire, One_Wire_IO);       // restore 1-wire data pin to high  
000028  2108              MOVS     r1,#8
00002a  4803              LDR      r0,|L46.56|
00002c  f7fffffe          BL       GPIO_SetBits
;;;481         
;;;482    				Delay_us(10); 
000030  200a              MOVS     r0,#0xa
000032  f7fffffe          BL       Delay_us
;;;483    }
000036  bd10              POP      {r4,pc}
;;;484    
                          ENDP

                  |L46.56|
                          DCD      0x40010800

                          AREA ||i.write_byte||, CODE, READONLY, ALIGN=1

                  write_byte PROC
;;;511    */
;;;512    void write_byte(char val)
000000  b570              PUSH     {r4-r6,lr}
;;;513    {
000002  4606              MOV      r6,r0
;;;514    	unsigned char i;
;;;515    	unsigned char temp; 
;;;516    
;;;517    	for (i = 0; i < 8; i++) // writes byte, one bit at a time
000004  2400              MOVS     r4,#0
000006  e008              B        |L47.26|
                  |L47.8|
;;;518    		{
;;;519    			temp = val>>i; // shifts val right i spaces
000008  fa46f504          ASR      r5,r6,r4
;;;520    			temp &= 0x01; // copy that bit to temp
00000c  f0050501          AND      r5,r5,#1
;;;521    			write_bit(temp); // write bit in temp into
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       write_bit
000016  1c60              ADDS     r0,r4,#1              ;517
000018  b2c4              UXTB     r4,r0                 ;517
                  |L47.26|
00001a  2c08              CMP      r4,#8                 ;517
00001c  dbf4              BLT      |L47.8|
;;;522    		}
;;;523    
;;;524    }
00001e  bd70              POP      {r4-r6,pc}
;;;525    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  SECRET
                          %        32
                  W32
                          %        64
                  H32
                          %        32
                  SHAVM_Hash
                          %        20
                  SHAVM_Message
                          %        64
                  Secret_256bit
                          %        32
                  MAC_Computer_Datainput
                          %        120
                  workbuffer
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  SHA_256_Initial
                          DCD      0x6a09e667
                          DCD      0xbb67ae85
                          DCD      0x3c6ef372
                          DCD      0xa54ff53a
                          DCD      0x510e527f
                          DCD      0x9b05688c
                          DCD      0x1f83d9ab
                          DCD      0x5be0cd19
                  SHA_CONSTANTS
                          DCD      0x428a2f98
                          DCD      0x71374491
                          DCD      0xb5c0fbcf
                          DCD      0xe9b5dba5
                          DCD      0x3956c25b
                          DCD      0x59f111f1
                          DCD      0x923f82a4
                          DCD      0xab1c5ed5
                          DCD      0xd807aa98
                          DCD      0x12835b01
                          DCD      0x243185be
                          DCD      0x550c7dc3
                          DCD      0x72be5d74
                          DCD      0x80deb1fe
                          DCD      0x9bdc06a7
                          DCD      0xc19bf174
                          DCD      0xe49b69c1
                          DCD      0xefbe4786
                          DCD      0x0fc19dc6
                          DCD      0x240ca1cc
                          DCD      0x2de92c6f
                          DCD      0x4a7484aa
                          DCD      0x5cb0a9dc
                          DCD      0x76f988da
                          DCD      0x983e5152
                          DCD      0xa831c66d
                          DCD      0xb00327c8
                          DCD      0xbf597fc7
                          DCD      0xc6e00bf3
                          DCD      0xd5a79147
                          DCD      0x06ca6351
                          DCD      0x14292967
                          DCD      0x27b70a85
                          DCD      0x2e1b2138
                          DCD      0x4d2c6dfc
                          DCD      0x53380d13
                          DCD      0x650a7354
                          DCD      0x766a0abb
                          DCD      0x81c2c92e
                          DCD      0x92722c85
                          DCD      0xa2bfe8a1
                          DCD      0xa81a664b
                          DCD      0xc24b8b70
                          DCD      0xc76c51a3
                          DCD      0xd192e819
                          DCD      0xd6990624
                          DCD      0xf40e3585
                          DCD      0x106aa070
                          DCD      0x19a4c116
                          DCD      0x1e376c08
                          DCD      0x2748774c
                          DCD      0x34b0bcb5
                          DCD      0x391c0cb3
                          DCD      0x4ed8aa4a
                          DCD      0x5b9cca4f
                          DCD      0x682e6ff3
                          DCD      0x748f82ee
                          DCD      0x78a5636f
                          DCD      0x84c87814
                          DCD      0x8cc70208
                          DCD      0x90befffa
                          DCD      0xa4506ceb
                          DCD      0xbef9a3f7
                          DCD      0xc67178f2
                          DCD      0xca273ece
                          DCD      0xd186b8c7
                          DCD      0xeada7dd6
                          DCD      0xf57d4f7f
                          DCD      0x06f067aa
                          DCD      0x0a637dc5
                          DCD      0x113f9804
                          DCD      0x1b710b35
                          DCD      0x28db77f5
                          DCD      0x32caab7b
                          DCD      0x3c9ebe0a
                          DCD      0x431d67c4
                          DCD      0x4cc5d4be
                          DCD      0x597f299c
                          DCD      0x5fcb6fab
                          DCD      0x6c44198c
                  dscrc_table
000160  005ebce2          DCB      0x00,0x5e,0xbc,0xe2
000164  613fdd83          DCB      0x61,0x3f,0xdd,0x83
000168  c29c7e20          DCB      0xc2,0x9c,0x7e,0x20
00016c  a3fd1f41          DCB      0xa3,0xfd,0x1f,0x41
000170  9dc3217f          DCB      0x9d,0xc3,0x21,0x7f
000174  fca2401e          DCB      0xfc,0xa2,0x40,0x1e
000178  5f01e3bd          DCB      0x5f,0x01,0xe3,0xbd
00017c  3e6082dc          DCB      0x3e,0x60,0x82,0xdc
000180  237d9fc1          DCB      0x23,0x7d,0x9f,0xc1
000184  421cfea0          DCB      0x42,0x1c,0xfe,0xa0
000188  e1bf5d03          DCB      0xe1,0xbf,0x5d,0x03
00018c  80de3c62          DCB      0x80,0xde,0x3c,0x62
000190  bee0025c          DCB      0xbe,0xe0,0x02,0x5c
000194  df81633d          DCB      0xdf,0x81,0x63,0x3d
000198  7c22c09e          DCB      0x7c,0x22,0xc0,0x9e
00019c  1d43a1ff          DCB      0x1d,0x43,0xa1,0xff
0001a0  4618faa4          DCB      0x46,0x18,0xfa,0xa4
0001a4  27799bc5          DCB      0x27,0x79,0x9b,0xc5
0001a8  84da3866          DCB      0x84,0xda,0x38,0x66
0001ac  e5bb5907          DCB      0xe5,0xbb,0x59,0x07
0001b0  db856739          DCB      0xdb,0x85,0x67,0x39
0001b4  bae40658          DCB      0xba,0xe4,0x06,0x58
0001b8  1947a5fb          DCB      0x19,0x47,0xa5,0xfb
0001bc  7826c49a          DCB      0x78,0x26,0xc4,0x9a
0001c0  653bd987          DCB      0x65,0x3b,0xd9,0x87
0001c4  045ab8e6          DCB      0x04,0x5a,0xb8,0xe6
0001c8  a7f91b45          DCB      0xa7,0xf9,0x1b,0x45
0001cc  c6987a24          DCB      0xc6,0x98,0x7a,0x24
0001d0  f8a6441a          DCB      0xf8,0xa6,0x44,0x1a
0001d4  99c7257b          DCB      0x99,0xc7,0x25,0x7b
0001d8  3a6486d8          DCB      0x3a,0x64,0x86,0xd8
0001dc  5b05e7b9          DCB      0x5b,0x05,0xe7,0xb9
0001e0  8cd2306e          DCB      0x8c,0xd2,0x30,0x6e
0001e4  edb3510f          DCB      0xed,0xb3,0x51,0x0f
0001e8  4e10f2ac          DCB      0x4e,0x10,0xf2,0xac
0001ec  2f7193cd          DCB      0x2f,0x71,0x93,0xcd
0001f0  114fadf3          DCB      0x11,0x4f,0xad,0xf3
0001f4  702ecc92          DCB      0x70,0x2e,0xcc,0x92
0001f8  d38d6f31          DCB      0xd3,0x8d,0x6f,0x31
0001fc  b2ec0e50          DCB      0xb2,0xec,0x0e,0x50
000200  aff1134d          DCB      0xaf,0xf1,0x13,0x4d
000204  ce90722c          DCB      0xce,0x90,0x72,0x2c
000208  6d33d18f          DCB      0x6d,0x33,0xd1,0x8f
00020c  0c52b0ee          DCB      0x0c,0x52,0xb0,0xee
000210  326c8ed0          DCB      0x32,0x6c,0x8e,0xd0
000214  530defb1          DCB      0x53,0x0d,0xef,0xb1
000218  f0ae4c12          DCB      0xf0,0xae,0x4c,0x12
00021c  91cf2d73          DCB      0x91,0xcf,0x2d,0x73
000220  ca947628          DCB      0xca,0x94,0x76,0x28
000224  abf51749          DCB      0xab,0xf5,0x17,0x49
000228  0856b4ea          DCB      0x08,0x56,0xb4,0xea
00022c  6937d58b          DCB      0x69,0x37,0xd5,0x8b
000230  5709ebb5          DCB      0x57,0x09,0xeb,0xb5
000234  36688ad4          DCB      0x36,0x68,0x8a,0xd4
000238  95cb2977          DCB      0x95,0xcb,0x29,0x77
00023c  f4aa4816          DCB      0xf4,0xaa,0x48,0x16
000240  e9b7550b          DCB      0xe9,0xb7,0x55,0x0b
000244  88d6346a          DCB      0x88,0xd6,0x34,0x6a
000248  2b7597c9          DCB      0x2b,0x75,0x97,0xc9
00024c  4a14f6a8          DCB      0x4a,0x14,0xf6,0xa8
000250  742ac896          DCB      0x74,0x2a,0xc8,0x96
000254  154ba9f7          DCB      0x15,0x4b,0xa9,0xf7
000258  b6e80a54          DCB      0xb6,0xe8,0x0a,0x54
00025c  d7896b35          DCB      0xd7,0x89,0x6b,0x35
                  oddparity
000260  00000001          DCW      0x0000,0x0001
000264  00010000          DCW      0x0001,0x0000
000268  00010000          DCW      0x0001,0x0000
00026c  00000001          DCW      0x0000,0x0001
000270  00010000          DCW      0x0001,0x0000
000274  00000001          DCW      0x0000,0x0001
000278  00000001          DCW      0x0000,0x0001
00027c  00010000          DCW      0x0001,0x0000
                  reverse_endian
                          DCD      0x00000001
                  sha_debug
                          DCD      0x00000000
                  a32
                          DCD      0x00000000
                  b32
                          DCD      0x00000000
                  ||c32||
                          DCD      0x00000000
                  ||d32||
                          DCD      0x00000000
                  e32
                          DCD      0x00000000
                  ||f32||
                          DCD      0x00000000
                  g32
                          DCD      0x00000000
                  h32
                          DCD      0x00000000
                  CRC8
0002a8  00                DCB      0x00
                  blockindex
0002a9  00                DCB      0x00
                  segmentindex
0002aa  00                DCB      0x00
                  pageindex
0002ab  00                DCB      0x00
                  CRC16
                          DCD      0x00000000
                  RomID_Buffer
                          %        8
                  Personality_Value
0002b8  0000              DCB      0x00,0x00
                  BoolValue
0002ba  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_DS28E11.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_bsp_DS28E11_c_d724f1e6____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_DS28E11_c_d724f1e6____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_bsp_DS28E11_c_d724f1e6____REVSH|
#line 128
|__asm___13_bsp_DS28E11_c_d724f1e6____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
